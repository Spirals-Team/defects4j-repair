# Summary

BugId             | NopolPC | NopolC | Genprog | Kali | Total
----------------- | ------- | ------ | ------- | ---- | ------
[L44](#lang-44)   | Yes     | No     | No      | No   | 1
[L46](#lang-46)   | Yes     | No     | No      | No   | 1
[L51](#lang-51)   | No      | Yes    | No      | No   | 1
[L55](#lang-55)   | Yes     | No     | No      | No   | 1
[L58](#lang-58)   | Yes     | Yes    | No      | No   | 2
[C5](#chart-5)    | No      | Yes    | No      | No   | 1
[C9](#chart-9)    | Yes     | Yes    | No      | No   | 2
[C13](#chart-13)  | Yes     | No     | No      | No   | 1
[C17](#chart-17)  | Yes     | Yes    | No      | No   | 2
[C21](#chart-21)  | Yes     | No     | No      | No   | 1
[C25](#chart-25)  | Yes     | Yes    | No      | No   | 2
[M2](#math-2)     | No      | No     | Yes     | Yes  | 2
[M8](#math-8)     | No      | No     | Yes     | Yes  | 2
[M32](#math-32)   | Yes     | No     | No      | No   | 1
[M33](#math-33)   | Yes     | Yes    | No      | No   | 2
[M40](#math-40)   | No      | Yes    | Yes     | No   | 2
[M41](#math-41)   | Yes     | Yes    | No      | No   | 2
[M42](#math-42)   | Yes     | No     | No      | No   | 1
[M44](#math-44)   | No      | No     | Yes     | No   | 1
[M49](#math-49)   | Yes     | No     | Yes     | Yes  | 3
[M50](#math-50)   | Yes     | Yes    | Yes     | Yes  | 4
[M57](#math-57)   | No      | Yes    | No      | No   | 1
[M58](#math-58)   | No      | Yes    | No      | No   | 1
[M64](#math-64)   | No      | No     | Yes     | No   | 1
[M69](#math-69)   | Yes     | No     | No      | No   | 1
[M70](#math-70)   | No      | No     | Yes     | No   | 1
[M73](#math-73)   | No      | Yes    | Yes     | No   | 2
[M78](#math-78)   | Yes     | No     | Yes     | Yes  | 3
[M79](#math-79)   | Yes     | No     | No      | No   | 1
[M80](#math-80)   | Yes     | No     | Yes     | Yes  | 3
[M81](#math-81)   | Yes     | Yes    | Yes     | Yes  | 4
[M82](#math-82)   | Yes     | No     | Yes     | Yes  | 3
[M84](#math-84)   | No      | No     | Yes     | No   | 1
[M85](#math-85)   | No      | Yes    | Yes     | Yes  | 3
[M87](#math-87)   | Yes     | Yes    | No      | No   | 2
[M88](#math-88)   | Yes     | No     | No      | No   | 1
[M95](#math-95)   | No      | No     | Yes     | No   | 1
[M97](#math-97)   | Yes     | Yes    | No      | No   | 2
[M99](#math-99)   | Yes     | Yes    | No      | No   | 2
[M104](#math-104) | No      | Yes    | No      | No   | 1
[M105](#math-105) | Yes     | No     | No      | No   | 1
Total             | 26 (11%) | 19 (8%) | 16 (7%) | 9 (4%) | 70
Fixed bugs: 41/224 (18%)

# Complete data

BugId             | NopolPC | NopolC | Genprog | Kali | Total
----------------- | ------- | ------ | ------- | ---- | ------
[L1](#lang-1)     | No      | No     | TIMEOUT | No   | 0
[L2](#lang-2)     | No      | No     | TIMEOUT | No   | 0
[L3](#lang-3)     | No      | No     | TIMEOUT | No   | 0
[L4](#lang-4)     | No      | No     | TIMEOUT | No   | 0
[L5](#lang-5)     | No      | No     | TIMEOUT | No   | 0
[L6](#lang-6)     | No      | No     | TIMEOUT | No   | 0
[L7](#lang-7)     | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[L8](#lang-8)     | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[L9](#lang-9)     | TIMEOUT | No     | TIMEOUT | No   | 0
[L10](#lang-10)   | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[L11](#lang-11)   | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[L12](#lang-12)   | No      | No     | TIMEOUT | No   | 0
[L13](#lang-13)   | No      | No     | TIMEOUT | No   | 0
[L14](#lang-14)   | No      | No     | TIMEOUT | No   | 0
[L15](#lang-15)   | No      | No     | TIMEOUT | No   | 0
[L16](#lang-16)   | No      | No     | TIMEOUT | No   | 0
[L17](#lang-17)   | No      | No     | TIMEOUT | No   | 0
[L18](#lang-18)   | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[L19](#lang-19)   | No      | No     | TIMEOUT | No   | 0
[L20](#lang-20)   | No      | No     | No      | No   | 0
[L21](#lang-21)   | No      | No     | No      | No   | 0
[L22](#lang-22)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L23](#lang-23)   | TIMEOUT | ERROR  | No      | No   | 0
[L24](#lang-24)   | TIMEOUT | No     | No      | No   | 0
[L25](#lang-25)   | No      | No     | No      | No   | 0
[L26](#lang-26)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L27](#lang-27)   | No      | No     | No      | No   | 0
[L28](#lang-28)   | No      | No     | No      | No   | 0
[L29](#lang-29)   | No      | No     | No      | No   | 0
[L30](#lang-30)   | No      | No     | No      | No   | 0
[L31](#lang-31)   | No      | No     | No      | No   | 0
[L32](#lang-32)   | No      | No     | No      | No   | 0
[L33](#lang-33)   | No      | No     | No      | No   | 0
[L34](#lang-34)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L35](#lang-35)   | No      | No     | No      | No   | 0
[L36](#lang-36)   | No      | No     | No      | No   | 0
[L37](#lang-37)   | No      | No     | No      | No   | 0
[L38](#lang-38)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L39](#lang-39)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L40](#lang-40)   | No      | No     | No      | No   | 0
[L41](#lang-41)   | No      | No     | No      | No   | 0
[L42](#lang-42)   | No      | No     | No      | No   | 0
[L43](#lang-43)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L44](#lang-44)   | Yes     | TIMEOUT | No      | No   | 1
[L45](#lang-45)   | No      | No     | No      | No   | 0
[L46](#lang-46)   | Yes     | No     | No      | No   | 1
[L47](#lang-47)   | No      | No     | No      | No   | 0
[L48](#lang-48)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L49](#lang-49)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L50](#lang-50)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L51](#lang-51)   | No      | Yes    | No      | No   | 1
[L52](#lang-52)   | No      | No     | No      | No   | 0
[L53](#lang-53)   | TIMEOUT | TIMEOUT | No      | No   | 0
[L54](#lang-54)   | No      | No     | No      | No   | 0
[L55](#lang-55)   | Yes     | No     | No      | No   | 1
[L56](#lang-56)   | No      | No     | No      | No   | 0
[L57](#lang-57)   | No      | No     | No      | No   | 0
[L58](#lang-58)   | Yes     | Yes    | No      | No   | 2
[L59](#lang-59)   | No      | No     | No      | No   | 0
[L60](#lang-60)   | No      | No     | No      | No   | 0
[L61](#lang-61)   | No      | No     | No      | No   | 0
[L62](#lang-62)   | No      | No     | No      | No   | 0
[L63](#lang-63)   | ERROR   | No     | No      | No   | 0
[L64](#lang-64)   | No      | No     | No      | No   | 0
[L65](#lang-65)   | No      | No     | No      | No   | 0
[C1](#chart-1)    | No      | No     | TIMEOUT | No   | 0
[C2](#chart-2)    | No      | No     | TIMEOUT | No   | 0
[C3](#chart-3)    | No      | TIMEOUT | TIMEOUT | No   | 0
[C4](#chart-4)    | No      | TIMEOUT | TIMEOUT | No   | 0
[C5](#chart-5)    | No      | Yes    | TIMEOUT | No   | 1
[C6](#chart-6)    | TIMEOUT | No     | TIMEOUT | No   | 0
[C7](#chart-7)    | No      | No     | TIMEOUT | No   | 0
[C8](#chart-8)    | ERROR   | ERROR  | No      | ERROR | 0
[C9](#chart-9)    | Yes     | Yes    | TIMEOUT | No   | 2
[C10](#chart-10)  | No      | No     | TIMEOUT | No   | 0
[C11](#chart-11)  | No      | No     | TIMEOUT | No   | 0
[C12](#chart-12)  | No      | No     | TIMEOUT | No   | 0
[C13](#chart-13)  | Yes     | TIMEOUT | TIMEOUT | No   | 1
[C14](#chart-14)  | No      | No     | TIMEOUT | No   | 0
[C15](#chart-15)  | No      | No     | TIMEOUT | No   | 0
[C16](#chart-16)  | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[C17](#chart-17)  | Yes     | Yes    | TIMEOUT | No   | 2
[C18](#chart-18)  | No      | No     | TIMEOUT | No   | 0
[C19](#chart-19)  | No      | No     | TIMEOUT | No   | 0
[C20](#chart-20)  | No      | No     | TIMEOUT | No   | 0
[C21](#chart-21)  | Yes     | No     | TIMEOUT | No   | 1
[C22](#chart-22)  | No      | No     | TIMEOUT | No   | 0
[C23](#chart-23)  | No      | No     | TIMEOUT | No   | 0
[C24](#chart-24)  | No      | No     | TIMEOUT | No   | 0
[C25](#chart-25)  | Yes     | Yes    | TIMEOUT | No   | 2
[C26](#chart-26)  | TIMEOUT | TIMEOUT | TIMEOUT | No   | 0
[M1](#math-1)     | No      | No     | No      | No   | 0
[M2](#math-2)     | TIMEOUT | TIMEOUT | Yes     | Yes  | 2
[M3](#math-3)     | No      | No     | No      | No   | 0
[M4](#math-4)     | TIMEOUT | TIMEOUT | No      | No   | 0
[M5](#math-5)     | No      | No     | No      | No   | 0
[M6](#math-6)     | TIMEOUT | TIMEOUT | No      | ERROR | 0
[M7](#math-7)     | TIMEOUT | TIMEOUT | No      | No   | 0
[M8](#math-8)     | No      | TIMEOUT | Yes     | Yes  | 2
[M9](#math-9)     | No      | No     | No      | No   | 0
[M10](#math-10)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M11](#math-11)   | No      | TIMEOUT | No      | No   | 0
[M12](#math-12)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M13](#math-13)   | No      | No     | No      | No   | 0
[M14](#math-14)   | No      | No     | No      | No   | 0
[M15](#math-15)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M16](#math-16)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M17](#math-17)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M18](#math-18)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M19](#math-19)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M20](#math-20)   | TIMEOUT | TIMEOUT | No      | ERROR | 0
[M21](#math-21)   | No      | No     | No      | No   | 0
[M22](#math-22)   | No      | TIMEOUT | No      | No   | 0
[M23](#math-23)   | No      | TIMEOUT | No      | No   | 0
[M24](#math-24)   | TIMEOUT | No     | No      | No   | 0
[M25](#math-25)   | No      | No     | No      | No   | 0
[M26](#math-26)   | No      | TIMEOUT | No      | No   | 0
[M27](#math-27)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M28](#math-28)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M29](#math-29)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M30](#math-30)   | No      | No     | No      | No   | 0
[M31](#math-31)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M32](#math-32)   | Yes     | TIMEOUT | No      | No   | 1
[M33](#math-33)   | Yes     | Yes    | No      | No   | 2
[M34](#math-34)   | No      | No     | No      | No   | 0
[M35](#math-35)   | ERROR   | ERROR  | No      | ERROR | 0
[M36](#math-36)   | No      | No     | No      | No   | 0
[M37](#math-37)   | ERROR   | TIMEOUT | No      | No   | 0
[M38](#math-38)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M39](#math-39)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M40](#math-40)   | TIMEOUT | Yes    | Yes     | No   | 2
[M41](#math-41)   | Yes     | Yes    | No      | No   | 2
[M42](#math-42)   | Yes     | TIMEOUT | No      | No   | 1
[M43](#math-43)   | No      | TIMEOUT | No      | No   | 0
[M44](#math-44)   | TIMEOUT | TIMEOUT | Yes     | No   | 1
[M45](#math-45)   | No      | No     | No      | No   | 0
[M46](#math-46)   | No      | No     | No      | No   | 0
[M47](#math-47)   | No      | TIMEOUT | No      | No   | 0
[M48](#math-48)   | TIMEOUT | No     | No      | No   | 0
[M49](#math-49)   | Yes     | No     | Yes     | Yes  | 3
[M50](#math-50)   | Yes     | Yes    | Yes     | Yes  | 4
[M51](#math-51)   | TIMEOUT | No     | No      | ERROR | 0
[M52](#math-52)   | No      | No     | No      | No   | 0
[M53](#math-53)   | No      | No     | No      | No   | 0
[M54](#math-54)   | TIMEOUT | TIMEOUT | No      | EMPTY | 0
[M55](#math-55)   | No      | No     | No      | No   | 0
[M56](#math-56)   | TIMEOUT | No     | No      | No   | 0
[M57](#math-57)   | TIMEOUT | Yes    | No      | No   | 1
[M58](#math-58)   | TIMEOUT | Yes    | No      | No   | 1
[M59](#math-59)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M60](#math-60)   | TIMEOUT | No     | No      | No   | 0
[M61](#math-61)   | No      | No     | No      | No   | 0
[M62](#math-62)   | No      | No     | No      | No   | 0
[M63](#math-63)   | No      | No     | No      | No   | 0
[M64](#math-64)   | TIMEOUT | TIMEOUT | Yes     | No   | 1
[M65](#math-65)   | No      | No     | No      | No   | 0
[M66](#math-66)   | No      | No     | No      | No   | 0
[M67](#math-67)   | No      | No     | No      | No   | 0
[M68](#math-68)   | TIMEOUT | No     | No      | No   | 0
[M69](#math-69)   | Yes     | No     | No      | No   | 1
[M70](#math-70)   | No      | No     | Yes     | No   | 1
[M71](#math-71)   | TIMEOUT | TIMEOUT | No      | ERROR | 0
[M72](#math-72)   | No      | No     | No      | No   | 0
[M73](#math-73)   | No      | Yes    | Yes     | No   | 2
[M74](#math-74)   | TIMEOUT | TIMEOUT | No      | EMPTY | 0
[M75](#math-75)   | No      | No     | No      | No   | 0
[M76](#math-76)   | No      | No     | No      | No   | 0
[M77](#math-77)   | No      | No     | No      | No   | 0
[M78](#math-78)   | Yes     | TIMEOUT | Yes     | Yes  | 3
[M79](#math-79)   | Yes     | No     | No      | No   | 1
[M80](#math-80)   | Yes     | TIMEOUT | Yes     | Yes  | 3
[M81](#math-81)   | Yes     | Yes    | Yes     | Yes  | 4
[M82](#math-82)   | Yes     | No     | Yes     | Yes  | 3
[M83](#math-83)   | No      | No     | No      | No   | 0
[M84](#math-84)   | No      | No     | Yes     | No   | 1
[M85](#math-85)   | TIMEOUT | Yes    | Yes     | Yes  | 3
[M86](#math-86)   | TIMEOUT | No     | No      | No   | 0
[M87](#math-87)   | Yes     | Yes    | No      | No   | 2
[M88](#math-88)   | Yes     | TIMEOUT | No      | No   | 1
[M89](#math-89)   | No      | No     | No      | No   | 0
[M90](#math-90)   | No      | No     | No      | No   | 0
[M91](#math-91)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M92](#math-92)   | No      | No     | No      | No   | 0
[M93](#math-93)   | No      | No     | No      | No   | 0
[M94](#math-94)   | TIMEOUT | TIMEOUT | No      | No   | 0
[M95](#math-95)   | ERROR   | No     | Yes     | No   | 1
[M96](#math-96)   | No      | No     | No      | No   | 0
[M97](#math-97)   | Yes     | Yes    | No      | No   | 2
[M98](#math-98)   | No      | No     | No      | No   | 0
[M99](#math-99)   | Yes     | Yes    | No      | No   | 2
[M100](#math-100) | No      | No     | No      | No   | 0
[M101](#math-101) | No      | No     | No      | No   | 0
[M102](#math-102) | TIMEOUT | No     | No      | No   | 0
[M103](#math-103) | No      | No     | No      | No   | 0
[M104](#math-104) | TIMEOUT | Yes    | No      | No   | 1
[M105](#math-105) | Yes     | No     | No      | No   | 1
[M106](#math-106) | No      | TIMEOUT | No      | No   | 0
[T1](#time-1)     | No      | TIMEOUT | No      | No   | 0
[T2](#time-2)     | No      | No     | No      | No   | 0
[T3](#time-3)     | TIMEOUT | TIMEOUT | No      | No   | 0
[T4](#time-4)     | No      | No     | No      | No   | 0
[T5](#time-5)     | TIMEOUT | No     | No      | No   | 0
[T6](#time-6)     | No      | TIMEOUT | No      | No   | 0
[T7](#time-7)     | TIMEOUT | TIMEOUT | No      | No   | 0
[T8](#time-8)     | No      | No     | No      | No   | 0
[T9](#time-9)     | No      | No     | No      | No   | 0
[T10](#time-10)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T11](#time-11)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T12](#time-12)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T13](#time-13)   | No      | TIMEOUT | No      | No   | 0
[T14](#time-14)   | TIMEOUT | No     | No      | No   | 0
[T15](#time-15)   | No      | No     | No      | No   | 0
[T16](#time-16)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T17](#time-17)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T18](#time-18)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T19](#time-19)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T20](#time-20)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T21](#time-21)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T22](#time-22)   | ERROR   | ERROR  | No      | No   | 0
[T23](#time-23)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T24](#time-24)   | TIMEOUT | TIMEOUT | No      | ERROR | 0
[T25](#time-25)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T26](#time-26)   | TIMEOUT | TIMEOUT | No      | No   | 0
[T27](#time-27)   | TIMEOUT | TIMEOUT | No      | ERROR | 0
Total             | 26 (11%) | 19 (8%) | 16 (7%) | 9 (4%) | 70
Fixed bugs: 41/224 (18%)




# Lang 1


Nb Executed tests: 2291

Nb Failing tests: 5

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.math.NumberUtilsTest#TestLang747
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFieldsList
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFields

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index 70b8d64..1e6ccdc 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -464,20 +464,11 @@ public class NumberUtils {
             }
         }
         if (pfxLen > 0) { // we have a hex number
-            char firstSigDigit = 0; // strip leading zeroes
-            for(int i = pfxLen; i < str.length(); i++) {
-                firstSigDigit = str.charAt(i);
-                if (firstSigDigit == '0') { // count leading zeroes
-                    pfxLen++;
-                } else {
-                    break;
-                }
-            }
             final int hexDigits = str.length() - pfxLen;
-            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
+            if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
-            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int
+            if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);

```

# Lang 2


Nb Executed tests: 2287

Nb Failing tests: 5

>	org.apache.commons.lang3.LocaleUtilsTest#testParseAllLocales
>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFieldsList
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFields

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/LocaleUtils.java b/org/apache/commons/lang3/LocaleUtils.java
index fab00c5..8a1203a 100644
--- a/org/apache/commons/lang3/LocaleUtils.java
+++ b/org/apache/commons/lang3/LocaleUtils.java
@@ -89,9 +89,6 @@ public class LocaleUtils {
         if (str == null) {
             return null;
         }
-        if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions
-            throw new IllegalArgumentException("Invalid locale format: " + str);
-        }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException("Invalid locale format: " + str);

```

# Lang 3


Nb Executed tests: 2286

Nb Failing tests: 5

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.math.NumberUtilsTest#testStringCreateNumberEnsureNoPrecisionLoss
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFieldsList
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFields

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index 1e6ccdc..064f504 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -482,7 +482,6 @@ public class NumberUtils {
         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
         // and the parsing which will detect if e or E appear in a number due to using the wrong offset
 
-        int numDecimals = 0; // Check required precision (LANG-693)
         if (decPos > -1) { // there is a decimal point
 
             if (expPos > -1) { // there is an exponent
@@ -494,7 +493,6 @@ public class NumberUtils {
                 dec = str.substring(decPos + 1);
             }
             mant = str.substring(0, decPos);
-            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
         } else {
             if (expPos > -1) {
                 if (expPos > str.length()) { // prevents double exponent causing IOOBE
@@ -590,21 +588,17 @@ public class NumberUtils {
         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
-            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
-                final Float f = createFloat(str);
-                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
-                    return f;
-                }
+            final Float f = createFloat(str);
+            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
+                return f;
             }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
-            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
-                final Double d = createDouble(str);
-                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
-                    return d;
-                }
+            final Double d = createDouble(str);
+            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
+                return d;
             }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number

```

# Lang 4


Nb Executed tests: 2285

Nb Failing tests: 5

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFieldsList
>	org.apache.commons.lang3.reflect.FieldUtilsTest#testGetAllFields
>	org.apache.commons.lang3.text.translate.LookupTranslatorTest#testLang882

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/LookupTranslator.java b/org/apache/commons/lang3/text/translate/LookupTranslator.java
index 9cf45f8..d6cb077 100644
--- a/org/apache/commons/lang3/text/translate/LookupTranslator.java
+++ b/org/apache/commons/lang3/text/translate/LookupTranslator.java
@@ -23,32 +23,31 @@ import java.util.HashMap;
 /**
  * Translates a value using a lookup table.
  *
+ * NOTE: This class is broken for any CharSequence implementation that does not define 
+ *       equals(Object) and hashCode() methods as the class uses the CharSequence as 
+ *       the key to a HashMap. See http://issues.apache.org/jira/browse/LANG-882.
+ * 
  * @since 3.0
  * @version $Id$
  */
 public class LookupTranslator extends CharSequenceTranslator {
 
-    private final HashMap<String, CharSequence> lookupMap;
+    private final HashMap<CharSequence, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 
     /**
      * Define the lookup table to be used in translation
      *
-     * Note that, as of Lang 3.1, the key to the lookup table is converted to a 
-     * java.lang.String, while the value remains as a java.lang.CharSequence. 
-     * This is because we need the key to support hashCode and equals(Object), 
-     * allowing it to be the key for a HashMap. See LANG-882.
-     *
      * @param lookup CharSequence[][] table of size [*][2]
      */
     public LookupTranslator(final CharSequence[]... lookup) {
-        lookupMap = new HashMap<String, CharSequence>();
+        lookupMap = new HashMap<CharSequence, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
-                this.lookupMap.put(seq[0].toString(), seq[1]);
+                this.lookupMap.put(seq[0], seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;
@@ -74,7 +73,7 @@ public class LookupTranslator extends CharSequenceTranslator {
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
-            final CharSequence result = lookupMap.get(subSeq.toString());
+            final CharSequence result = lookupMap.get(subSeq);
             if (result != null) {
                 out.write(result.toString());
                 return i;

```

# Lang 5


Nb Executed tests: 2271

Nb Failing tests: 3

>	org.apache.commons.lang3.LocaleUtilsTest#testLang865
>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/LocaleUtils.java b/org/apache/commons/lang3/LocaleUtils.java
index a7a6051..7568f2c 100644
--- a/org/apache/commons/lang3/LocaleUtils.java
+++ b/org/apache/commons/lang3/LocaleUtils.java
@@ -85,66 +85,41 @@ public class LocaleUtils {
      * @return a Locale, null if null input
      * @throws IllegalArgumentException if the string is an invalid format
      */
-    public static Locale toLocale(final String str) {
+    public static Locale toLocale(String str) {
         if (str == null) {
             return null;
         }
-        final int len = str.length();
-        if (len < 2) {
+        int len = str.length();
+        if (len != 2 && len != 5 && len < 7) {
             throw new IllegalArgumentException("Invalid locale format: " + str);
         }
-        final char ch0 = str.charAt(0);
-        if (ch0 == '_') {
-            if (len < 3) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            final char ch1 = str.charAt(1);
-            final char ch2 = str.charAt(2);
-            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            if (len == 3) {
-                return new Locale("", str.substring(1, 3));
-            }
-            if (len < 5) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            if (str.charAt(3) != '_') {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            return new Locale("", str.substring(1, 3), str.substring(4));
+        char ch0 = str.charAt(0);
+        char ch1 = str.charAt(1);
+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
+            throw new IllegalArgumentException("Invalid locale format: " + str);
+        }
+        if (len == 2) {
+            return new Locale(str, "");
         } else {
-            final char ch1 = str.charAt(1);
-            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            if (len == 2) {
-                return new Locale(str);
-            }
-            if (len < 5) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
             if (str.charAt(2) != '_') {
                 throw new IllegalArgumentException("Invalid locale format: " + str);
             }
-            final char ch3 = str.charAt(3);
+            char ch3 = str.charAt(3);
             if (ch3 == '_') {
                 return new Locale(str.substring(0, 2), "", str.substring(4));
             }
-            final char ch4 = str.charAt(4);
-            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
+            char ch4 = str.charAt(4);
+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException("Invalid locale format: " + str);
             }
             if (len == 5) {
                 return new Locale(str.substring(0, 2), str.substring(3, 5));
+            } else {
+                if (str.charAt(5) != '_') {
+                    throw new IllegalArgumentException("Invalid locale format: " + str);
+                }
+                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
             }
-            if (len < 7) {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            if (str.charAt(5) != '_') {
-                throw new IllegalArgumentException("Invalid locale format: " + str);
-            }
-            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
         }
     }
 

```

# Lang 6


Nb Executed tests: 2263

Nb Failing tests: 3

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.StringUtilsTest#testEscapeSurrogatePairs
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
index 0500460..4d010ea 100644
--- a/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
+++ b/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
-                pos += Character.charCount(Character.codePointAt(input, pt));
+                pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }

```

# Lang 7


Nb Executed tests: 2261

Nb Failing tests: 3

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.math.NumberUtilsTest#testCreateNumber

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index 064f547..cca5a3f 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -449,6 +449,13 @@ public class NumberUtils {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException("A blank string is not a valid number");
         }  
+        if (str.startsWith("--")) {
+            // this is protection for poorness in java.lang.BigDecimal.
+            // it accepts this as a legal value, but it does not appear 
+            // to be in specification of class. OS X Java parses it to 
+            // a wrong value.
+            return null;
+        }
         if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith("-")) { // drop -
@@ -714,14 +721,7 @@ public class NumberUtils {
         // handle JDK1.3.1 bug where "" throws IndexOutOfBoundsException
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException("A blank string is not a valid number");
-        }
-        if (str.trim().startsWith("--")) {
-            // this is protection for poorness in java.lang.BigDecimal.
-            // it accepts this as a legal value, but it does not appear 
-            // to be in specification of class. OS X Java parses it to 
-            // a wrong value.
-            throw new NumberFormatException(str + " is not a valid number.");
-        }
+        }  
         return new BigDecimal(str);
     }
 

```

# Lang 8


Nb Executed tests: 2205

Nb Failing tests: 2

>	org.apache.commons.lang3.time.FastDatePrinterTest#testCalendarTimezoneRespected
>	org.apache.commons.lang3.time.FastDateFormat_PrinterTest#testCalendarTimezoneRespected

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDatePrinter.java b/org/apache/commons/lang3/time/FastDatePrinter.java
index c952309..cc1af9d 100644
--- a/org/apache/commons/lang3/time/FastDatePrinter.java
+++ b/org/apache/commons/lang3/time/FastDatePrinter.java
@@ -1093,8 +1093,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
      * <p>Inner class to output a time zone name.</p>
      */
     private static class TimeZoneNameRule implements Rule {
-        private final Locale mLocale;
-        private final int mStyle;
+        private final TimeZone mTimeZone;
         private final String mStandard;
         private final String mDaylight;
 
@@ -1106,9 +1105,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * @param style the style
          */
         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
-            mLocale = locale;
-            mStyle = style;
-            
+            mTimeZone = timeZone;
+
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
         }
@@ -1129,12 +1124,10 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          */
         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
-            TimeZone zone = calendar.getTimeZone();
-            if (zone.useDaylightTime()
-                    && calendar.get(Calendar.DST_OFFSET) != 0) {
-                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
+            if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
+                buffer.append(mDaylight);
             } else {
-                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
+                buffer.append(mStandard);
             }
         }
     }

```

# Lang 9


Nb Executed tests: 2200

Nb Failing tests: 2

>	org.apache.commons.lang3.time.FastDateParserTest#testLANG_832
>	org.apache.commons.lang3.time.FastDateFormat_ParserTest#testLANG_832

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDateParser.java b/org/apache/commons/lang3/time/FastDateParser.java
index 38857c7..8df302f 100644
--- a/org/apache/commons/lang3/time/FastDateParser.java
+++ b/org/apache/commons/lang3/time/FastDateParser.java
@@ -141,9 +141,6 @@ public class FastDateParser implements DateParser, Serializable {
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
-        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
-            throw new IllegalArgumentException("Failed to parse \""+pattern+"\" ; gave up at index "+patternMatcher.regionStart());
-        }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }

```

# Lang 10


Nb Executed tests: 2198

Nb Failing tests: 2

>	org.apache.commons.lang3.time.FastDateParserTest#testLANG_831
>	org.apache.commons.lang3.time.FastDateFormat_ParserTest#testLANG_831

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDateParser.java b/org/apache/commons/lang3/time/FastDateParser.java
index 8df302f..a01159b 100644
--- a/org/apache/commons/lang3/time/FastDateParser.java
+++ b/org/apache/commons/lang3/time/FastDateParser.java
@@ -301,8 +301,17 @@ public class FastDateParser implements DateParser, Serializable {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
+        boolean wasWhite= false;
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
+            if(Character.isWhitespace(c)) {
+                if(!wasWhite) {
+                    wasWhite= true;
+                    regex.append("\\s*+");
+                }
+                continue;
+            }
+            wasWhite= false;
             switch(c) {
             case '\'':
                 if(unquote) {

```

# Lang 11


Nb Executed tests: 2138

Nb Failing tests: 1

>	org.apache.commons.lang3.RandomStringUtilsTest#testLANG807

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/RandomStringUtils.java b/org/apache/commons/lang3/RandomStringUtils.java
index 9dfee22..a799057 100644
--- a/org/apache/commons/lang3/RandomStringUtils.java
+++ b/org/apache/commons/lang3/RandomStringUtils.java
@@ -242,10 +242,6 @@ public class RandomStringUtils {
                     start = ' ';                
                 }
             }
-        } else {
-            if (end <= start) {
-                throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")");
-            }
         }
 
         char[] buffer = new char[count];

```

# Lang 12


Nb Executed tests: 2137

Nb Failing tests: 2

>	org.apache.commons.lang3.RandomStringUtilsTest#testExceptions
>	org.apache.commons.lang3.RandomStringUtilsTest#testLANG805

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/RandomStringUtils.java b/org/apache/commons/lang3/RandomStringUtils.java
index a799057..f27fb6d 100644
--- a/org/apache/commons/lang3/RandomStringUtils.java
+++ b/org/apache/commons/lang3/RandomStringUtils.java
@@ -227,20 +227,13 @@ public class RandomStringUtils {
         } else if (count < 0) {
             throw new IllegalArgumentException("Requested random string length " + count + " is less than 0.");
         }
-        if (chars != null && chars.length == 0) {
-            throw new IllegalArgumentException("The chars array must not be empty");
-        }
 
         if (start == 0 && end == 0) {
-            if (chars != null) {
-                end = chars.length;
-            } else {
-                if (!letters && !numbers) {
-                    end = Integer.MAX_VALUE;
-                } else {
-                    end = 'z' + 1;
-                    start = ' ';                
-                }
+            end = 'z' + 1;
+            start = ' ';
+            if (!letters && !numbers) {
+                start = 0;
+                end = Integer.MAX_VALUE;
             }
         }
 

```

# Lang 13


Nb Executed tests: 2135

Nb Failing tests: 1

>	org.apache.commons.lang3.SerializationUtilsTest#testPrimitiveTypeClassSerialization

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/SerializationUtils.java b/org/apache/commons/lang3/SerializationUtils.java
index 7c89b61..5926a9b 100644
--- a/org/apache/commons/lang3/SerializationUtils.java
+++ b/org/apache/commons/lang3/SerializationUtils.java
@@ -236,8 +236,6 @@ public class SerializationUtils {
      * class here is a workaround, see the JIRA issue LANG-626. </p>
      */
      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
-        private static final Map<String, Class<?>> primitiveTypes = 
-                new HashMap<String, Class<?>>();
         private ClassLoader classLoader;
         
         /**
@@ -251,15 +249,6 @@ public class SerializationUtils {
             super(in);
             this.classLoader = classLoader;
 
-            primitiveTypes.put("byte", byte.class);
-            primitiveTypes.put("short", short.class);
-            primitiveTypes.put("int", int.class);
-            primitiveTypes.put("long", long.class);
-            primitiveTypes.put("float", float.class);
-            primitiveTypes.put("double", double.class);
-            primitiveTypes.put("boolean", boolean.class);
-            primitiveTypes.put("char", char.class);
-            primitiveTypes.put("void", void.class);
         }
 
         /**
@@ -276,15 +265,7 @@ public class SerializationUtils {
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
-                try {
-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
-                } catch (ClassNotFoundException cnfe) {
-                    Class<?> cls = primitiveTypes.get(name);
-                    if (cls != null)
-                        return cls;
-                    else
-                        throw cnfe;
-                }
+                return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
             }
         }
 

```

# Lang 14


Nb Executed tests: 2073

Nb Failing tests: 1

>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testEquals

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/StringUtils.java b/org/apache/commons/lang3/StringUtils.java
index 4733b7e..98319bf 100644
--- a/org/apache/commons/lang3/StringUtils.java
+++ b/org/apache/commons/lang3/StringUtils.java
@@ -779,16 +779,7 @@ public class StringUtils {
      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
      */
     public static boolean equals(CharSequence cs1, CharSequence cs2) {
-        if (cs1 == cs2) {
-            return true;
-        }
-        if (cs1 == null || cs2 == null) {
-            return false;
-        }
-        if (cs1 instanceof String && cs2 instanceof String) {
-            return cs1.equals(cs2);
-        }
-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
+        return cs1 == null ? cs2 == null : cs1.equals(cs2);
     }
 
     /**

```

# Lang 15


Nb Executed tests: 2047

Nb Failing tests: 2

>	org.apache.commons.lang3.reflect.TypeUtilsTest#testGetTypeArguments
>	org.apache.commons.lang3.reflect.TypeUtilsTest#testIsAssignable

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/reflect/TypeUtils.java b/org/apache/commons/lang3/reflect/TypeUtils.java
index 8db8abf..ed9dc3f 100644
--- a/org/apache/commons/lang3/reflect/TypeUtils.java
+++ b/org/apache/commons/lang3/reflect/TypeUtils.java
@@ -216,9 +216,9 @@ public class TypeUtils {
                 toClass, typeVarAssigns);
 
         // now to check each type argument
-        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
-            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
-            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
+        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
+            Type toTypeArg = entry.getValue();
+            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
@@ -234,18 +234,6 @@ public class TypeUtils {
         return true;
     }
 
-    private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns) {
-        Type result;
-        do {
-            result = typeVarAssigns.get(var);
-            if (result instanceof TypeVariable<?> && !result.equals(var)) {
-                var = (TypeVariable<?>) result;
-                continue;
-            }
-            break;
-        } while (true);
-        return result;
-    }
 
     /**
      * <p> Checks if the subject type may be implicitly cast to the target
@@ -672,7 +660,7 @@ public class TypeUtils {
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
-        if (toClass.equals(cls)) {
+        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
             return typeVarAssigns;
         }
 

```

# Lang 16


Nb Executed tests: 2046

Nb Failing tests: 1

>	org.apache.commons.lang3.math.NumberUtilsTest#testCreateNumber

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index 5b7891a..e0118ee 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -455,7 +455,7 @@ public class NumberUtils {
             // a wrong value.
             return null;
         }
-        if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) {
+        if (str.startsWith("0x") || str.startsWith("-0x")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);

```

# Lang 17


Nb Executed tests: 1903

Nb Failing tests: 1

>	org.apache.commons.lang3.StringEscapeUtilsTest#testLang720

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
index 4d010ea..3cbf1e1 100644
--- a/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
+++ b/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
@@ -79,20 +79,27 @@ public abstract class CharSequenceTranslator {
         if (input == null) {
             return;
         }
-        int pos = 0;
-        int len = input.length();
-        while (pos < len) {
-            int consumed = translate(input, pos, out);
+        int sz = Character.codePointCount(input, 0, input.length());
+        for (int i = 0; i < sz; i++) {
+
+            // consumed is the number of codepoints consumed
+            int consumed = translate(input, i, out);
+
             if (consumed == 0) {
-                char[] c = Character.toChars(Character.codePointAt(input, pos));
-                out.write(c);
-                pos+= c.length;
-                continue;
-            }
+                out.write(Character.toChars(Character.codePointAt(input, i)));
+            } else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
-            for (int pt = 0; pt < consumed; pt++) {
-                pos += Character.charCount(Character.codePointAt(input, pos));
+                for (int j = 0; j < consumed; j++) {
+                    if (i < sz - 2) {
+                        i += Character.charCount(Character.codePointAt(input, i));
+                    } else {
+                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things
+                        i++;
+                    }
+                }
+                // for loop will increment 1 anyway, so remove 1 to account for that
+                i--;
             }
         }
     }

```

# Lang 18


Nb Executed tests: 1902

Nb Failing tests: 1

>	org.apache.commons.lang3.time.FastDateFormatTest#testFormat

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDateFormat.java b/org/apache/commons/lang3/time/FastDateFormat.java
index 51da48e..8be2e61 100644
--- a/org/apache/commons/lang3/time/FastDateFormat.java
+++ b/org/apache/commons/lang3/time/FastDateFormat.java
@@ -492,10 +486,10 @@ public class FastDateFormat extends Format {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
-                if (tokenLen == 2) {
-                    rule = TwoDigitYearField.INSTANCE;
+                if (tokenLen >= 4) {
+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                 } else {
-                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
+                    rule = TwoDigitYearField.INSTANCE;
                 }
                 break;
             case 'M': // month in year (text and number)

```

# Lang 19


Nb Executed tests: 1877

Nb Failing tests: 2

>	org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest#testUnfinishedEntity
>	org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest#testOutOfBounds

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
index 3d4c238..ffd969f 100644
--- a/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
+++ b/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
@@ -35,9 +33,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {
      */
     @Override
     public int translate(CharSequence input, int index, Writer out) throws IOException {
-        int seqEnd = input.length();
-        // Uses -2 to ensure there is something after the &#
-        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
+        if(input.charAt(index) == '&' && index < (input.length() - 1) && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 
@@ -45,19 +41,10 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {
             if(firstChar == 'x' || firstChar == 'X') {
                 start++;
                 isHex = true;
-
-                // Check there's more than just an x after the &#
-                if(start == seqEnd) {
-                    return 0;
-                }
             }
 
             int end = start;
-            // Note that this supports character codes without a ; on the end
-            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
-                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
-                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
-            {
+            while(input.charAt(end) != ';') {
                 end++;
             }
 
@@ -69,7 +56,6 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {
                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                 }
             } catch(NumberFormatException nfe) {
-            System.err.println("FAIL: " + input.subSequence(start, end) + "[" + start +"]["+ end +"]");
                 return 0;
             }
 
@@ -80,10 +66,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {
             } else {
                 out.write(entityValue);
             }
-
-            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
-
-            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
     }

```

# Lang 20


Nb Executed tests: 1876

Nb Failing tests: 2

>	org.apache.commons.lang3.StringUtilsTest#testJoin_ArrayChar
>	org.apache.commons.lang3.StringUtilsTest#testJoin_Objectarray

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/StringUtils.java b/org/apache/commons/lang3/StringUtils.java
index 711852e..6b8c2e4 100644
--- a/org/apache/commons/lang3/StringUtils.java
+++ b/org/apache/commons/lang3/StringUtils.java
@@ -3290,12 +3290,13 @@ public class StringUtils {
         if (array == null) {
             return null;
         }
-        int noOfItems = (endIndex - startIndex);
-        if (noOfItems <= 0) {
+        int bufSize = (endIndex - startIndex);
+        if (bufSize <= 0) {
             return EMPTY;
         }
-        
-        StringBuilder buf = new StringBuilder(noOfItems * 16);
+
+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
+        StringBuilder buf = new StringBuilder(bufSize);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
@@ -3375,12 +3377,15 @@ public class StringUtils {
 
         // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
         //           (Assuming that all Strings are roughly equally long)
-        int noOfItems = (endIndex - startIndex);
-        if (noOfItems <= 0) {
+        int bufSize = (endIndex - startIndex);
+        if (bufSize <= 0) {
             return EMPTY;
         }
 
-        StringBuilder buf = new StringBuilder(noOfItems * 16);
+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())
+                        + separator.length());
+
+        StringBuilder buf = new StringBuilder(bufSize);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {

```

# Lang 21


Nb Executed tests: 1827

Nb Failing tests: 1

>	org.apache.commons.lang3.time.DateUtilsTest#testIsSameLocalTime_Cal

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/DateUtils.java b/org/apache/commons/lang3/time/DateUtils.java
index 52a4436..9a24c00 100644
--- a/org/apache/commons/lang3/time/DateUtils.java
+++ b/org/apache/commons/lang3/time/DateUtils.java
@@ -262,7 +262,7 @@ public class DateUtils {
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
-                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&

```

# Lang 22


Nb Executed tests: 1825

Nb Failing tests: 2

>	org.apache.commons.lang3.math.FractionTest#testReducedFactory_int_int
>	org.apache.commons.lang3.math.FractionTest#testReduce

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/Fraction.java b/org/apache/commons/lang3/math/Fraction.java
index bf15a49..15272e5 100644
--- a/org/apache/commons/lang3/math/Fraction.java
+++ b/org/apache/commons/lang3/math/Fraction.java
@@ -579,15 +579,8 @@ public final class Fraction extends Number implements Comparable<Fraction> {
      * @return the greatest common divisor, never zero
      */
     private static int greatestCommonDivisor(int u, int v) {
-        // From Commons Math:
-        if ((u == 0) || (v == 0)) {
-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
-                throw new ArithmeticException("overflow: gcd is 2^31");
-            }
-            return Math.abs(u) + Math.abs(v);
-        }
-        //if either operand is abs 1, return 1:
-        if (Math.abs(u) == 1 || Math.abs(v) == 1) {
+        //if either op. is abs 0 or 1, return 1:
+        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to

```

# Lang 23


Nb Executed tests: 1825

Nb Failing tests: 1

>	org.apache.commons.lang3.text.ExtendedMessageFormatTest#testEqualsHashcode

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/ExtendedMessageFormat.java b/org/apache/commons/lang3/text/ExtendedMessageFormat.java
index 55ee7d1..e4742ad 100644
--- a/org/apache/commons/lang3/text/ExtendedMessageFormat.java
+++ b/org/apache/commons/lang3/text/ExtendedMessageFormat.java
@@ -70,7 +69,6 @@ import org.apache.commons.lang3.Validate;
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
-    private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = "";
     private static final String ESCAPED_QUOTE = "''";
@@ -256,49 +254,6 @@ public class ExtendedMessageFormat extends MessageFormat {
     }
 
     /**
-     * Check if this extended message format is equal to another object.
-     *
-     * @param obj the object to compare to
-     * @return true if this object equals the other, otherwise false
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == this) {
-            return true;
-        }
-        if (obj == null) {
-            return false;
-        }
-        if (!super.equals(obj)) {
-            return false;
-        }
-        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
-          return false;
-        }
-        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
-        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
-            return false;
-        }
-        if (ObjectUtils.notEqual(registry, rhs.registry)) {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Return the hashcode.
-     *
-     * @return the hashcode
-     */
-    @Override
-    public int hashCode() {
-        int result = super.hashCode();
-        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
-        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
-        return result;
-    }
-
-    /**
      * Get a custom format from a format description.
      * 
      * @param desc String

```

# Lang 24


Nb Executed tests: 1822

Nb Failing tests: 1

>	org.apache.commons.lang3.math.NumberUtilsTest#testIsNumber

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index d9b3c6d..f1f36a8 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -1409,8 +1409,8 @@ public class NumberUtils {
             }
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
-                // not allowing L with an exponent or decimal point
-                return foundDigit && !hasExp && !hasDecPoint;
+                // not allowing L with an exponent
+                return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;

```

# Lang 25


Nb Executed tests: 1821

Nb Failing tests: 1

>	org.apache.commons.lang3.text.translate.EntityArraysTest#testISO8859_1_ESCAPE

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/EntityArrays.java b/org/apache/commons/lang3/text/translate/EntityArrays.java
index ef839c6..8caca58 100644
--- a/org/apache/commons/lang3/text/translate/EntityArrays.java
+++ b/org/apache/commons/lang3/text/translate/EntityArrays.java
@@ -71,33 +71,33 @@ public class EntityArrays {
         {"\u00C7", "&Ccedil;"}, //  - uppercase C, cedilla
         {"\u00C8", "&Egrave;"}, //  - uppercase E, grave accent
         {"\u00C9", "&Eacute;"}, //  - uppercase E, acute accent
-        {"\u00CA", "&Ecirc;"}, //  - uppercase E, circumflex accent
-        {"\u00CB", "&Euml;"}, //  - uppercase E, umlaut
-        {"\u00CC", "&Igrave;"}, //  - uppercase I, grave accent
-        {"\u00CD", "&Iacute;"}, //  - uppercase I, acute accent
-        {"\u00CE", "&Icirc;"}, //  - uppercase I, circumflex accent
-        {"\u00CF", "&Iuml;"}, //  - uppercase I, umlaut
-        {"\u00D0", "&ETH;"}, //  - uppercase Eth, Icelandic
-        {"\u00D1", "&Ntilde;"}, //  - uppercase N, tilde
-        {"\u00D2", "&Ograve;"}, //  - uppercase O, grave accent
-        {"\u00D3", "&Oacute;"}, //  - uppercase O, acute accent
-        {"\u00D4", "&Ocirc;"}, //  - uppercase O, circumflex accent
-        {"\u00D5", "&Otilde;"}, //  - uppercase O, tilde
-        {"\u00D6", "&Ouml;"}, //  - uppercase O, umlaut
-        {"\u00D7", "&times;"}, // multiplication sign
-        {"\u00D8", "&Oslash;"}, //  - uppercase O, slash
-        {"\u00D9", "&Ugrave;"}, //  - uppercase U, grave accent
-        {"\u00DA", "&Uacute;"}, //  - uppercase U, acute accent
-        {"\u00DB", "&Ucirc;"}, //  - uppercase U, circumflex accent
-        {"\u00DC", "&Uuml;"}, //  - uppercase U, umlaut
-        {"\u00DD", "&Yacute;"}, //  - uppercase Y, acute accent
-        {"\u00DE", "&THORN;"}, //  - uppercase THORN, Icelandic
-        {"\u00DF", "&szlig;"}, //  - lowercase sharps, German
-        {"\u00E0", "&agrave;"}, //  - lowercase a, grave accent
-        {"\u00E1", "&aacute;"}, //  - lowercase a, acute accent
-        {"\u00E2", "&acirc;"}, //  - lowercase a, circumflex accent
-        {"\u00E3", "&atilde;"}, //  - lowercase a, tilde
-        {"\u00E4", "&auml;"}, //  - lowercase a, umlaut
+        {"\u00CB", "&Ecirc;"}, //  - uppercase E, circumflex accent
+        {"\u00CC", "&Euml;"}, //  - uppercase E, umlaut
+        {"\u00CD", "&Igrave;"}, //  - uppercase I, grave accent
+        {"\u00CE", "&Iacute;"}, //  - uppercase I, acute accent
+        {"\u00CF", "&Icirc;"}, //  - uppercase I, circumflex accent
+        {"\u00D0", "&Iuml;"}, //  - uppercase I, umlaut
+        {"\u00D1", "&ETH;"}, //  - uppercase Eth, Icelandic
+        {"\u00D2", "&Ntilde;"}, //  - uppercase N, tilde
+        {"\u00D3", "&Ograve;"}, //  - uppercase O, grave accent
+        {"\u00D4", "&Oacute;"}, //  - uppercase O, acute accent
+        {"\u00D5", "&Ocirc;"}, //  - uppercase O, circumflex accent
+        {"\u00D6", "&Otilde;"}, //  - uppercase O, tilde
+        {"\u00D7", "&Ouml;"}, //  - uppercase O, umlaut
+        {"\u00D8", "&times;"}, // multiplication sign
+        {"\u00D9", "&Oslash;"}, //  - uppercase O, slash
+        {"\u00DA", "&Ugrave;"}, //  - uppercase U, grave accent
+        {"\u00DB", "&Uacute;"}, //  - uppercase U, acute accent
+        {"\u00DC", "&Ucirc;"}, //  - uppercase U, circumflex accent
+        {"\u00DD", "&Uuml;"}, //  - uppercase U, umlaut
+        {"\u00DE", "&Yacute;"}, //  - uppercase Y, acute accent
+        {"\u00DF", "&THORN;"}, //  - uppercase THORN, Icelandic
+        {"\u00E0", "&szlig;"}, //  - lowercase sharps, German
+        {"\u00E1", "&agrave;"}, //  - lowercase a, grave accent
+        {"\u00E2", "&aacute;"}, //  - lowercase a, acute accent
+        {"\u00E3", "&acirc;"}, //  - lowercase a, circumflex accent
+        {"\u00E4", "&atilde;"}, //  - lowercase a, tilde
+        {"\u00E5", "&auml;"}, //  - lowercase a, umlaut
         {"\u00E5", "&aring;"}, //  - lowercase a, ring
         {"\u00E6", "&aelig;"}, //  - lowercase ae
         {"\u00E7", "&ccedil;"}, //  - lowercase c, cedilla

```

# Lang 26


Nb Executed tests: 1790

Nb Failing tests: 1

>	org.apache.commons.lang3.time.FastDateFormatTest#testLang645

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDateFormat.java b/org/apache/commons/lang3/time/FastDateFormat.java
index 95925fc..e30da2a 100644
--- a/org/apache/commons/lang3/time/FastDateFormat.java
+++ b/org/apache/commons/lang3/time/FastDateFormat.java
@@ -817,7 +817,7 @@ public class FastDateFormat extends Format {
      * @return the formatted string
      */
     public String format(Date date) {
-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
+        Calendar c = new GregorianCalendar(mTimeZone);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }

```

# Lang 27


Nb Executed tests: 1785

Nb Failing tests: 1

>	org.apache.commons.lang3.math.NumberUtilsTest#testCreateNumber

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index f1f36a8..fd03ab8 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -476,7 +476,7 @@ public class NumberUtils {
         if (decPos > -1) {
 
             if (expPos > -1) {
-                if (expPos < decPos || expPos > str.length()) {
+                if (expPos < decPos) {
                     throw new NumberFormatException(str + " is not a valid number.");
                 }
                 dec = str.substring(decPos + 1, expPos);
@@ -486,9 +486,6 @@ public class NumberUtils {
             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
-                if (expPos > str.length()) {
-                    throw new NumberFormatException(str + " is not a valid number.");
-                }
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;

```

# Lang 28


Nb Executed tests: 1763

Nb Failing tests: 1

>	org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest#testSupplementaryUnescaping

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
index a21671a..12a0663 100644
--- a/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
+++ b/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
@@ -60,13 +60,8 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {
                 return 0;
             }
 
-            if(entityValue > 0xFFFF) {
-                char[] chrs = Character.toChars(entityValue);
-                out.write(chrs[0]);
-                out.write(chrs[1]);
-            } else {
-                out.write(entityValue);
-            }
+            // TODO: if(entityValue > 0xFFFF) {
+            out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;

```

# Lang 29


Nb Executed tests: 1760

Nb Failing tests: 1

>	org.apache.commons.lang3.SystemUtilsTest#testJavaVersionAsInt

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/SystemUtils.java b/org/apache/commons/lang3/SystemUtils.java
index 2116f7c..0c73f42 100644
--- a/org/apache/commons/lang3/SystemUtils.java
+++ b/org/apache/commons/lang3/SystemUtils.java
@@ -1669,7 +1669,7 @@ public class SystemUtils {
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
-    static int toJavaVersionInt(String version) {
+    static float toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 

```

# Lang 30


Nb Executed tests: 1733

Nb Failing tests: 10

>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsNone_CharArrayWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsNone_StringWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsAny_StringCharArrayWithBadSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testIndexOfAnyBut_StringStringWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsAny_StringWithBadSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testIndexOfAny_StringCharArrayWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testIndexOfAnyBut_StringCharArrayWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsNone_StringWithBadSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testIndexOfAny_StringStringWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsNone_CharArrayWithBadSupplementaryChars

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/StringUtils.java b/org/apache/commons/lang3/StringUtils.java
index da86fdb..c107e3a 100644
--- a/org/apache/commons/lang3/StringUtils.java
+++ b/org/apache/commons/lang3/StringUtils.java
@@ -1372,22 +1372,11 @@ public class StringUtils {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
-        int csLen = cs.length();
-        int csLast = csLen - 1;
-        int searchLen = searchChars.length;
-        int searchLast = searchLen - 1;
-        for (int i = 0; i < csLen; i++) {
+        for (int i = 0; i < cs.length(); i++) {
             char ch = cs.charAt(i);
-            for (int j = 0; j < searchLen; j++) {
+            for (int j = 0; j < searchChars.length; j++) {
                 if (searchChars[j] == ch) {
-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
-                        // ch is a supplementary character
-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
-                            return i;
-                        }
-                    } else {
-                        return i;
-                    }
+                    return i;
                 }
             }
         }
@@ -1448,24 +1437,21 @@ public class StringUtils {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
-    public static boolean containsAny(String cs, char[] searchChars) {
+    public static boolean containsAny(CharSequence cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }
         int csLength = cs.length();
         int searchLength = searchChars.length;
-        int csLast = csLength - 1;
-        int searchLast = searchLength - 1;
+        int csLastIndex = csLength - 1;
+        int searchLastIndex = searchLength - 1;
         for (int i = 0; i < csLength; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
-                    if (Character.isHighSurrogate(ch)) {
-                        if (j == searchLast) {
-                            // missing low surrogate, fine, like String.indexOf(String)
-                            return true;
-                        }
-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+                    if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
+                        // ch is a supplementary character
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
@@ -1505,7 +1491,7 @@ public class StringUtils {
      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
      * @since 2.4
      */
-    public static boolean containsAny(String cs, String searchChars) {
+    public static boolean containsAny(CharSequence cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }
@@ -1540,22 +1526,11 @@ public class StringUtils {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
-        int csLen = cs.length();
-        int csLast = csLen - 1;
-        int searchLen = searchChars.length;
-        int searchLast = searchLen - 1;
-        outer:
-        for (int i = 0; i < csLen; i++) {
+        outer : for (int i = 0; i < cs.length(); i++) {
             char ch = cs.charAt(i);
-            for (int j = 0; j < searchLen; j++) {
+            for (int j = 0; j < searchChars.length; j++) {
                 if (searchChars[j] == ch) {
-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
-                            continue outer;
-                        }
-                    } else {
-                        continue outer;
-                    }
+                    continue outer;
                 }
             }
             return i;
@@ -1589,19 +1564,9 @@ public class StringUtils {
         if (isEmpty(str) || isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
-        int strLen = str.length();
-        for (int i = 0; i < strLen; i++) {
-            char ch = str.charAt(i);
-            boolean chFound = searchChars.indexOf(ch) >= 0;
-            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
-                char ch2 = str.charAt(i + 1);
-                if (chFound && searchChars.indexOf(ch2) < 0) {
-                    return i;
-                }
-            } else {
-                if (!chFound) {
-                    return i;
-                }
+        for (int i = 0; i < str.length(); i++) {
+            if (searchChars.indexOf(str.charAt(i)) < 0) {
+                return i;
             }
         }
         return INDEX_NOT_FOUND;
@@ -1693,34 +1658,21 @@ public class StringUtils {
      * </pre>
      *
      * @param cs  the CharSequence to check, may be null
-     * @param searchChars  an array of invalid chars, may be null
+     * @param invalidChars  an array of invalid chars, may be null
      * @return true if it contains none of the invalid chars, or is null
      * @since 2.0
      */
-    public static boolean containsNone(CharSequence cs, char[] searchChars) {
-        if (cs == null || searchChars == null) {
+    public static boolean containsNone(CharSequence cs, char[] invalidChars) {
+        if (cs == null || invalidChars == null) {
             return true;
         }
-        int csLen = cs.length();
-        int csLast = csLen - 1;
-        int searchLen = searchChars.length;
-        int searchLast = searchLen - 1;
-        for (int i = 0; i < csLen; i++) {
+        int strSize = cs.length();
+        int validSize = invalidChars.length;
+        for (int i = 0; i < strSize; i++) {
             char ch = cs.charAt(i);
-            for (int j = 0; j < searchLen; j++) {
-                if (searchChars[j] == ch) {
-                    if (Character.isHighSurrogate(ch)) {
-                        if (j == searchLast) {
-                            // missing low surrogate, fine, like String.indexOf(String)
-                            return false;
-                        }
-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
-                            return false;
-                        }
-                    } else {
-                        // ch is in the Basic Multilingual Plane
-                        return false;
-                    }
+            for (int j = 0; j < validSize; j++) {
+                if (invalidChars[j] == ch) {
+                    return false;
                 }
             }
         }

```

# Lang 31


Nb Executed tests: 1721

Nb Failing tests: 2

>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsAnyCharArrayWithSupplementaryChars
>	org.apache.commons.lang3.StringUtilsEqualsIndexOfTest#testContainsAnyStringWithSupplementaryChars

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/StringUtils.java b/org/apache/commons/lang3/StringUtils.java
index 4aac02d..e60c449 100644
--- a/org/apache/commons/lang3/StringUtils.java
+++ b/org/apache/commons/lang3/StringUtils.java
@@ -1437,32 +1437,20 @@ public class StringUtils {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
-	public static boolean containsAny(CharSequence cs, char[] searchChars) {
-		if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
-			return false;
-		}
-		int csLength = cs.length();
-		int searchLength = searchChars.length;
-		int csLastIndex = csLength - 1;
-		int searchLastIndex = searchLength - 1;
-		for (int i = 0; i < csLength; i++) {
-			char ch = cs.charAt(i);
-			for (int j = 0; j < searchLength; j++) {
-				if (searchChars[j] == ch) {
-					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
-						// ch is a supplementary character
-						if (searchChars[j + 1] == cs.charAt(i + 1)) {
-							return true;
-						}
-					} else {
-						// ch is in the Basic Multilingual Plane
-						return true;
-					}
-				}
-			}
-		}
-		return false;
-	}
+    public static boolean containsAny(CharSequence cs, char[] searchChars) {
+        if (cs == null || cs.length() == 0 || searchChars == null || searchChars.length == 0) {
+            return false;
+        }
+        for (int i = 0; i < cs.length(); i++) {
+            char ch = cs.charAt(i);
+            for (int j = 0; j < searchChars.length; j++) {
+                if (searchChars[j] == ch) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
 
     /**
      * <p>

```

# Lang 32


Nb Executed tests: 1670

Nb Failing tests: 1

>	org.apache.commons.lang3.builder.HashCodeBuilderTest#testReflectionObjectCycle

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/builder/HashCodeBuilder.java b/org/apache/commons/lang3/builder/HashCodeBuilder.java
index 9f7e890..547676c 100644
--- a/org/apache/commons/lang3/builder/HashCodeBuilder.java
+++ b/org/apache/commons/lang3/builder/HashCodeBuilder.java
@@ -101,7 +101,14 @@ public class HashCodeBuilder {
      * 
      * @since 2.3
      */
-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
+    private static final ThreadLocal<Set<IDKey>> registry = new ThreadLocal<Set<IDKey>>() {
+        @Override
+        protected Set<IDKey> initialValue() {
+            // The HashSet implementation is not synchronized,
+            // which is just what we need here.
+            return new HashSet<IDKey>();
+        }
+    };
 
     /*
      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
@@ -129,7 +136,7 @@ public class HashCodeBuilder {
      * @since 2.3
      */
     static Set<IDKey> getRegistry() {
-        return REGISTRY.get();
+        return registry.get();
     }
 
     /**
@@ -144,8 +151,7 @@ public class HashCodeBuilder {
      * @since 2.3
      */
     static boolean isRegistered(Object value) {
-        Set<IDKey> registry = getRegistry();
-        return registry != null && registry.contains(new IDKey(value));
+        return getRegistry().contains(new IDKey(value));
     }
 
     /**
@@ -515,11 +521,6 @@ public class HashCodeBuilder {
      *            The object to register.
      */
     static void register(Object value) {
-        synchronized (HashCodeBuilder.class) {
-            if (getRegistry() == null) {
-                REGISTRY.set(new HashSet<IDKey>());
-            }
-        }
         getRegistry().add(new IDKey(value));
     }
 
@@ -536,15 +537,7 @@ public class HashCodeBuilder {
      * @since 2.3
      */
     static void unregister(Object value) {
-        Set<IDKey> s = getRegistry();
-        if (s != null) {
-            s.remove(new IDKey(value));
-            synchronized (HashCodeBuilder.class) {
-                if (s.isEmpty()) {
-                    REGISTRY.remove();
-                }
-            }
-        }
+        getRegistry().remove(new IDKey(value));
     }
 
     /**

```

# Lang 33


Nb Executed tests: 1670

Nb Failing tests: 1

>	org.apache.commons.lang3.ClassUtilsTest#testToClass_object

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/ClassUtils.java b/org/apache/commons/lang3/ClassUtils.java
index 3998966..85fda04 100644
--- a/org/apache/commons/lang3/ClassUtils.java
+++ b/org/apache/commons/lang3/ClassUtils.java
@@ -907,7 +906,7 @@ public class ClassUtils {
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
-            classes[i] = array[i] == null ? null : array[i].getClass();
+            classes[i] = array[i].getClass();
         }
         return classes;
     }

```

# Lang 34


Nb Executed tests: 1670

Nb Failing tests: 27

>	org.apache.commons.lang3.builder.ToStringBuilderTest#testObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionHierarchy
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testSelfInstanceTwoVarsReflectionObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionArrayCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionLongArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionArrayArrayCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionFloatArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionDoubleArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionBooleanArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionyteArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionDoubleArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionIntArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionLongArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionhortArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionObjectArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionBooleanArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testSimpleReflectionObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionByteArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionArrayCycleLevel2
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionArrayAndObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionCharArrayArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionShortArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testSelfInstanceVarReflectionObjectCycle
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionIntArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionCharArray
>	org.apache.commons.lang3.builder.ToStringBuilderTest#testReflectionFloatArrayArray

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/builder/ToStringStyle.java b/org/apache/commons/lang3/builder/ToStringStyle.java
index 26214ed..95b580b 100644
--- a/org/apache/commons/lang3/builder/ToStringStyle.java
+++ b/org/apache/commons/lang3/builder/ToStringStyle.java
@@ -144,8 +144,9 @@ public abstract class ToStringStyle implements Serializable {
      *
      * @return Set the registry of objects being traversed
      */
-    static Map<Object, Object> getRegistry() {
-        return REGISTRY.get();
+    static Set<Object> getRegistry() {
+        WeakHashMap<Object, Object> m = REGISTRY.get();
+        return m == null ? Collections.<Object> emptySet() : m.keySet();
     }
 
     /**
@@ -160,8 +161,7 @@ public abstract class ToStringStyle implements Serializable {
      *             object.
      */
     static boolean isRegistered(Object value) {
-        Map<Object, Object> m = getRegistry();
-        return m != null && m.containsKey(value);
+        return getRegistry().contains(value);
     }
 
     /**

```

# Lang 35


Nb Executed tests: 1644

Nb Failing tests: 1

>	org.apache.commons.lang3.ArrayUtilsAddTest#testLANG571

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/ArrayUtils.java b/org/apache/commons/lang3/ArrayUtils.java
index 3a543ce..79c80bd 100644
--- a/org/apache/commons/lang3/ArrayUtils.java
+++ b/org/apache/commons/lang3/ArrayUtils.java
@@ -3280,21 +3280,13 @@ public class ArrayUtils {
      * @param element  the object to add, may be <code>null</code>
      * @return A new array containing the existing elements plus the new element
      * The returned array type will be that of the input array (unless null),
-     * in which case it will have the same type as the element.
-     * If both are null, an IllegalArgumentException is thrown
+     * in which case it will have the same type as the element (unless that is also null)
+     * in which case the returned type will be Object[].
      * @since 2.1
-     * @throws IllegalArgumentException if both arguments are null
      */
     public static <T> T[] add(T[] array, T element) {
-        Class<?> type;
-        if (array != null){
-            type = array.getClass();
-        } else if (element != null) {
-            type = element.getClass();
-        } else {
-            throw new IllegalArgumentException("Arguments cannot both be null");            
-        }
-        @SuppressWarnings("unchecked") // type must be T
+        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);
+        // TODO - this is NOT safe to ignore - see LANG-571
         T[] newArray = (T[]) copyArrayGrow1(array, type);
         newArray[newArray.length - 1] = element;
         return newArray;
@@ -3571,7 +3562,9 @@ public class ArrayUtils {
         } else if (element != null) {
             clss = element.getClass();
         } else {
-            throw new IllegalArgumentException("Array and element cannot both be null");            
+            // TODO this is not type-safe - see LANG-571
+            final T[] emptyArray = (T[]) new Object[] { null };
+            return emptyArray;
         }
         @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);

```

# Lang 36


Nb Executed tests: 1628

Nb Failing tests: 2

>	org.apache.commons.lang3.math.NumberUtilsTest#testCreateNumber
>	org.apache.commons.lang3.math.NumberUtilsTest#testIsNumber

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/math/NumberUtils.java b/org/apache/commons/lang3/math/NumberUtils.java
index 0d30b22..d3054f3 100644
--- a/org/apache/commons/lang3/math/NumberUtils.java
+++ b/org/apache/commons/lang3/math/NumberUtils.java
@@ -488,7 +488,7 @@ public class NumberUtils {
             }
             dec = null;
         }
-        if (!Character.isDigit(lastChar) && lastChar != '.') {
+        if (!Character.isDigit(lastChar)) {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
@@ -1385,14 +1385,6 @@ public class NumberUtils {
                 // can't have an E at the last byte
                 return false;
             }
-            if (chars[i] == '.') {
-                if (hasDecPoint || hasExp) {
-                    // two decimal points or dec in exponent
-                    return false;
-                }
-                // single trailing decimal point after non-exponent is ok
-                return foundDigit;
-            }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'

```

# Lang 37


Nb Executed tests: 1627

Nb Failing tests: 1

>	org.apache.commons.lang3.ArrayUtilsAddTest#testJira567

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/ArrayUtils.java b/org/apache/commons/lang3/ArrayUtils.java
index b9413e8..9011bff 100644
--- a/org/apache/commons/lang3/ArrayUtils.java
+++ b/org/apache/commons/lang3/ArrayUtils.java
@@ -2956,19 +2956,10 @@ public class ArrayUtils {
         } else if (array2 == null) {
             return clone(array1);
         }
-        final Class<?> type1 = array1.getClass().getComponentType();
-        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
+        T[] joinedArray = (T[]) Array.newInstance(array1.getClass().getComponentType(),
+                                                            array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
-        try {
-            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
-        } catch (ArrayStoreException ase) {
-            // Check if problem is incompatible types
-            final Class<?> type2 = array2.getClass().getComponentType();
-            if (!type1.isAssignableFrom(type2)){
-                throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "+type1.getName());
-            }
-            throw ase; // No, so rethrow original
-        }
+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
         return joinedArray;
     }
 

```

# Lang 38


Nb Executed tests: 1624

Nb Failing tests: 1

>	org.apache.commons.lang3.time.FastDateFormatTest#testLang538

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/time/FastDateFormat.java b/org/apache/commons/lang3/time/FastDateFormat.java
index d60af96..6b10a94 100644
--- a/org/apache/commons/lang3/time/FastDateFormat.java
+++ b/org/apache/commons/lang3/time/FastDateFormat.java
@@ -869,7 +869,6 @@ public class FastDateFormat extends Format {
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
-            calendar.getTime(); /// LANG-538
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }

```

# Lang 39


Nb Executed tests: 1618

Nb Failing tests: 1

>	org.apache.commons.lang3.StringUtilsTest#testReplace_StringStringArrayStringArray

## Human Patch 

```Java
diff --git a/org/apache/commons/lang3/StringUtils.java b/org/apache/commons/lang3/StringUtils.java
index f6cabee..14563aa 100644
--- a/org/apache/commons/lang3/StringUtils.java
+++ b/org/apache/commons/lang3/StringUtils.java
@@ -3673,9 +3673,6 @@ public class StringUtils {
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
-            if (searchList[i] == null || replacementList[i] == null) {
-                continue;
-            }
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches

```

# Lang 40


Nb Executed tests: 1643

Nb Failing tests: 1

>	org.apache.commons.lang.StringUtilsEqualsIndexOfTest#testContainsIgnoreCase_LocaleIndependence

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/StringUtils.java b/org/apache/commons/lang/StringUtils.java
index 8351b3e..6ad364b 100644
--- a/org/apache/commons/lang/StringUtils.java
+++ b/org/apache/commons/lang/StringUtils.java
@@ -1045,14 +1045,7 @@ public class StringUtils {
         if (str == null || searchStr == null) {
             return false;
         }
-        int len = searchStr.length();
-        int max = str.length() - len;
-        for (int i = 0; i <= max; i++) {
-            if (str.regionMatches(true, i, searchStr, 0, len)) {
-                return true;
-            }
-        }
-        return false;
+        return contains(str.toUpperCase(), searchStr.toUpperCase());
     }
 
     // IndexOfAny chars

```

# Lang 41


Nb Executed tests: 1624

Nb Failing tests: 2

>	org.apache.commons.lang.ClassUtilsTest#test_getShortClassName_Class
>	org.apache.commons.lang.ClassUtilsTest#test_getPackageName_Class

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/ClassUtils.java b/org/apache/commons/lang/ClassUtils.java
index 478b377..ebfd25a 100644
--- a/org/apache/commons/lang/ClassUtils.java
+++ b/org/apache/commons/lang/ClassUtils.java
@@ -188,24 +188,6 @@ public class ClassUtils {
             return StringUtils.EMPTY;
         }
 
-        StringBuffer arrayPrefix = new StringBuffer();
-
-        // Handle array encoding
-        if (className.startsWith("[")) {
-            while (className.charAt(0) == '[') {
-                className = className.substring(1);
-                arrayPrefix.append("[]");
-            }
-            // Strip Object type encoding
-            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
-                className = className.substring(1, className.length() - 1);
-            }
-        }
-
-        if (reverseAbbreviationMap.containsKey(className)) {
-            className = reverseAbbreviationMap.get(className);
-        }
-
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(
                 INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
@@ -213,7 +195,7 @@ public class ClassUtils {
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
-        return out + arrayPrefix;
+        return out;
     }
 
     // Package name
@@ -242,7 +224,7 @@ public class ClassUtils {
         if (cls == null) {
             return StringUtils.EMPTY;
         }
-        return getPackageName(cls.getName());
+        return cls.getPackage().getName();
     }
 
     /**
@@ -255,19 +237,9 @@ public class ClassUtils {
      * @return the package name or an empty string
      */
     public static String getPackageName(String className) {
-        if (className == null || className.length() == 0) {
+        if (className == null) {
             return StringUtils.EMPTY;
         }
-
-        // Strip array encoding
-        while (className.charAt(0) == '[') {
-            className = className.substring(1);
-        }
-        // Strip Object type encoding
-        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
-            className = className.substring(1);
-        }
-
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
             return StringUtils.EMPTY;

```

# Lang 42


Nb Executed tests: 1903

Nb Failing tests: 1

>	org.apache.commons.lang.StringEscapeUtilsTest#testEscapeHtmlHighUnicode

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/Entities.java b/org/apache/commons/lang/Entities.java
index 0d8f7f4..900e1a8 100644
--- a/org/apache/commons/lang/Entities.java
+++ b/org/apache/commons/lang/Entities.java
@@ -825,15 +825,10 @@ class Entities {
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
-            int c = Character.codePointAt(str, i); 
+            char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
-                if (c >= 0x010000 && i < len - 1) {
-                    writer.write("&#");
-                    writer.write(Integer.toString(c, 10));
-                    writer.write(';');
-                    i++;
-                } else if (c > 0x7F) { 
+                if (c > 0x7F) {
                     writer.write("&#");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');

```

# Lang 43


Nb Executed tests: 1902

Nb Failing tests: 1

>	org.apache.commons.lang.text.ExtendedMessageFormatTest#testEscapedQuote_LANG_477

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/text/ExtendedMessageFormat.java b/org/apache/commons/lang/text/ExtendedMessageFormat.java
index 4af3955..404be49 100644
--- a/org/apache/commons/lang/text/ExtendedMessageFormat.java
+++ b/org/apache/commons/lang/text/ExtendedMessageFormat.java
@@ -419,7 +419,6 @@ public class ExtendedMessageFormat extends MessageFormat {
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
-            next(pos);
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;

```

# Lang 44


Nb Executed tests: 1879

Nb Failing tests: 1

>	org.apache.commons.lang.NumberUtilsTest#testLang457

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/NumberUtils.java b/org/apache/commons/lang/NumberUtils.java
index c5ca8cd..18a05ef 100644
--- a/org/apache/commons/lang/NumberUtils.java
+++ b/org/apache/commons/lang/NumberUtils.java
@@ -142,9 +142,6 @@ public final class NumberUtils {
         if (val.length() == 0) {
             throw new NumberFormatException("\"\" is not a valid number.");
         }
-        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
-            throw new NumberFormatException(val + " is not a valid number.");
-        }
         if (val.startsWith("--")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 

```

## NopolPC 

org.apache.commons.lang.NumberUtils:193 (Suspicious rank: 18 (Ochiai), 13 (Ample), 13 (Tarantula))
```Java
(numeric.length())!=(0)
```

Nb Angelic value: 1

Nb analyzed Statement: 18

Execution time: 0:00:55.402000

Grid5000 node: chimint-19.lille.grid5000.fr


# Lang 45


Nb Executed tests: 1877

Nb Failing tests: 1

>	org.apache.commons.lang.WordUtilsTest#testAbbreviate

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/WordUtils.java b/org/apache/commons/lang/WordUtils.java
index 91c6615..748b547 100644
--- a/org/apache/commons/lang/WordUtils.java
+++ b/org/apache/commons/lang/WordUtils.java
@@ -611,11 +611,6 @@ public class WordUtils {
             return StringUtils.EMPTY;
         }
 
-        // if the lower value is greater than the length of the string,
-        // set to the length of the string
-        if (lower > str.length()) {
-            lower = str.length();    
-        }
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {

```

# Lang 46


Nb Executed tests: 1829

Nb Failing tests: 1

>	org.apache.commons.lang.StringEscapeUtilsTest#testEscapeJavaWithSlash

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/StringEscapeUtils.java b/org/apache/commons/lang/StringEscapeUtils.java
index d4f98ec..c30c663 100644
--- a/org/apache/commons/lang/StringEscapeUtils.java
+++ b/org/apache/commons/lang/StringEscapeUtils.java
@@ -83,7 +83,7 @@ public class StringEscapeUtils {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJava(String str) {
-        return escapeJavaStyleString(str, false, false);
+        return escapeJavaStyleString(str, false);
     }
 
     /**
@@ -99,7 +99,7 @@ public class StringEscapeUtils {
      * @throws IOException if error occurs on underlying Writer
      */
     public static void escapeJava(Writer out, String str) throws IOException {
-        escapeJavaStyleString(out, str, false, false);
+        escapeJavaStyleString(out, str, false);
     }
 
     /**
@@ -124,7 +124,7 @@ public class StringEscapeUtils {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJavaScript(String str) {
-        return escapeJavaStyleString(str, true, true);
+        return escapeJavaStyleString(str, true);
     }
 
     /**
@@ -140,7 +140,7 @@ public class StringEscapeUtils {
      * @throws IOException if error occurs on underlying Writer
      **/
     public static void escapeJavaScript(Writer out, String str) throws IOException {
-        escapeJavaStyleString(out, str, true, true);
+        escapeJavaStyleString(out, str, true);
     }
 
     /**
@@ -148,16 +148,15 @@ public class StringEscapeUtils {
      * 
      * @param str String to escape values in, may be null
      * @param escapeSingleQuotes escapes single quotes if <code>true</code>
-     * @param escapeForwardSlash TODO
      * @return the escaped string
      */
-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
-            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
+            escapeJavaStyleString(writer, str, escapeSingleQuotes);
             return writer.toString();
         } catch (IOException ioe) {
             // this should never ever happen while writing to a StringWriter
@@ -172,11 +171,9 @@ public class StringEscapeUtils {
      * @param out write to receieve the escaped string
      * @param str String to escape values in, may be null
      * @param escapeSingleQuote escapes single quotes if <code>true</code>
-     * @param escapeForwardSlash TODO
      * @throws IOException if an IOException occurs
      */
-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
-            boolean escapeForwardSlash) throws IOException {
+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException("The Writer must not be null");
         }
@@ -197,23 +194,23 @@ public class StringEscapeUtils {
                 out.write("\\u00" + hex(ch));
             } else if (ch < 32) {
                 switch (ch) {
-                    case '\b' :
+                    case '\b':
                         out.write('\\');
                         out.write('b');
                         break;
-                    case '\n' :
+                    case '\n':
                         out.write('\\');
                         out.write('n');
                         break;
-                    case '\t' :
+                    case '\t':
                         out.write('\\');
                         out.write('t');
                         break;
-                    case '\f' :
+                    case '\f':
                         out.write('\\');
                         out.write('f');
                         break;
-                    case '\r' :
+                    case '\r':
                         out.write('\\');
                         out.write('r');
                         break;
@@ -227,24 +224,22 @@ public class StringEscapeUtils {
                 }
             } else {
                 switch (ch) {
-                    case '\'' :
+                    case '\'':
                         if (escapeSingleQuote) {
-                            out.write('\\');
+                          out.write('\\');
                         }
                         out.write('\'');
                         break;
-                    case '"' :
+                    case '"':
                         out.write('\\');
                         out.write('"');
                         break;
-                    case '\\' :
+                    case '\\':
                         out.write('\\');
                         out.write('\\');
                         break;
-                    case '/' :
-                        if (escapeForwardSlash) {
-                            out.write('\\');
-                        }
+                    case '/':
+                        out.write('\\');
                         out.write('/');
                         break;
                     default :

```

## NopolPC 

org.apache.commons.lang.StringEscapeUtils:242 (Suspicious rank: 1 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
escapeSingleQuote
```

Nb Angelic value: 1

Nb analyzed Statement: 1

Execution time: 0:00:40.201000

Grid5000 node: chinqchint-3.lille.grid5000.fr


# Lang 47


Nb Executed tests: 1829

Nb Failing tests: 2

>	org.apache.commons.lang.text.StrBuilderTest#testLang412Left
>	org.apache.commons.lang.text.StrBuilderTest#testLang412Right

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/text/StrBuilder.java b/org/apache/commons/lang/text/StrBuilder.java
index fd135fd..13281ce 100644
--- a/org/apache/commons/lang/text/StrBuilder.java
+++ b/org/apache/commons/lang/text/StrBuilder.java
@@ -1183,9 +1183,6 @@ public class StrBuilder implements Cloneable {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
-            if (str == null) {
-                str = "";
-            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
@@ -1230,9 +1227,6 @@ public class StrBuilder implements Cloneable {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
-            if (str == null) {
-                str = "";
-            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);

```

# Lang 48


Nb Executed tests: 1764

Nb Failing tests: 1

>	org.apache.commons.lang.builder.EqualsBuilderTest#testBigDecimal

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/builder/EqualsBuilder.java b/org/apache/commons/lang/builder/EqualsBuilder.java
index 6901c8e..afd1666 100644
--- a/org/apache/commons/lang/builder/EqualsBuilder.java
+++ b/org/apache/commons/lang/builder/EqualsBuilder.java
@@ -377,12 +377,8 @@ public class EqualsBuilder {
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
-            if (lhs instanceof java.math.BigDecimal) {
-                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
-            } else {
-                // The simple case, not an array, just test the element
-                isEquals = lhs.equals(rhs);
-            }
+            // The simple case, not an array, just test the element
+            isEquals = lhs.equals(rhs);
         } else if (lhs.getClass() != rhs.getClass()) {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] 
             this.setEquals(false);

```

# Lang 49


Nb Executed tests: 1750

Nb Failing tests: 1

>	org.apache.commons.lang.math.FractionTest#testReduce

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/math/Fraction.java b/org/apache/commons/lang/math/Fraction.java
index 3347689..5f8e565 100644
--- a/org/apache/commons/lang/math/Fraction.java
+++ b/org/apache/commons/lang/math/Fraction.java
@@ -463,9 +463,6 @@ public final class Fraction extends Number implements Comparable {
      * @return a new reduced fraction instance, or this if no simplification possible
      */
     public Fraction reduce() {
-        if (numerator == 0) {
-            return equals(ZERO) ? this : ZERO;
-        }
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;

```

# Lang 50


Nb Executed tests: 1814

Nb Failing tests: 2

>	org.apache.commons.lang.time.FastDateFormatTest#test_changeDefault_Locale_DateInstance
>	org.apache.commons.lang.time.FastDateFormatTest#test_changeDefault_Locale_DateTimeInstance

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/FastDateFormat.java b/org/apache/commons/lang/time/FastDateFormat.java
index d1caaa8..0be752b 100644
--- a/org/apache/commons/lang/time/FastDateFormat.java
+++ b/org/apache/commons/lang/time/FastDateFormat.java
@@ -281,15 +281,16 @@ public class FastDateFormat extends Format {
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
-
-        if (locale == null) {
-            locale = Locale.getDefault();
+        if (locale != null) {
+            key = new Pair(key, locale);
         }
 
-        key = new Pair(key, locale);
-
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
+            if (locale == null) {
+                locale = Locale.getDefault();
+            }
+
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
@@ -460,13 +461,16 @@ public class FastDateFormat extends Format {
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
-        if (locale == null) {
-            locale = Locale.getDefault();
+        if (locale != null) {
+            key = new Pair(key, locale);
         }
-        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
+            if (locale == null) {
+                locale = Locale.getDefault();
+            }
+
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);

```

# Lang 51


Nb Executed tests: 1725

Nb Failing tests: 1

>	org.apache.commons.lang.BooleanUtilsTest#test_toBoolean_String

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/BooleanUtils.java b/org/apache/commons/lang/BooleanUtils.java
index 8b5028c..3fda4ec 100644
--- a/org/apache/commons/lang/BooleanUtils.java
+++ b/org/apache/commons/lang/BooleanUtils.java
@@ -679,7 +679,6 @@ public class BooleanUtils {
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
-                return false;
             }
             case 4: {
                 char ch = str.charAt(0);

```

## NopolC 

org.apache.commons.lang.BooleanUtils:672 (Suspicious rank: 10 (Ochiai), 18 (Ample), 18 (Tarantula))
```Java
str!=null
```

Nb Angelic value: 1

Nb analyzed Statement: 10

Execution time: 0:00:51.122000

Grid5000 node: chimint-15.lille.grid5000.fr


# Lang 52


Nb Executed tests: 1725

Nb Failing tests: 1

>	org.apache.commons.lang.StringEscapeUtilsTest#testEscapeJavaScript

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/StringEscapeUtils.java b/org/apache/commons/lang/StringEscapeUtils.java
index db2d7bd..4fda091 100644
--- a/org/apache/commons/lang/StringEscapeUtils.java
+++ b/org/apache/commons/lang/StringEscapeUtils.java
@@ -233,10 +233,6 @@ public class StringEscapeUtils {
                         out.write('\\');
                         out.write('\\');
                         break;
-                    case '/':
-                        out.write('\\');
-                        out.write('/');
-                        break;
                     default :
                         out.write(ch);
                         break;

```

# Lang 53


Nb Executed tests: 1718

Nb Failing tests: 1

>	org.apache.commons.lang.time.DateUtilsTest#testRoundLang346

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/DateUtils.java b/org/apache/commons/lang/time/DateUtils.java
index e5138b5..9ca1bc5 100644
--- a/org/apache/commons/lang/time/DateUtils.java
+++ b/org/apache/commons/lang/time/DateUtils.java
@@ -640,18 +640,18 @@ public class DateUtils {
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
-        }
-        if (field == Calendar.SECOND) {
-            done = true;
+            if (field == Calendar.SECOND) {
+                done = true;
+            }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
-        }
-        if (field == Calendar.MINUTE) {
-            done = true;
+            if (field == Calendar.MINUTE) {
+                done = true;
+            }
         }
 
         // truncate minutes

```

# Lang 54


Nb Executed tests: 1710

Nb Failing tests: 1

>	org.apache.commons.lang.LocaleUtilsTest#testLang328

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/LocaleUtils.java b/org/apache/commons/lang/LocaleUtils.java
index 9607953..139d9a7 100644
--- a/org/apache/commons/lang/LocaleUtils.java
+++ b/org/apache/commons/lang/LocaleUtils.java
@@ -111,9 +111,6 @@ public class LocaleUtils {
                 throw new IllegalArgumentException("Invalid locale format: " + str);
             }
             char ch3 = str.charAt(3);
-            if (ch3 == '_') {
-                return new Locale(str.substring(0, 2), "", str.substring(4));
-            }
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException("Invalid locale format: " + str);

```

# Lang 55


Nb Executed tests: 1710

Nb Failing tests: 1

>	org.apache.commons.lang.time.StopWatchTest#testLang315

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/StopWatch.java b/org/apache/commons/lang/time/StopWatch.java
index 0f0786a..607e9b6 100644
--- a/org/apache/commons/lang/time/StopWatch.java
+++ b/org/apache/commons/lang/time/StopWatch.java
@@ -115,9 +115,7 @@ public class StopWatch {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException("Stopwatch is not running. ");
         }
-        if(this.runningState == STATE_RUNNING) {
-            stopTime = System.currentTimeMillis();
-        }
+        stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }
 

```

## NopolPC 

org.apache.commons.lang.time.StopWatch:118 (Suspicious rank: 7 (Ochiai), 8 (Ample), 8 (Tarantula))
```Java
(org.apache.commons.lang.time.StopWatch.this.stopTime)<(org.apache.commons.lang.time.StopWatch.STATE_RUNNING)
```

Nb Angelic value: 1

Nb analyzed Statement: 7

Execution time: 0:01:22.345000

Grid5000 node: chinqchint-3.lille.grid5000.fr


# Lang 56


Nb Executed tests: 1691

Nb Failing tests: 1

>	org.apache.commons.lang.time.FastDateFormatTest#testLang303

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/FastDateFormat.java b/org/apache/commons/lang/time/FastDateFormat.java
index 756290f..ac96c58 100644
--- a/org/apache/commons/lang/time/FastDateFormat.java
+++ b/org/apache/commons/lang/time/FastDateFormat.java
@@ -137,11 +134,11 @@ public class FastDateFormat extends Format {
     /**
      * The parsed rules.
      */
-    private transient Rule[] mRules;
+    private Rule[] mRules;
     /**
      * The estimated maximum length.
      */
-    private transient int mMaxLengthEstimate;
+    private int mMaxLengthEstimate;
 
     //-----------------------------------------------------------------------
     /**
@@ -1016,13 +1013,6 @@ public class FastDateFormat extends Format {
     public String toString() {
         return "FastDateFormat[" + mPattern + "]";
     }
-
-    // Serializing
-    //-----------------------------------------------------------------------
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        in.defaultReadObject();
-        init();
-    }
     
     // Rules
     //-----------------------------------------------------------------------

```

# Lang 57


Nb Executed tests: 1690

Nb Failing tests: 11

>	org.apache.commons.lang.LocaleUtilsTest#testAvailableLocaleSet
>	org.apache.commons.lang.LocaleUtilsTest#testIsAvailableLocale
>	org.apache.commons.lang.LocaleUtilsTest#testAvailableLocaleList
>	org.apache.commons.lang.LocaleUtilsTest#testCountriesByLanguage
>	org.apache.commons.lang.LocaleUtilsTest#testLocaleLookupList_LocaleLocale
>	org.apache.commons.lang.LocaleUtilsTest#testLanguagesByCountry
>	org.apache.commons.lang.LocaleUtilsTest#testToLocale_1Part
>	org.apache.commons.lang.LocaleUtilsTest#testToLocale_2Part
>	org.apache.commons.lang.LocaleUtilsTest#testToLocale_3Part
>	org.apache.commons.lang.LocaleUtilsTest#testLocaleLookupList_Locale
>	org.apache.commons.lang.LocaleUtilsTest#testConstructor

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/LocaleUtils.java b/org/apache/commons/lang/LocaleUtils.java
index 139d9a7..ceb886e 100644
--- a/org/apache/commons/lang/LocaleUtils.java
+++ b/org/apache/commons/lang/LocaleUtils.java
@@ -220,7 +220,7 @@ public class LocaleUtils {
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
-        return availableLocaleList().contains(locale);
+        return cAvailableLocaleSet.contains(locale);
     }
 
     //-----------------------------------------------------------------------

```

# Lang 58


Nb Executed tests: 1689

Nb Failing tests: 2

>	org.apache.commons.lang.math.RandomUtilsTest#testNextFloat2
>	org.apache.commons.lang.math.NumberUtilsTest#testLang300

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/math/NumberUtils.java b/org/apache/commons/lang/math/NumberUtils.java
index eb74e72..c0f06a4 100644
--- a/org/apache/commons/lang/math/NumberUtils.java
+++ b/org/apache/commons/lang/math/NumberUtils.java
@@ -451,7 +451,8 @@ public class NumberUtils {
                 case 'L' :
                     if (dec == null
                         && exp == null
-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
+                        && isDigits(numeric.substring(1))
+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {

```

## NopolPC 

org.apache.commons.lang.math.NumberUtils:464 (Suspicious rank: 2 (Ochiai), 2 (Ample), 2 (Tarantula))
```Java
(-1)<(expPos)
```

Nb Angelic value: 1

Nb analyzed Statement: 1

Execution time: 0:00:38.547000

Grid5000 node: chinqchint-16.lille.grid5000.fr


## NopolC 

org.apache.commons.lang.math.NumberUtils:452 (Suspicious rank: 21 (Ochiai), 11 (Ample), 11 (Tarantula))
```Java
((dec == null) && (exp == null))
```

Nb Angelic value: 3

Nb analyzed Statement: 20

Execution time: 0:01:10.317000

Grid5000 node: chinqchint-11.lille.grid5000.fr


# Lang 59


Nb Executed tests: 1687

Nb Failing tests: 1

>	org.apache.commons.lang.text.StrBuilderAppendInsertTest#testLang299

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/text/StrBuilder.java b/org/apache/commons/lang/text/StrBuilder.java
index 4c14509..886d424 100644
--- a/org/apache/commons/lang/text/StrBuilder.java
+++ b/org/apache/commons/lang/text/StrBuilder.java
@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
-                str.getChars(0, width, buffer, size);
+                str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);

```

# Lang 60


Nb Executed tests: 1684

Nb Failing tests: 1

>	org.apache.commons.lang.text.StrBuilderTest#testLang295

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/text/StrBuilder.java b/org/apache/commons/lang/text/StrBuilder.java
index 886d424..c7cbfb3 100644
--- a/org/apache/commons/lang/text/StrBuilder.java
+++ b/org/apache/commons/lang/text/StrBuilder.java
@@ -1670,7 +1670,7 @@ public class StrBuilder implements Cloneable {
      */
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
-        for (int i = 0; i < this.size; i++) {
+        for (int i = 0; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
@@ -1727,7 +1727,7 @@ public class StrBuilder implements Cloneable {
             return -1;
         }
         char[] thisBuf = buffer;
-        for (int i = startIndex; i < size; i++) {
+        for (int i = startIndex; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }

```

# Lang 61


Nb Executed tests: 1683

Nb Failing tests: 2

>	org.apache.commons.lang.text.StrBuilderTest#testIndexOfLang294
>	org.apache.commons.lang.text.StrBuilderTest#testLang294

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/text/StrBuilder.java b/org/apache/commons/lang/text/StrBuilder.java
index c7cbfb3..e202d73 100644
--- a/org/apache/commons/lang/text/StrBuilder.java
+++ b/org/apache/commons/lang/text/StrBuilder.java
@@ -1773,9 +1773,8 @@ public class StrBuilder implements Cloneable {
             return -1;
         }
         char[] thisBuf = buffer;
-        int len = size - strLen + 1;
         outer:
-        for (int i = startIndex; i < len; i++) {
+        for (int i = startIndex; i < thisBuf.length - strLen; i++) {
             for (int j = 0; j < strLen; j++) {
                 if (str.charAt(j) != thisBuf[i + j]) {
                     continue outer;

```

# Lang 62


Nb Executed tests: 1681

Nb Failing tests: 1

>	org.apache.commons.lang.EntitiesTest#testNumberOverflow

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/Entities.java b/org/apache/commons/lang/Entities.java
index a45e004..495c981 100644
--- a/org/apache/commons/lang/Entities.java
+++ b/org/apache/commons/lang/Entities.java
@@ -847,9 +847,6 @@ class Entities {
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
-                            if (entityValue > 0xFFFF) {
-                                entityValue = -1;
-                            }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
@@ -920,17 +917,13 @@ class Entities {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
-                                        break;
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
-                                if (entityValue > 0xFFFF) {
-                                    entityValue = -1;
-                                }
                             } catch (NumberFormatException e) {
-                                entityValue = -1;
+                                // ignore the escaped value content
                             }
                         }
                     } else { //escaped value content is an entity name

```

# Lang 63


Nb Executed tests: 1671

Nb Failing tests: 1

>	org.apache.commons.lang.time.DurationFormatUtilsTest#testJiraLang281

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/DurationFormatUtils.java b/org/apache/commons/lang/time/DurationFormatUtils.java
index 3a9d9f6..f777d48 100644
--- a/org/apache/commons/lang/time/DurationFormatUtils.java
+++ b/org/apache/commons/lang/time/DurationFormatUtils.java
@@ -303,21 +303,23 @@ public class DurationFormatUtils {
             days -= 1;
         }
         while (days < 0) {
-            end.add(Calendar.MONTH, -1);
-            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
-//days += 31; // TODO: Need tests to show this is bad and the new code is good.
-// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
-// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
-// Also it's contextual - if asked for no M in the format then I should probably 
-// be doing no calculating here.
+            days += 31; // such overshooting is taken care of later on
             months -= 1;
-            end.add(Calendar.MONTH, 1);
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
 
+        // take estimates off of end to see if we can equal start, when it overshoots recalculate
+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
+
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
         // number of months and get the real count and not just 0->11.
@@ -425,6 +427,29 @@ public class DurationFormatUtils {
         return buffer.toString();
     }
 
+    /**
+     * Reduces by difference, then if it overshot, calculates the overshot amount and 
+     * fixes and returns the amount to change by.
+     *
+     * @param start Start of period being formatted
+     * @param end End of period being formatted
+     * @param field Field to reduce, as per constants in {@link java.util.Calendar}
+     * @param difference amount to reduce by
+     * @return int reduced value
+     */
+    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
+        end.add( field, -1 * difference );
+        int endValue = end.get(field);
+        int startValue = start.get(field);
+        if (endValue < startValue) {
+            int newdiff = startValue - endValue;
+            end.add( field, newdiff );
+            return newdiff;
+        } else {
+            return 0;
+        }
+    }
+
     static final Object y = "y";
     static final Object M = "M";
     static final Object d = "d";

```

# Lang 64


Nb Executed tests: 1666

Nb Failing tests: 3

>	org.apache.commons.lang.enums.ValuedEnumTest#testCompareTo_otherEnumType
>	org.apache.commons.lang.enums.ValuedEnumTest#testCompareTo_classloader_equal
>	org.apache.commons.lang.enums.ValuedEnumTest#testCompareTo_classloader_different

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/enums/ValuedEnum.java b/org/apache/commons/lang/enums/ValuedEnum.java
index 419a0ea..bbd018c 100644
--- a/org/apache/commons/lang/enums/ValuedEnum.java
+++ b/org/apache/commons/lang/enums/ValuedEnum.java
@@ -180,41 +174,10 @@ public abstract class ValuedEnum extends Enum {
      * @throws NullPointerException if other is <code>null</code>
      */
     public int compareTo(Object other) {
-        if (other == this) {
-            return 0;
-        }
-        if (other.getClass() != this.getClass()) {
-            if (other.getClass().getName().equals(this.getClass().getName())) {
-                return iValue - getValueInOtherClassLoader(other);
-            }
-            throw new ClassCastException(
-                    "Different enum class '" + ClassUtils.getShortClassName(other.getClass()) + "'");
-        }
         return iValue - ((ValuedEnum) other).iValue;
     }
 
     /**
-     * <p>Use reflection to return an objects value.</p>
-     *
-     * @param other  the object to determine the value for
-     * @return the value
-     */
-    private int getValueInOtherClassLoader(Object other) {
-        try {
-            Method mth = other.getClass().getMethod("getValue", null);
-            Integer value = (Integer) mth.invoke(other, null);
-            return value.intValue();
-        } catch (NoSuchMethodException e) {
-            // ignore - should never happen
-        } catch (IllegalAccessException e) {
-            // ignore - should never happen
-        } catch (InvocationTargetException e) {
-            // ignore - should never happen
-        }
-        throw new IllegalStateException("This should not happen");
-    }
-
-    /**
      * <p>Human readable description of this <code>Enum</code> item.</p>
      *
      * @return String in the form <code>type[name=value]</code>, for example:

```

# Lang 65


Nb Executed tests: 1633

Nb Failing tests: 1

>	org.apache.commons.lang.time.DateUtilsTest#testTruncateLang59

## Human Patch 

```Java
diff --git a/org/apache/commons/lang/time/DateUtils.java b/org/apache/commons/lang/time/DateUtils.java
index 79c13f0..f042237 100644
--- a/org/apache/commons/lang/time/DateUtils.java
+++ b/org/apache/commons/lang/time/DateUtils.java
@@ -621,51 +621,6 @@ public class DateUtils {
             throw new ArithmeticException("Calendar value too large for accurate calculations");
         }
         
-        if (field == Calendar.MILLISECOND) {
-            return;
-        }
-
-        // ----------------- Fix for LANG-59 ---------------------- START ---------------
-        // see http://issues.apache.org/jira/browse/LANG-59
-        //
-        // Manually truncate milliseconds, seconds and minutes, rather than using
-        // Calendar methods.
-
-        Date date = val.getTime();
-        long time = date.getTime();
-        boolean done = false;
-
-        // truncate milliseconds
-        int millisecs = val.get(Calendar.MILLISECOND);
-        if (!round || millisecs < 500) {
-            time = time - millisecs;
-            if (field == Calendar.SECOND) {
-                done = true;
-            }
-        }
-
-        // truncate seconds
-        int seconds = val.get(Calendar.SECOND);
-        if (!done && (!round || seconds < 30)) {
-            time = time - (seconds * 1000L);
-            if (field == Calendar.MINUTE) {
-                done = true;
-            }
-        }
-
-        // truncate minutes
-        int minutes = val.get(Calendar.MINUTE);
-        if (!done && (!round || minutes < 30)) {
-            time = time - (minutes * 60000L);
-        }
-
-        // reset time
-        if (date.getTime() != time) {
-            date.setTime(time);
-            val.setTime(date);
-        }
-        // ----------------- Fix for LANG-59 ----------------------- END ----------------
-
         boolean roundUp = false;
         for (int i = 0; i < fields.length; i++) {
             for (int j = 0; j < fields[i].length; j++) {
@@ -734,9 +689,7 @@ public class DateUtils {
                 roundUp = offset > ((max - min) / 2);
             }
             //We need to remove this field
-            if (offset != 0) {
-                val.set(fields[i][0], val.get(fields[i][0]) - offset);
-            }
+            val.set(fields[i][0], val.get(fields[i][0]) - offset);
         }
         throw new IllegalArgumentException("The field " + field + " is not supported");
 

```

# Chart 1


Nb Executed tests: 4402

Nb Failing tests: 2

>	org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests#test2947660
>	org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests#test2947660

## Human Patch 

```Java
Index: org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java
===================================================================
--- org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java	(revision 2266)
+++ org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java	(revision 2264)
@@ -1794,7 +1794,7 @@
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
-        if (dataset == null) {
+        if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();

```

# Chart 2


Nb Executed tests: 4398

Nb Failing tests: 4

>	org.jfree.data.general.junit.DatasetUtilitiesTests#testBug2849731_2
>	org.jfree.data.general.junit.DatasetUtilitiesTests#testBug2849731_3
>	org.jfree.data.general.junit.DatasetUtilitiesTests#testBug2849731_2
>	org.jfree.data.general.junit.DatasetUtilitiesTests#testBug2849731_3

## Human Patch 

```Java
Index: org/jfree/data/general/DatasetUtilities.java
===================================================================
--- org/jfree/data/general/DatasetUtilities.java	(revision 2242)
+++ org/jfree/data/general/DatasetUtilities.java	(revision 2240)
@@ -752,19 +752,12 @@
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
-                    double value = intervalXYData.getXValue(series, item);
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
-                    if (!Double.isNaN(value)) {
-                        minimum = Math.min(minimum, value);
-                        maximum = Math.max(maximum, value);
-                    }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
-                        maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
-                        minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
@@ -1246,19 +1239,12 @@
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
-                    double value = ixyd.getYValue(series, item);
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
-                    if (!Double.isNaN(value)) {
-                        minimum = Math.min(minimum, value);
-                        maximum = Math.max(maximum, value);
-                    }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
-                        maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
-                        minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }

```

# Chart 3


Nb Executed tests: 4390

Nb Failing tests: 2

>	org.jfree.data.time.junit.TimeSeriesTests#testCreateCopy3
>	org.jfree.data.time.junit.TimeSeriesTests#testCreateCopy3

## Human Patch 

```Java
Index: org/jfree/data/time/TimeSeries.java
===================================================================
--- org/jfree/data/time/TimeSeries.java	(revision 2227)
+++ org/jfree/data/time/TimeSeries.java	(revision 2225)
@@ -1054,8 +1054,7 @@
             throw new IllegalArgumentException("Requires start <= end.");
         }
         TimeSeries copy = (TimeSeries) super.clone();
-        copy.minY = Double.NaN;
-        copy.maxY = Double.NaN;
+
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {

```

# Chart 4


Nb Executed tests: 4374

Nb Failing tests: 44

>	org.jfree.chart.junit.JFreeChartTests#testSerialization4
>	org.jfree.chart.junit.ScatterPlotTests#testDrawWithNullInfo
>	org.jfree.chart.junit.ScatterPlotTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.ScatterPlotTests#testReplaceDataset
>	org.jfree.chart.junit.TimeSeriesChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.TimeSeriesChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.TimeSeriesChartTests#testReplaceDataset
>	org.jfree.chart.junit.XYAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYAreaChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYAreaChartTests#testReplaceDataset
>	org.jfree.chart.junit.XYStepAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYStepAreaChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYStepAreaChartTests#testReplaceDataset
>	org.jfree.chart.junit.XYStepChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYStepChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYStepChartTests#testReplaceDataset
>	org.jfree.chart.axis.junit.LogAxisTests#testXYAutoRange1
>	org.jfree.chart.axis.junit.LogAxisTests#testXYAutoRange2
>	org.jfree.chart.junit.XYStepAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYStepAreaChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYStepAreaChartTests#testReplaceDataset
>	org.jfree.chart.plot.junit.XYPlotTests#testDrawRangeGridlines
>	org.jfree.chart.junit.JFreeChartTests#testSerialization4
>	org.jfree.chart.junit.ScatterPlotTests#testDrawWithNullInfo
>	org.jfree.chart.junit.ScatterPlotTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.ScatterPlotTests#testReplaceDataset
>	org.jfree.chart.plot.junit.XYPlotTests#testDrawRangeGridlines
>	org.jfree.chart.junit.TimeSeriesChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.TimeSeriesChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.TimeSeriesChartTests#testReplaceDataset
>	org.jfree.chart.axis.junit.LogAxisTests#testXYAutoRange1
>	org.jfree.chart.axis.junit.LogAxisTests#testXYAutoRange2
>	org.jfree.chart.axis.junit.NumberAxisTests#testXYAutoRange1
>	org.jfree.chart.axis.junit.NumberAxisTests#testXYAutoRange2
>	org.jfree.chart.axis.junit.ValueAxisTests#testAxisMargins
>	org.jfree.chart.junit.XYAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYAreaChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYAreaChartTests#testReplaceDataset
>	org.jfree.chart.axis.junit.ValueAxisTests#testAxisMargins
>	org.jfree.chart.junit.XYStepChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.XYStepChartTests#testSetSeriesToolTipGenerator
>	org.jfree.chart.junit.XYStepChartTests#testReplaceDataset
>	org.jfree.chart.axis.junit.NumberAxisTests#testXYAutoRange1
>	org.jfree.chart.axis.junit.NumberAxisTests#testXYAutoRange2

## Human Patch 

```Java
Index: org/jfree/chart/plot/XYPlot.java
===================================================================
--- org/jfree/chart/plot/XYPlot.java	(revision 2183)
+++ org/jfree/chart/plot/XYPlot.java	(revision 2182)
@@ -4490,14 +4490,12 @@
                     }
                 }
                 
-                if (r != null) {
-                    Collection c = r.getAnnotations();
-                    Iterator i = c.iterator();
-                    while (i.hasNext()) {
-                        XYAnnotation a = (XYAnnotation) i.next();
-                        if (a instanceof XYAnnotationBoundsInfo) {
-                            includedAnnotations.add(a);
-                        }
+                Collection c = r.getAnnotations();
+                Iterator i = c.iterator();
+                while (i.hasNext()) {
+                    XYAnnotation a = (XYAnnotation) i.next();
+                    if (a instanceof XYAnnotationBoundsInfo) {
+                        includedAnnotations.add(a);
                     }
                 }
             }

```

# Chart 5


Nb Executed tests: 4081

Nb Failing tests: 2

>	org.jfree.data.xy.junit.XYSeriesTests#testBug1955483
>	org.jfree.data.xy.junit.XYSeriesTests#testBug1955483

## Human Patch 

```Java
Index: org/jfree/data/xy/XYSeries.java
===================================================================
--- org/jfree/data/xy/XYSeries.java	(revision 1696)
+++ org/jfree/data/xy/XYSeries.java	(revision 1695)
@@ -541,15 +537,9 @@
         if (x == null) {
             throw new IllegalArgumentException("Null 'x' argument.");
         }
-        if (this.allowDuplicateXValues) {
-            add(x, y);
-            return null;
-        }
-
-        // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
-        if (index >= 0) {
+        if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();

```

## NopolC 

org.jfree.data.xy.XYSeries:561 (Suspicious rank: 3 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)
```

Nb Angelic value: 1

Nb analyzed Statement: 3

Execution time: 0:00:58.314000

Grid5000 node: chimint-15.lille.grid5000.fr


# Chart 6


Nb Executed tests: 3789

Nb Failing tests: 4

>	org.jfree.chart.util.junit.ShapeListTests#testSerialization
>	org.jfree.chart.util.junit.ShapeListTests#testEquals
>	org.jfree.chart.util.junit.ShapeListTests#testSerialization
>	org.jfree.chart.util.junit.ShapeListTests#testEquals

## Human Patch 

```Java
Index: org/jfree/chart/util/ShapeList.java
===================================================================
--- org/jfree/chart/util/ShapeList.java	(revision 1166)
+++ org/jfree/chart/util/ShapeList.java	(revision 1164)
@@ -96,27 +93,26 @@
     /**
      * Tests the list for equality with another object (typically also a list).
      *
-     * @param obj  the other object (<code>null</code> permitted).
+     * @param obj  the other object.
      *
      * @return A boolean.
      */
     public boolean equals(Object obj) {
 
+        if (obj == null) {
+            return false;
+        }
+
         if (obj == this) {
             return true;
         }
-        if (!(obj instanceof ShapeList)) {
-            return false;
+
+        if (obj instanceof ShapeList) {
+            return super.equals(obj);
         }
-        ShapeList that = (ShapeList) obj;
-        int listSize = size();
-        for (int i = 0; i < listSize; i++) {
-           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {
-               return false;
-           }
-        }
-        return true;
 
+        return false;
+
     }
 
     /**

```

# Chart 7


Nb Executed tests: 3641

Nb Failing tests: 2

>	org.jfree.data.time.junit.TimePeriodValuesTests#testGetMaxMiddleIndex
>	org.jfree.data.time.junit.TimePeriodValuesTests#testGetMaxMiddleIndex

## Human Patch 

```Java
Index: org/jfree/data/time/TimePeriodValues.java
===================================================================
--- org/jfree/data/time/TimePeriodValues.java	(revision 1087)
+++ org/jfree/data/time/TimePeriodValues.java	(revision 1086)
@@ -297,9 +296,9 @@
         }
         
         if (this.maxMiddleIndex >= 0) {
-            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
+            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                 .getTime();
-            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()
+            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                 .getTime();
             long maxMiddle = s + (e - s) / 2;
             if (middle > maxMiddle) {

```

# Chart 8


Nb Executed tests: 3641

Nb Failing tests: 0


## Human Patch 

```Java
Index: org/jfree/data/time/Week.java
===================================================================
--- org/jfree/data/time/Week.java	(revision 1085)
+++ org/jfree/data/time/Week.java	(revision 1084)
@@ -172,7 +171,7 @@
      */
     public Week(Date time, TimeZone zone) {
         // defer argument checking...
-        this(time, zone, Locale.getDefault());
+        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
     }
 
     /**

```

# Chart 9


Nb Executed tests: 3641

Nb Failing tests: 2

>	org.jfree.data.time.junit.TimeSeriesTests#testBug1864222
>	org.jfree.data.time.junit.TimeSeriesTests#testBug1864222

## Human Patch 

```Java
Index: org/jfree/data/time/TimeSeries.java
===================================================================
--- org/jfree/data/time/TimeSeries.java	(revision 1083)
+++ org/jfree/data/time/TimeSeries.java	(revision 1082)
@@ -674,7 +672,7 @@
      */
     public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,
                                           double value) {
-        return addOrUpdate(period, new Double(value));
+        return this.addOrUpdate(period, new Double(value));
     }
 
     /**
@@ -941,7 +937,7 @@
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
-        if ((endIndex < 0)  || (endIndex < startIndex)) {
+        if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
@@ -970,13 +966,15 @@
             return false;
         }
         TimeSeries s = (TimeSeries) object;
-        if (!ObjectUtilities.equal(getDomainDescription(),
-                s.getDomainDescription())) {
+        if (!ObjectUtilities.equal(
+            getDomainDescription(), s.getDomainDescription()
+        )) {
             return false;
         }
 
-        if (!ObjectUtilities.equal(getRangeDescription(),
-                s.getRangeDescription())) {
+        if (!ObjectUtilities.equal(
+            getRangeDescription(), s.getRangeDescription()
+        )) {
             return false;
         }
 

```

## NopolPC 

org.jfree.data.time.TimeSeries:940 (Suspicious rank: 10 (Ochiai), 14 (Ample), 14 (Tarantula))
```Java
(org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length())==(org.jfree.data.time.TimeSeries.this.data.size())
```

Nb Angelic value: 1

Nb analyzed Statement: 10

Execution time: 0:00:50.565000

Grid5000 node: chinqchint-20.lille.grid5000.fr


## NopolC 

org.jfree.data.time.TimeSeries:935 (Suspicious rank: 8 (Ochiai), 9 (Ample), 9 (Tarantula))
```Java
((org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length())==(startIndex))||((!((startIndex)!=(1)))&&(start!=null))
```

Nb Angelic value: 1

Nb analyzed Statement: 8

Execution time: 0:00:49.728000

Grid5000 node: chinqchint-12.lille.grid5000.fr


# Chart 10


Nb Executed tests: 3625

Nb Failing tests: 2

>	org.jfree.chart.imagemap.junit.StandardToolTipTagFragmentGeneratorTests#testGenerateURLFragment
>	org.jfree.chart.imagemap.junit.StandardToolTipTagFragmentGeneratorTests#testGenerateURLFragment

## Human Patch 

```Java
Index: org/jfree/chart/imagemap/DynamicDriveToolTipTagFragmentGenerator.java
===================================================================
--- org/jfree/chart/imagemap/DynamicDriveToolTipTagFragmentGenerator.java	(revision 1065)
+++ org/jfree/chart/imagemap/DynamicDriveToolTipTagFragmentGenerator.java	(revision 1064)
@@ -2,51 +2,49 @@
  * JFreeChart : a free chart library for the Java(tm) platform
  * ===========================================================
  *
- * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.
+ * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.
  *
  * Project Info:  http://www.jfree.org/jfreechart/index.html
  *
- * This library is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
+ * This library is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by 
+ * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+ * This library is distributed in the hope that it will be useful, but 
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
+ * USA.  
  *
- * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
+ * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * --------------------------------------------
  * DynamicDriveToolTipTagFragmentGenerator.java
  * --------------------------------------------
- * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.
+ * (C) Copyright 2003-2007, by Richard Atkinson and Contributors.
  *
  * Original Author:  Richard Atkinson;
- * Contributors:     David Gilbert (for Object Refinery Limited);
  *
  * Changes
  * -------
  * 12-Aug-2003 : Version 1 (RA);
- * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);
- *
+ * 
  */
-
+ 
 package org.jfree.chart.imagemap;
 
 /**
- * Generates tooltips using the Dynamic Drive DHTML Tip Message
+ * Generates tooltips using the Dynamic Drive DHTML Tip Message 
  * library (http://www.dynamicdrive.com).
  */
-public class DynamicDriveToolTipTagFragmentGenerator
-        implements ToolTipTagFragmentGenerator {
+public class DynamicDriveToolTipTagFragmentGenerator 
+    implements ToolTipTagFragmentGenerator {
 
     /** The title, empty string not to display */
     protected String title = "";
@@ -78,14 +76,13 @@
      * Generates a tooltip string to go in an HTML image map.
      *
      * @param toolTipText  the tooltip.
-     *
+     * 
      * @return The formatted HTML area tag attribute(s).
      */
     public String generateToolTipFragment(String toolTipText) {
-        return " onMouseOver=\"return stm(['"
-            + ImageMapUtilities.htmlEscape(this.title) + "','"
-            + ImageMapUtilities.htmlEscape(toolTipText) + "'],Style["
-            + this.style + "]);\"" + " onMouseOut=\"return htm();\"";
+        return " onMouseOver=\"return stm(['" + this.title + "','" 
+            + toolTipText + "'],Style[" + this.style + "]);\"" 
+            + " onMouseOut=\"return htm();\"";
     }
 
 }
Index: org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java
===================================================================
--- org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java	(revision 1065)
+++ org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java	(revision 1064)
@@ -45,16 +43,9 @@
  * Generates tooltips using the HTML title attribute for image map area tags.
  */
 public class StandardToolTipTagFragmentGenerator 
-        implements ToolTipTagFragmentGenerator {
+    implements ToolTipTagFragmentGenerator {
 
     /**
-     * Creates a new instance.
-     */
-    public StandardToolTipTagFragmentGenerator() {
-        super();
-    }
-	
-    /**
      * Generates a tooltip string to go in an HTML image map.
      *
      * @param toolTipText  the tooltip.
@@ -62,8 +53,7 @@
      * @return The formatted HTML area tag attribute(s).
      */
     public String generateToolTipFragment(String toolTipText) {
-        return " title=\"" + ImageMapUtilities.htmlEscape(toolTipText) 
-            + "\" alt=\"\"";
+        return " title=\"" + toolTipText + "\" alt=\"\"";
     }
 
 }
Index: org/jfree/chart/imagemap/OverLIBToolTipTagFragmentGenerator.java
===================================================================
--- org/jfree/chart/imagemap/OverLIBToolTipTagFragmentGenerator.java	(revision 1065)
+++ org/jfree/chart/imagemap/OverLIBToolTipTagFragmentGenerator.java	(revision 1064)
@@ -46,25 +44,17 @@
  * (http://www.bosrup.com/web/overlib/).
  */
 public class OverLIBToolTipTagFragmentGenerator 
-        implements ToolTipTagFragmentGenerator {
+    implements ToolTipTagFragmentGenerator {
 
     /**
-     * Creates a new instance.
-     */
-    public OverLIBToolTipTagFragmentGenerator() {
-        super();
-    }
-	
-    /**
      * Generates a tooltip string to go in an HTML image map.
      *
-     * @param toolTipText  the tooltip text.
+     * @param toolTipText  the tooltip.
      * 
      * @return The formatted HTML area tag attribute(s).
      */
     public String generateToolTipFragment(String toolTipText) {
-        return " onMouseOver=\"return overlib('" 
-                + ImageMapUtilities.htmlEscape(toolTipText) 
+        return " onMouseOver=\"return overlib('" + toolTipText 
                 + "');\" onMouseOut=\"return nd();\"";
     }
 

```

# Chart 11


Nb Executed tests: 3621

Nb Failing tests: 2

>	org.jfree.chart.util.junit.ShapeUtilitiesTests#testEqualGeneralPaths
>	org.jfree.chart.util.junit.ShapeUtilitiesTests#testEqualGeneralPaths

## Human Patch 

```Java
Index: org/jfree/chart/util/ShapeUtilities.java
===================================================================
--- org/jfree/chart/util/ShapeUtilities.java	(revision 1025)
+++ org/jfree/chart/util/ShapeUtilities.java	(revision 1024)
@@ -272,7 +271,7 @@
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
-        PathIterator iterator2 = p2.getPathIterator(null);
+        PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
Index: org/jfree/chart/util/SerialUtilities.java
===================================================================
--- org/jfree/chart/util/SerialUtilities.java	(revision 1025)
+++ org/jfree/chart/util/SerialUtilities.java	(revision 1024)
@@ -315,18 +314,21 @@
                             gp.lineTo(args[0], args[1]);
                             break;
                         case PathIterator.SEG_CUBICTO :
-                            gp.curveTo(args[0], args[1], args[2],
-                                    args[3], args[4], args[5]);
+                            gp.curveTo(
+                                args[0], args[1], args[2],
+                                args[3], args[4], args[5]
+                            );
                             break;
                         case PathIterator.SEG_QUADTO :
                             gp.quadTo(args[0], args[1], args[2], args[3]);
                             break;
                         case PathIterator.SEG_CLOSE :
-                            gp.closePath();
+                            //result = gp;
                             break;
                         default :
                             throw new RuntimeException(
-                                    "JFreeChart - No path exists");
+                                "JFreeChart - No path exists"
+                            );
                     }
                     gp.setWindingRule(stream.readInt());
                     hasNext = stream.readBoolean();

```

# Chart 12


Nb Executed tests: 3613

Nb Failing tests: 2

>	org.jfree.chart.plot.junit.MultiplePiePlotTests#testConstructor
>	org.jfree.chart.plot.junit.MultiplePiePlotTests#testConstructor

## Human Patch 

```Java
Index: org/jfree/chart/plot/MultiplePiePlot.java
===================================================================
--- org/jfree/chart/plot/MultiplePiePlot.java	(revision 852)
+++ org/jfree/chart/plot/MultiplePiePlot.java	(revision 846)
@@ -90,65 +88,65 @@
 import org.jfree.data.general.PieDataset;
 
 /**
- * A plot that displays multiple pie plots using data from a
+ * A plot that displays multiple pie plots using data from a 
  * {@link CategoryDataset}.
  */
 public class MultiplePiePlot extends Plot implements Cloneable, Serializable {
-
+    
     /** For serialization. */
     private static final long serialVersionUID = -355377800470807389L;
-
+    
     /** The chart object that draws the individual pie charts. */
     private JFreeChart pieChart;
-
+    
     /** The dataset. */
     private CategoryDataset dataset;
-
+    
     /** The data extract order (by row or by column). */
     private TableOrder dataExtractOrder;
-
+    
     /** The pie section limit percentage. */
     private double limit = 0.0;
-
-    /**
-     * The key for the aggregated items.
+    
+    /** 
+     * The key for the aggregated items. 
      * @since 1.0.2
      */
     private Comparable aggregatedItemsKey;
-
-    /**
-     * The paint for the aggregated items.
+    
+    /** 
+     * The paint for the aggregated items. 
      * @since 1.0.2
      */
     private transient Paint aggregatedItemsPaint;
-
-    /**
-     * The colors to use for each section.
+    
+    /** 
+     * The colors to use for each section. 
      * @since 1.0.2
      */
     private transient Map sectionPaints;
-
+    
     /**
      * Creates a new plot with no data.
      */
     public MultiplePiePlot() {
         this(null);
     }
-
+    
     /**
      * Creates a new plot.
-     *
+     * 
      * @param dataset  the dataset (<code>null</code> permitted).
      */
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
-        setDataset(dataset);
+        this.dataset = dataset;
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
         this.dataExtractOrder = TableOrder.BY_COLUMN;
         this.pieChart.setBackgroundPaint(null);
-        TextTitle seriesTitle = new TextTitle("Series Title",
+        TextTitle seriesTitle = new TextTitle("Series Title", 
                 new Font("SansSerif", Font.BOLD, 12));
         seriesTitle.setPosition(RectangleEdge.BOTTOM);
         this.pieChart.setTitle(seriesTitle);
@@ -156,24 +154,24 @@
         this.aggregatedItemsPaint = Color.lightGray;
         this.sectionPaints = new HashMap();
     }
-
+    
     /**
      * Returns the dataset used by the plot.
-     *
+     * 
      * @return The dataset (possibly <code>null</code>).
      */
     public CategoryDataset getDataset() {
-        return this.dataset;
+        return this.dataset;   
     }
-
+    
     /**
      * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}
      * to all registered listeners.
-     *
+     * 
      * @param dataset  the dataset (<code>null</code> permitted).
      */
     public void setDataset(CategoryDataset dataset) {
-        // if there is an existing dataset, remove the plot from the list of
+        // if there is an existing dataset, remove the plot from the list of 
         // change listeners...
         if (this.dataset != null) {
             this.dataset.removeChangeListener(this);
@@ -320,19 +318,19 @@
         this.aggregatedItemsPaint = paint;
         fireChangeEvent();
     }
-
+    
     /**
      * Returns a short string describing the type of plot.
      *
      * @return The plot type.
      */
     public String getPlotType() {
-        return "Multiple Pie Plot";
+        return "Multiple Pie Plot";  
          // TODO: need to fetch this from localised resources
     }
 
     /**
-     * Draws the plot on a Java 2D graphics device (such as the screen or a
+     * Draws the plot on a Java 2D graphics device (such as the screen or a 
      * printer).
      *
      * @param g2  the graphics device.
@@ -341,19 +339,19 @@
      * @param parentState  the state from the parent plot, if there is one.
      * @param info  collects info about the drawing.
      */
-    public void draw(Graphics2D g2,
+    public void draw(Graphics2D g2, 
                      Rectangle2D area,
                      Point2D anchor,
                      PlotState parentState,
                      PlotRenderingInfo info) {
-
-
+        
+       
         // adjust the drawing area for the plot insets (if any)...
         RectangleInsets insets = getInsets();
         insets.trim(area);
         drawBackground(g2, area);
         drawOutline(g2, area);
-
+        
         // check that there is some data to display...
         if (DatasetUtilities.isEmptyOrNull(this.dataset)) {
             drawNoDataMessage(g2, area);
@@ -370,7 +368,7 @@
 
         // the columns variable is always >= rows
         int displayCols = (int) Math.ceil(Math.sqrt(pieCount));
-        int displayRows
+        int displayRows 
             = (int) Math.ceil((double) pieCount / (double) displayCols);
 
         // swap rows and columns to match plotArea shape
@@ -393,7 +391,7 @@
         Rectangle rect = new Rectangle();
 
         for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {
-            rect.setBounds(x + xoffset + (width * column), y + (height * row),
+            rect.setBounds(x + xoffset + (width * column), y + (height * row), 
                     width, height);
 
             String title = null;
@@ -404,9 +402,9 @@
                 title = this.dataset.getColumnKey(pieIndex).toString();
             }
             this.pieChart.setTitle(title);
-
+            
             PieDataset piedataset = null;
-            PieDataset dd = new CategoryToPieDataset(this.dataset,
+            PieDataset dd = new CategoryToPieDataset(this.dataset, 
                     this.dataExtractOrder, pieIndex);
             if (this.limit > 0.0) {
                 piedataset = DatasetUtilities.createConsolidatedPieDataset(
@@ -455,26 +453,26 @@
         }
 
     }
-
+    
     /**
      * For each key in the dataset, check the <code>sectionPaints</code>
-     * cache to see if a paint is associated with that key and, if not,
+     * cache to see if a paint is associated with that key and, if not, 
      * fetch one from the drawing supplier.  These colors are cached so that
      * the legend and all the subplots use consistent colors.
      */
     private void prefetchSectionPaints() {
-
+        
         // pre-fetch the colors for each key...this is because the subplots
         // may not display every key, but we need the coloring to be
         // consistent...
-
+        
         PiePlot piePlot = (PiePlot) getPieChart().getPlot();
-
+        
         if (this.dataExtractOrder == TableOrder.BY_ROW) {
             // column keys provide potential keys for individual pies
             for (int c = 0; c < this.dataset.getColumnCount(); c++) {
                 Comparable key = this.dataset.getColumnKey(c);
-                Paint p = piePlot.getSectionPaint(key);
+                Paint p = piePlot.getSectionPaint(key); 
                 if (p == null) {
                     p = (Paint) this.sectionPaints.get(key);
                     if (p == null) {
@@ -485,10 +483,10 @@
             }
         }
         else {
-            // row keys provide potential keys for individual pies
+            // row keys provide potential keys for individual pies            
             for (int r = 0; r < this.dataset.getRowCount(); r++) {
                 Comparable key = this.dataset.getRowKey(r);
-                Paint p = piePlot.getSectionPaint(key);
+                Paint p = piePlot.getSectionPaint(key); 
                 if (p == null) {
                     p = (Paint) this.sectionPaints.get(key);
                     if (p == null) {
@@ -529,8 +527,8 @@
                     String label = key.toString();
                     String description = label;
                     Paint paint = (Paint) this.sectionPaints.get(key);
-                    LegendItem item = new LegendItem(label, description,
-                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,
+                    LegendItem item = new LegendItem(label, description, 
+                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE, 
                             paint, Plot.DEFAULT_OUTLINE_STROKE, paint);
                     item.setDataset(getDataset());
                     result.add(item);
@@ -538,56 +536,56 @@
                 }
             }
             if (this.limit > 0.0) {
-                result.add(new LegendItem(this.aggregatedItemsKey.toString(),
-                        this.aggregatedItemsKey.toString(), null, null,
-                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,
+                result.add(new LegendItem(this.aggregatedItemsKey.toString(), 
+                        this.aggregatedItemsKey.toString(), null, null, 
+                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE, 
                         this.aggregatedItemsPaint,
-                        Plot.DEFAULT_OUTLINE_STROKE,
+                        Plot.DEFAULT_OUTLINE_STROKE, 
                         this.aggregatedItemsPaint));
             }
         }
         return result;
     }
-
+    
     /**
-     * Tests this plot for equality with an arbitrary object.  Note that the
+     * Tests this plot for equality with an arbitrary object.  Note that the 
      * plot's dataset is not considered in the equality test.
-     *
+     * 
      * @param obj  the object (<code>null</code> permitted).
-     *
+     * 
      * @return <code>true</code> if this plot is equal to <code>obj</code>, and
      *     <code>false</code> otherwise.
      */
     public boolean equals(Object obj) {
         if (obj == this) {
-            return true;
+            return true;   
         }
         if (!(obj instanceof MultiplePiePlot)) {
-            return false;
+            return false;   
         }
         MultiplePiePlot that = (MultiplePiePlot) obj;
         if (this.dataExtractOrder != that.dataExtractOrder) {
-            return false;
+            return false;   
         }
         if (this.limit != that.limit) {
-            return false;
+            return false;   
         }
         if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
             return false;
         }
-        if (!PaintUtilities.equal(this.aggregatedItemsPaint,
+        if (!PaintUtilities.equal(this.aggregatedItemsPaint, 
                 that.aggregatedItemsPaint)) {
             return false;
         }
         if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
-            return false;
+            return false;   
         }
         if (!super.equals(obj)) {
-            return false;
+            return false;   
         }
         return true;
     }
-
+    
     /**
      * Provides serialization support.
      *
@@ -608,12 +606,12 @@
      * @throws IOException  if there is an I/O error.
      * @throws ClassNotFoundException  if there is a classpath problem.
      */
-    private void readObject(ObjectInputStream stream)
+    private void readObject(ObjectInputStream stream) 
         throws IOException, ClassNotFoundException {
         stream.defaultReadObject();
         this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);
         this.sectionPaints = new HashMap();
     }
 
-
+    
 }

```

# Chart 13


Nb Executed tests: 3597

Nb Failing tests: 2

>	org.jfree.chart.block.junit.BorderArrangementTests#testSizingWithWidthConstraint
>	org.jfree.chart.block.junit.BorderArrangementTests#testSizingWithWidthConstraint

## Human Patch 

```Java
Index: org/jfree/chart/block/BorderArrangement.java
===================================================================
--- org/jfree/chart/block/BorderArrangement.java	(revision 822)
+++ org/jfree/chart/block/BorderArrangement.java	(revision 817)
@@ -114,102 +112,114 @@
             }
         }
     }
-
+    
     /**
-     * Arranges the items in the specified container, subject to the given
+     * Arranges the items in the specified container, subject to the given 
      * constraint.
-     *
+     * 
      * @param container  the container.
      * @param g2  the graphics device.
      * @param constraint  the constraint.
-     *
+     * 
      * @return The block size.
      */
-    public Size2D arrange(BlockContainer container,
-                          Graphics2D g2,
+    public Size2D arrange(BlockContainer container, 
+                          Graphics2D g2, 
                           RectangleConstraint constraint) {
-        RectangleConstraint contentConstraint
-                = container.toContentConstraint(constraint);
+        RectangleConstraint contentConstraint 
+            = container.toContentConstraint(constraint);
         Size2D contentSize = null;
         LengthConstraintType w = contentConstraint.getWidthConstraintType();
         LengthConstraintType h = contentConstraint.getHeightConstraintType();
         if (w == LengthConstraintType.NONE) {
             if (h == LengthConstraintType.NONE) {
-                contentSize = arrangeNN(container, g2);
+                contentSize = arrangeNN(container, g2);  
             }
             else if (h == LengthConstraintType.FIXED) {
-                throw new RuntimeException("Not implemented.");
+                throw new RuntimeException("Not implemented.");  
             }
             else if (h == LengthConstraintType.RANGE) {
-                throw new RuntimeException("Not implemented.");
+                throw new RuntimeException("Not implemented.");  
             }
         }
         else if (w == LengthConstraintType.FIXED) {
             if (h == LengthConstraintType.NONE) {
-                contentSize = arrangeFN(container, g2, constraint.getWidth());
+                contentSize = arrangeFN(container, g2, constraint.getWidth());  
             }
             else if (h == LengthConstraintType.FIXED) {
-                contentSize = arrangeFF(container, g2, constraint);
+                contentSize = arrangeFF(container, g2, constraint);  
             }
             else if (h == LengthConstraintType.RANGE) {
-                contentSize = arrangeFR(container, g2, constraint);
+                contentSize = arrangeFR(container, g2, constraint);  
             }
         }
         else if (w == LengthConstraintType.RANGE) {
             if (h == LengthConstraintType.NONE) {
-                throw new RuntimeException("Not implemented.");
+                throw new RuntimeException("Not implemented.");  
             }
             else if (h == LengthConstraintType.FIXED) {
-                throw new RuntimeException("Not implemented.");
+                throw new RuntimeException("Not implemented.");  
             }
             else if (h == LengthConstraintType.RANGE) {
-                contentSize = arrangeRR(container, constraint.getWidthRange(),
-                        constraint.getHeightRange(), g2);
+                contentSize = arrangeRR(
+                    container, constraint.getWidthRange(),
+                    constraint.getHeightRange(), g2
+                );  
             }
         }
-        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),
-                container.calculateTotalHeight(contentSize.getHeight()));
+        return new Size2D(
+            container.calculateTotalWidth(contentSize.getWidth()),
+            container.calculateTotalHeight(contentSize.getHeight())
+        );
     }
-
+    
     /**
      * Performs an arrangement without constraints.
-     *
+     * 
      * @param container  the container.
      * @param g2  the graphics device.
-     *
+     * 
      * @return The container size after the arrangement.
      */
     protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {
         double[] w = new double[5];
         double[] h = new double[5];
         if (this.topBlock != null) {
-            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);
+            Size2D size = this.topBlock.arrange(
+                g2, RectangleConstraint.NONE
+            );
             w[0] = size.width;
             h[0] = size.height;
         }
         if (this.bottomBlock != null) {
-            Size2D size = this.bottomBlock.arrange(g2,
-                    RectangleConstraint.NONE);
+            Size2D size = this.bottomBlock.arrange(
+                g2, RectangleConstraint.NONE
+            );
             w[1] = size.width;
             h[1] = size.height;
         }
         if (this.leftBlock != null) {
-            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);
+            Size2D size = this.leftBlock.arrange(
+                g2, RectangleConstraint.NONE
+            );
             w[2] = size.width;
             h[2] = size.height;
        }
         if (this.rightBlock != null) {
-            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);
+            Size2D size = this.rightBlock.arrange(
+                g2, RectangleConstraint.NONE
+            );
             w[3] = size.width;
             h[3] = size.height;
         }
-
+        
         h[2] = Math.max(h[2], h[3]);
         h[3] = h[2];
-
+        
         if (this.centerBlock != null) {
-            Size2D size = this.centerBlock.arrange(g2,
-                    RectangleConstraint.NONE);
+            Size2D size = this.centerBlock.arrange(
+                g2, RectangleConstraint.NONE
+            );
             w[4] = size.width;
             h[4] = size.height;
         }
@@ -217,68 +227,76 @@
         double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));
         double height = h[0] + h[1] + centerHeight;
         if (this.topBlock != null) {
-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,
-                    h[0]));
+            this.topBlock.setBounds(
+                new Rectangle2D.Double(0.0, 0.0, width, h[0])
+            );
         }
         if (this.bottomBlock != null) {
-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,
-                    height - h[1], width, h[1]));
+            this.bottomBlock.setBounds(
+                new Rectangle2D.Double(0.0, height - h[1], width, h[1])
+            );
         }
         if (this.leftBlock != null) {
-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
-                    centerHeight));
+            this.leftBlock.setBounds(
+                new Rectangle2D.Double(0.0, h[0], w[2], centerHeight)
+            );
         }
         if (this.rightBlock != null) {
-            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],
-                    h[0], w[3], centerHeight));
+            this.rightBlock.setBounds(
+                new Rectangle2D.Double(width - w[3], h[0], w[3], centerHeight)
+            );
         }
-
+        
         if (this.centerBlock != null) {
-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],
-                    width - w[2] - w[3], centerHeight));
+            this.centerBlock.setBounds(
+                new Rectangle2D.Double(
+                    w[2], h[0], width - w[2] - w[3], centerHeight
+                )
+            );
         }
         return new Size2D(width, height);
     }
 
     /**
      * Performs an arrangement with a fixed width and a range for the height.
-     *
+     * 
      * @param container  the container.
      * @param g2  the graphics device.
      * @param constraint  the constraint.
-     *
+     * 
      * @return The container size after the arrangement.
      */
     protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,
                                RectangleConstraint constraint) {
         Size2D size1 = arrangeFN(container, g2, constraint.getWidth());
         if (constraint.getHeightRange().contains(size1.getHeight())) {
-            return size1;
+            return size1;   
         }
         else {
             double h = constraint.getHeightRange().constrain(size1.getHeight());
             RectangleConstraint c2 = constraint.toFixedHeight(h);
-            return arrange(container, g2, c2);
+            return arrange(container, g2, c2);   
         }
     }
-
-    /**
-     * Arranges the container width a fixed width and no constraint on the
+    
+    /** 
+     * Arranges the container width a fixed width and no constraint on the 
      * height.
-     *
+     * 
      * @param container  the container.
      * @param g2  the graphics device.
      * @param width  the fixed width.
-     *
+     * 
      * @return The container size after arranging the contents.
      */
     protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,
                                double width) {
         double[] w = new double[5];
         double[] h = new double[5];
-        RectangleConstraint c1 = new RectangleConstraint(width, null,
-                LengthConstraintType.FIXED, 0.0, null,
-                LengthConstraintType.NONE);
+        RectangleConstraint c1 = new RectangleConstraint(
+            width, null, LengthConstraintType.FIXED,
+            0.0, null, LengthConstraintType.NONE
+        );
         if (this.topBlock != null) {
             Size2D size = this.topBlock.arrange(g2, c1);
             w[0] = size.width;
@@ -289,9 +307,10 @@
             w[1] = size.width;
             h[1] = size.height;
         }
-        RectangleConstraint c2 = new RectangleConstraint(0.0,
-                new Range(0.0, width), LengthConstraintType.RANGE,
-                0.0, null, LengthConstraintType.NONE);
+        RectangleConstraint c2 = new RectangleConstraint(
+            0.0, new Range(0.0, width), LengthConstraintType.RANGE,
+            0.0, null, LengthConstraintType.NONE
+        );
         if (this.leftBlock != null) {
             Size2D size = this.leftBlock.arrange(g2, c2);
             w[2] = size.width;
@@ -299,22 +318,24 @@
         }
         if (this.rightBlock != null) {
             double maxW = Math.max(width - w[2], 0.0);
-            RectangleConstraint c3 = new RectangleConstraint(0.0,
-                    new Range(Math.min(w[2], maxW), maxW),
-                    LengthConstraintType.RANGE, 0.0, null,
-                    LengthConstraintType.NONE);
+            RectangleConstraint c3 = new RectangleConstraint(
+                0.0, new Range(Math.min(w[2], maxW), maxW), 
+                LengthConstraintType.RANGE,
+                0.0, null, LengthConstraintType.NONE
+            );    
             Size2D size = this.rightBlock.arrange(g2, c3);
             w[3] = size.width;
             h[3] = size.height;
         }
-
+        
         h[2] = Math.max(h[2], h[3]);
         h[3] = h[2];
-
+        
         if (this.centerBlock != null) {
-            RectangleConstraint c4 = new RectangleConstraint(width - w[2]
-                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,
-                    LengthConstraintType.NONE);
+            RectangleConstraint c4 = new RectangleConstraint(
+                width - w[2] - w[3], null, LengthConstraintType.FIXED,
+                0.0, null, LengthConstraintType.NONE
+            );    
             Size2D size = this.centerBlock.arrange(g2, c4);
             w[4] = size.width;
             h[4] = size.height;
@@ -324,62 +345,67 @@
     }
 
     /**
-     * Performs an arrangement with range constraints on both the vertical
+     * Performs an arrangement with range constraints on both the vertical 
      * and horizontal sides.
-     *
+     * 
      * @param container  the container.
      * @param widthRange  the allowable range for the container width.
      * @param heightRange  the allowable range for the container height.
      * @param g2  the graphics device.
-     *
+     * 
      * @return The container size.
      */
-    protected Size2D arrangeRR(BlockContainer container,
-                               Range widthRange, Range heightRange,
+    protected Size2D arrangeRR(BlockContainer container, 
+                               Range widthRange, Range heightRange, 
                                Graphics2D g2) {
         double[] w = new double[5];
         double[] h = new double[5];
         if (this.topBlock != null) {
-            RectangleConstraint c1 = new RectangleConstraint(widthRange,
-                    heightRange);
+            RectangleConstraint c1 = new RectangleConstraint(
+                widthRange, heightRange
+            );
             Size2D size = this.topBlock.arrange(g2, c1);
             w[0] = size.width;
             h[0] = size.height;
         }
         if (this.bottomBlock != null) {
             Range heightRange2 = Range.shift(heightRange, -h[0], false);
-            RectangleConstraint c2 = new RectangleConstraint(widthRange,
-                    heightRange2);
+            RectangleConstraint c2 = new RectangleConstraint(
+                widthRange, heightRange2
+            );  
             Size2D size = this.bottomBlock.arrange(g2, c2);
             w[1] = size.width;
             h[1] = size.height;
         }
         Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));
         if (this.leftBlock != null) {
-            RectangleConstraint c3 = new RectangleConstraint(widthRange,
-                    heightRange3);
+            RectangleConstraint c3 = new RectangleConstraint(
+                widthRange, heightRange3
+            );
             Size2D size = this.leftBlock.arrange(g2, c3);
             w[2] = size.width;
             h[2] = size.height;
         }
         Range widthRange2 = Range.shift(widthRange, -w[2], false);
         if (this.rightBlock != null) {
-            RectangleConstraint c4 = new RectangleConstraint(widthRange2,
-                    heightRange3);
+            RectangleConstraint c4 = new RectangleConstraint(
+                widthRange2, heightRange3
+            );
             Size2D size = this.rightBlock.arrange(g2, c4);
             w[3] = size.width;
             h[3] = size.height;
         }
-
+        
         h[2] = Math.max(h[2], h[3]);
         h[3] = h[2];
         Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);
         if (this.centerBlock != null) {
-            RectangleConstraint c5 = new RectangleConstraint(widthRange3,
-                    heightRange3);
-            // TODO:  the width and height ranges should be reduced by the
+            RectangleConstraint c5 = new RectangleConstraint(
+                widthRange3, heightRange3
+            );
+            // TODO:  the width and height ranges should be reduced by the 
             // height required for the top and bottom, and the width required
-            // by the left and right
+            // by the left and right 
             Size2D size = this.centerBlock.arrange(g2, c5);
             w[4] = size.width;
             h[4] = size.height;
@@ -387,36 +413,43 @@
         double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));
         double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));
         if (this.topBlock != null) {
-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,
-                    h[0]));
+            this.topBlock.setBounds(
+                new Rectangle2D.Double(0.0, 0.0, width, h[0])
+            );
         }
         if (this.bottomBlock != null) {
-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,
-                    height - h[1], width, h[1]));
+            this.bottomBlock.setBounds(
+                new Rectangle2D.Double(0.0, height - h[1], width, h[1])
+            );
         }
         if (this.leftBlock != null) {
-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
-                    h[2]));
+            this.leftBlock.setBounds(
+                new Rectangle2D.Double(0.0, h[0], w[2], h[2])
+            );
         }
         if (this.rightBlock != null) {
-            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],
-                    h[0], w[3], h[3]));
+            this.rightBlock.setBounds(
+                new Rectangle2D.Double(width - w[3], h[0], w[3], h[3])
+            );
         }
-
+        
         if (this.centerBlock != null) {
-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],
-                    width - w[2] - w[3], height - h[0] - h[1]));
+            this.centerBlock.setBounds(
+                new Rectangle2D.Double(
+                    w[2], h[0], width - w[2] - w[3], height - h[0] - h[1]
+                )
+            );
         }
         return new Size2D(width, height);
     }
 
     /**
      * Arranges the items within a container.
-     *
+     * 
      * @param container  the container.
      * @param constraint  the constraint.
      * @param g2  the graphics device.
-     *
+     * 
      * @return The container size after the arrangement.
      */
     protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
@@ -425,69 +458,79 @@
         double[] h = new double[5];
         w[0] = constraint.getWidth();
         if (this.topBlock != null) {
-            RectangleConstraint c1 = new RectangleConstraint(w[0], null,
-                    LengthConstraintType.FIXED, 0.0,
-                    new Range(0.0, constraint.getHeight()),
-                    LengthConstraintType.RANGE);
+            RectangleConstraint c1 = new RectangleConstraint(
+                w[0], null, LengthConstraintType.FIXED,
+                0.0, new Range(0.0, constraint.getHeight()), 
+                LengthConstraintType.RANGE
+            );
             Size2D size = this.topBlock.arrange(g2, c1);
             h[0] = size.height;
         }
         w[1] = w[0];
         if (this.bottomBlock != null) {
-            RectangleConstraint c2 = new RectangleConstraint(w[0], null,
-                    LengthConstraintType.FIXED, 0.0, new Range(0.0,
-                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
+            RectangleConstraint c2 = new RectangleConstraint(
+                w[0], null, LengthConstraintType.FIXED,
+                0.0, new Range(0.0, constraint.getHeight() - h[0]), 
+                LengthConstraintType.RANGE
+            );
             Size2D size = this.bottomBlock.arrange(g2, c2);
             h[1] = size.height;
         }
         h[2] = constraint.getHeight() - h[1] - h[0];
         if (this.leftBlock != null) {
-            RectangleConstraint c3 = new RectangleConstraint(0.0,
-                    new Range(0.0, constraint.getWidth()),
-                    LengthConstraintType.RANGE, h[2], null,
-                    LengthConstraintType.FIXED);
+            RectangleConstraint c3 = new RectangleConstraint(
+                0.0, new Range(0.0, constraint.getWidth()), 
+                LengthConstraintType.RANGE,
+                h[2], null, LengthConstraintType.FIXED
+            );
             Size2D size = this.leftBlock.arrange(g2, c3);
-            w[2] = size.width;
+            w[2] = size.width;            
         }
         h[3] = h[2];
         if (this.rightBlock != null) {
-            RectangleConstraint c4 = new RectangleConstraint(0.0,
-                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),
-                    LengthConstraintType.RANGE, h[2], null,
-                    LengthConstraintType.FIXED);
+            RectangleConstraint c4 = new RectangleConstraint(
+                0.0, new Range(0.0, constraint.getWidth() - w[2]), 
+                LengthConstraintType.RANGE,
+                h[2], null, LengthConstraintType.FIXED
+            );
             Size2D size = this.rightBlock.arrange(g2, c4);
-            w[3] = size.width;
+            w[3] = size.width;            
         }
         h[4] = h[2];
         w[4] = constraint.getWidth() - w[3] - w[2];
         RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
         if (this.centerBlock != null) {
-            this.centerBlock.arrange(g2, c5);
+            this.centerBlock.arrange(g2, c5);   
         }
-
+       
         if (this.topBlock != null) {
-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
-                    h[0]));
+            this.topBlock.setBounds(
+                new Rectangle2D.Double(0.0, 0.0, w[0], h[0])
+            );
         }
         if (this.bottomBlock != null) {
-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
-                    w[1], h[1]));
+            this.bottomBlock.setBounds(
+                new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])
+            );
         }
         if (this.leftBlock != null) {
-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
-                    h[2]));
+            this.leftBlock.setBounds(
+                new Rectangle2D.Double(0.0, h[0], w[2], h[2])
+            );
         }
         if (this.rightBlock != null) {
-            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
-                    w[3], h[3]));
+            this.rightBlock.setBounds(
+                new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])
+            );
         }
         if (this.centerBlock != null) {
-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
-                    h[4]));
+            this.centerBlock.setBounds(
+                new Rectangle2D.Double(w[2], h[0], w[4], h[4])
+            );
         }
         return new Size2D(constraint.getWidth(), constraint.getHeight());
     }
-
+    
     /**
      * Clears the layout.
      */
@@ -498,36 +541,36 @@
         this.leftBlock = null;
         this.rightBlock = null;
     }
-
+    
     /**
      * Tests this arrangement for equality with an arbitrary object.
-     *
+     * 
      * @param obj  the object (<code>null</code> permitted).
-     *
+     * 
      * @return A boolean.
      */
     public boolean equals(Object obj) {
         if (obj == this) {
-            return true;
+            return true;   
         }
         if (!(obj instanceof BorderArrangement)) {
-            return false;
+            return false;   
         }
         BorderArrangement that = (BorderArrangement) obj;
         if (!ObjectUtilities.equal(this.topBlock, that.topBlock)) {
-            return false;
+            return false;   
         }
         if (!ObjectUtilities.equal(this.bottomBlock, that.bottomBlock)) {
-            return false;
+            return false;   
         }
         if (!ObjectUtilities.equal(this.leftBlock, that.leftBlock)) {
-            return false;
+            return false;   
         }
         if (!ObjectUtilities.equal(this.rightBlock, that.rightBlock)) {
-            return false;
+            return false;   
         }
         if (!ObjectUtilities.equal(this.centerBlock, that.centerBlock)) {
-            return false;
+            return false;   
         }
         return true;
     }

```

## NopolPC 

org.jfree.chart.block.BorderArrangement:482 (Suspicious rank: 38 (Ochiai), 4 (Ample), 4 (Tarantula))
```Java
null!=null
```

Nb Angelic value: 1

Nb analyzed Statement: 38

Execution time: 0:00:55.554000

Grid5000 node: chinqchint-32.lille.grid5000.fr


# Chart 14


Nb Executed tests: 3589

Nb Failing tests: 8

>	org.jfree.chart.plot.junit.CategoryPlotTests#testRemoveRangeMarker
>	org.jfree.chart.plot.junit.CategoryPlotTests#testRemoveDomainMarker
>	org.jfree.chart.plot.junit.CategoryPlotTests#testRemoveRangeMarker
>	org.jfree.chart.plot.junit.CategoryPlotTests#testRemoveDomainMarker
>	org.jfree.chart.plot.junit.XYPlotTests#testRemoveRangeMarker
>	org.jfree.chart.plot.junit.XYPlotTests#testRemoveDomainMarker
>	org.jfree.chart.plot.junit.XYPlotTests#testRemoveRangeMarker
>	org.jfree.chart.plot.junit.XYPlotTests#testRemoveDomainMarker

## Human Patch 

```Java
Index: org/jfree/chart/plot/CategoryPlot.java
===================================================================
--- org/jfree/chart/plot/CategoryPlot.java	(revision 811)
+++ org/jfree/chart/plot/CategoryPlot.java	(revision 809)
@@ -2163,9 +2161,6 @@
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
-        if (markers == null) {
-            return false;
-        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2448,9 +2443,7 @@
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
-        if (markers == null) {
-            return false;
-        }
+
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2504,10 +2497,12 @@
      * @see #isRangeCrosshairLockedOnData()
      */
     public void setRangeCrosshairLockedOnData(boolean flag) {
+
         if (this.rangeCrosshairLockedOnData != flag) {
             this.rangeCrosshairLockedOnData = flag;
             fireChangeEvent();
         }
+
     }
 
     /**
Index: org/jfree/chart/plot/XYPlot.java
===================================================================
--- org/jfree/chart/plot/XYPlot.java	(revision 811)
+++ org/jfree/chart/plot/XYPlot.java	(revision 809)
@@ -2290,9 +2288,6 @@
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
-        if (markers == null) {
-            return false;
-        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2529,9 +2524,7 @@
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
-        if (markers == null) {
-            return false;
-        }
+
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

```

# Chart 15


Nb Executed tests: 3579

Nb Failing tests: 2

>	org.jfree.chart.plot.junit.PiePlot3DTests#testDrawWithNullDataset
>	org.jfree.chart.plot.junit.PiePlot3DTests#testDrawWithNullDataset

## Human Patch 

```Java
Index: org/jfree/chart/plot/PiePlot.java
===================================================================
--- org/jfree/chart/plot/PiePlot.java	(revision 749)
+++ org/jfree/chart/plot/PiePlot.java	(revision 747)
@@ -1375,9 +1373,6 @@
      * @return The percent.
      */
     public double getMaximumExplodePercent() {
-        if (this.dataset == null) {
-            return 0.0;
-        }
         double result = 0.0;
         Iterator iterator = this.dataset.getKeys().iterator();
         while (iterator.hasNext()) {
@@ -2051,10 +2046,8 @@
      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
-        if (this.dataset != null) {
-            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
-                    plot.getDataset()));
-        }
+        state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
+                plot.getDataset()));
         state.setLatestAngle(plot.getStartAngle());
         return state;
         

```

# Chart 16


Nb Executed tests: 3575

Nb Failing tests: 16

>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetCategoryIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testSetCategoryKeys
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetSeriesIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetRowCount
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetRowIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetColumnCount
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetColumnIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testCloning2
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetCategoryIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testSetCategoryKeys
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetSeriesIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetRowCount
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetRowIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetColumnCount
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testGetColumnIndex
>	org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests#testCloning2

## Human Patch 

```Java
Index: org/jfree/data/category/DefaultIntervalCategoryDataset.java
===================================================================
--- org/jfree/data/category/DefaultIntervalCategoryDataset.java	(revision 743)
+++ org/jfree/data/category/DefaultIntervalCategoryDataset.java	(revision 741)
@@ -64,7 +62,7 @@
  * first dimension is the series, and the second dimension is the category.
  */
 public class DefaultIntervalCategoryDataset extends AbstractSeriesDataset
-        implements IntervalCategoryDataset {
+                                            implements IntervalCategoryDataset {
 
     /** The series keys. */
     private Comparable[] seriesKeys;
@@ -204,8 +196,8 @@
 
             }
             else {
-                this.seriesKeys = new Comparable[0];
-                this.categoryKeys = new Comparable[0];
+                this.seriesKeys = null;
+                this.categoryKeys = null;
             }
         }
 
@@ -335,7 +327,7 @@
         if (categoryKeys == null) {
             throw new IllegalArgumentException("Null 'categoryKeys' argument.");
         }
-        if (categoryKeys.length != getCategoryCount()) {
+        if (categoryKeys.length != this.startData[0].length) {
             throw new IllegalArgumentException(
                     "The number of categories does not match the data.");
         }

```

# Chart 17


Nb Executed tests: 3499

Nb Failing tests: 2

>	org.jfree.data.time.junit.TimeSeriesTests#testBug1832432
>	org.jfree.data.time.junit.TimeSeriesTests#testBug1832432

## Human Patch 

```Java
Index: org/jfree/data/time/TimeSeries.java
===================================================================
--- org/jfree/data/time/TimeSeries.java	(revision 622)
+++ org/jfree/data/time/TimeSeries.java	(revision 621)
@@ -854,8 +853,7 @@
      *         subclasses may differ.
      */
     public Object clone() throws CloneNotSupportedException {
-        TimeSeries clone = (TimeSeries) super.clone();
-        clone.data = (List) ObjectUtilities.deepClone(this.data);
+        Object clone = createCopy(0, getItemCount() - 1);
         return clone;
     }
 

```

## NopolPC 

org.jfree.data.time.TimeSeries:880 (Suspicious rank: 1 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
(1)==(start)
```

Nb Angelic value: 1

Nb analyzed Statement: 1

Execution time: 0:00:55.833000

Grid5000 node: chimint-7.lille.grid5000.fr


## NopolC 

org.jfree.data.time.TimeSeries:879 (Suspicious rank: 4 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
(org.jfree.data.time.TimeSeries.this.range.length()==0)||(((org.jfree.data.time.TimeSeries.this.data.size())!=(start))&&(end < start))
```

Nb Angelic value: 1

Nb analyzed Statement: 4

Execution time: 0:00:57.130000

Grid5000 node: chimint-15.lille.grid5000.fr


# Chart 18


Nb Executed tests: 3495

Nb Failing tests: 8

>	org.jfree.data.junit.DefaultKeyedValuesTests#testRemoveValue
>	org.jfree.data.junit.DefaultKeyedValuesTests#testGetIndex2
>	org.jfree.data.junit.DefaultKeyedValues2DTests#testRemoveColumnByKey
>	org.jfree.data.junit.DefaultKeyedValues2DTests#testRemoveColumnByKey
>	org.jfree.data.junit.DefaultKeyedValuesTests#testRemoveValue
>	org.jfree.data.junit.DefaultKeyedValuesTests#testGetIndex2
>	org.jfree.data.category.junit.DefaultCategoryDatasetTests#testBug1835955
>	org.jfree.data.category.junit.DefaultCategoryDatasetTests#testBug1835955

## Human Patch 

```Java
Index: org/jfree/data/DefaultKeyedValues.java
===================================================================
--- org/jfree/data/DefaultKeyedValues.java	(revision 621)
+++ org/jfree/data/DefaultKeyedValues.java	(revision 620)
@@ -315,25 +314,27 @@
     public void removeValue(int index) {
         this.keys.remove(index);
         this.values.remove(index);
-        rebuildIndex();
+
+        // did we remove the last item? If not, then rebuild the index ..
+        if (index < this.keys.size()) {
+            rebuildIndex();
+        }
     }
 
     /**
-     * Removes a value from the collection.
+     * Removes a value from the collection.  If there is no item with the 
+     * specified key, this method does nothing.
      *
      * @param key  the item key (<code>null</code> not permitted).
      * 
      * @throws IllegalArgumentException if <code>key</code> is 
      *     <code>null</code>.
-     * @throws UnknownKeyException if <code>key</code> is not recognised.
      */
     public void removeValue(Comparable key) {
         int index = getIndex(key);
-        if (index < 0) {
-            throw new UnknownKeyException("The key (" + key 
-                    + ") is not recognised.");
+        if (index >= 0) {
+            removeValue(index);
         }
-        removeValue(index);
     }
     
     /**
@@ -353,23 +354,23 @@
      * @param order  the sort order (<code>null</code> not permitted).
      */
     public void sortByKeys(SortOrder order) {
-        final int size = this.keys.size();
-        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];
+      final int size = this.keys.size();
+      final DefaultKeyedValue[] data = new DefaultKeyedValue[size];
 
-        for (int i = 0; i < size; i++) {
-            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), 
-                    (Number) this.values.get(i));
-        }
+      for (int i = 0; i < size; i++) {
+          data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), 
+                  (Number) this.values.get(i));
+      }
 
-        Comparator comparator = new KeyedValueComparator(
+      Comparator comparator = new KeyedValueComparator(
                 KeyedValueComparatorType.BY_KEY, order);
-        Arrays.sort(data, comparator);
-        clear();
+      Arrays.sort(data, comparator);
+      clear();
 
-        for (int i = 0; i < data.length; i++) {
-            final DefaultKeyedValue value = data[i];
-            addValue(value.getKey(), value.getValue());
-        }
+      for (int i = 0; i < data.length; i++) {
+          final DefaultKeyedValue value = data[i];
+          addValue(value.getKey(), value.getValue());
+      }
     }
 
     /**
Index: org/jfree/data/DefaultKeyedValues2D.java
===================================================================
--- org/jfree/data/DefaultKeyedValues2D.java	(revision 621)
+++ org/jfree/data/DefaultKeyedValues2D.java	(revision 620)
@@ -439,32 +438,18 @@
     }
 
     /**
-     * Removes a column from the table.
+     * Removes a column.
      *
      * @param columnKey  the column key (<code>null</code> not permitted).
      * 
-     * @throws UnknownKeyException if the table does not contain a column with
-     *     the specified key.
-     * @throws IllegalArgumentException if <code>columnKey</code> is 
-     *     <code>null</code>.
-     * 
      * @see #removeColumn(int)
      * @see #removeRow(Comparable)
      */
     public void removeColumn(Comparable columnKey) {
-    	if (columnKey == null) {
-    		throw new IllegalArgumentException("Null 'columnKey' argument.");
-    	}
-    	if (!this.columnKeys.contains(columnKey)) {
-    		throw new UnknownKeyException("Unknown key: " + columnKey);
-    	}
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();
-            int index = rowData.getIndex(columnKey);
-            if (index >= 0) {
-                rowData.removeValue(columnKey);
-            }
+            rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }

```

# Chart 19


Nb Executed tests: 3459

Nb Failing tests: 4

>	org.jfree.chart.plot.junit.CategoryPlotTests#testGetRangeAxisIndex
>	org.jfree.chart.plot.junit.CategoryPlotTests#testGetDomainAxisIndex
>	org.jfree.chart.plot.junit.CategoryPlotTests#testGetRangeAxisIndex
>	org.jfree.chart.plot.junit.CategoryPlotTests#testGetDomainAxisIndex

## Human Patch 

```Java
Index: org/jfree/chart/plot/CategoryPlot.java
===================================================================
--- org/jfree/chart/plot/CategoryPlot.java	(revision 434)
+++ org/jfree/chart/plot/CategoryPlot.java	(revision 430)
@@ -685,19 +684,13 @@
      * Returns the index of the specified axis, or <code>-1</code> if the axis
      * is not assigned to the plot.
      * 
-     * @param axis  the axis (<code>null</code> not permitted).
+     * @param axis  the axis.
      * 
      * @return The axis index.
      * 
-     * @see #getDomainAxis(int)
-     * @see #getRangeAxisIndex(ValueAxis)
-     * 
      * @since 1.0.3
      */
     public int getDomainAxisIndex(CategoryAxis axis) {
-        if (axis == null) {
-            throw new IllegalArgumentException("Null 'axis' argument.");
-        }
         return this.domainAxes.indexOf(axis);
     }
     
@@ -958,24 +951,19 @@
         notifyListeners(new PlotChangeEvent(this));
     }
     
-
     /**
      * Returns the index of the specified axis, or <code>-1</code> if the axis
      * is not assigned to the plot.
      *
-     * @param axis  the axis (<code>null</code> not permitted).
+     * @param axis  the axis.
      *
      * @return The axis index.
      * 
-     * @see #getRangeAxis(int)
      * @see #getDomainAxisIndex(CategoryAxis)
      * 
      * @since 1.0.7
      */
     public int getRangeAxisIndex(ValueAxis axis) {
-        if (axis == null) {
-            throw new IllegalArgumentException("Null 'axis' argument.");
-        }
         int result = this.rangeAxes.indexOf(axis);
         if (result < 0) { // try the parent plot
             Plot parent = getParent();

```

# Chart 20


Nb Executed tests: 3311

Nb Failing tests: 2

>	org.jfree.chart.plot.junit.ValueMarkerTests#test1808376
>	org.jfree.chart.plot.junit.ValueMarkerTests#test1808376

## Human Patch 

```Java
Index: org/jfree/chart/plot/ValueMarker.java
===================================================================
--- org/jfree/chart/plot/ValueMarker.java	(revision 283)
+++ org/jfree/chart/plot/ValueMarker.java	(revision 281)
@@ -88,11 +88,11 @@
      * @param stroke  the stroke (<code>null</code> not permitted).
      * @param outlinePaint  the outline paint (<code>null</code> permitted).
      * @param outlineStroke  the outline stroke (<code>null</code> permitted).
-     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).
+     * @param alpha  the alpha transparency.
      */
     public ValueMarker(double value, Paint paint, Stroke stroke, 
                        Paint outlinePaint, Stroke outlineStroke, float alpha) {
-        super(paint, stroke, outlinePaint, outlineStroke, alpha);
+        super(paint, stroke, paint, stroke, alpha);
         this.value = value;
     }
     

```

# Chart 21


Nb Executed tests: 3303

Nb Failing tests: 2

>	org.jfree.data.statistics.junit.DefaultBoxAndWhiskerCategoryDatasetTests#testGetRangeBounds
>	org.jfree.data.statistics.junit.DefaultBoxAndWhiskerCategoryDatasetTests#testGetRangeBounds

## Human Patch 

```Java
Index: org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java
===================================================================
--- org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java	(revision 231)
+++ org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java	(revision 227)
@@ -120,14 +119,12 @@
      *
      * @param list  a collection of values from which the various medians will 
      *              be calculated.
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
-     * 
-     * @see #add(BoxAndWhiskerItem, Comparable, Comparable)
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      */
     public void add(List list, Comparable rowKey, Comparable columnKey) {
-        BoxAndWhiskerItem item = BoxAndWhiskerCalculator
-                .calculateBoxAndWhiskerStatistics(list);
+        BoxAndWhiskerItem item 
+            = BoxAndWhiskerCalculator.calculateBoxAndWhiskerStatistics(list);
         add(item, rowKey, columnKey);
     }
     
@@ -136,60 +133,62 @@
      * table.  The various median values are calculated.
      *
      * @param item  a box and whisker item (<code>null</code> not permitted).
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
-     * 
-     * @see #add(List, Comparable, Comparable)
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      */
-    public void add(BoxAndWhiskerItem item, Comparable rowKey, 
-            Comparable columnKey) {
+    public void add(BoxAndWhiskerItem item, 
+                    Comparable rowKey, 
+                    Comparable columnKey) {
 
         this.data.addObject(item, rowKey, columnKey);
         
         // update cached min and max values
         int r = this.data.getRowIndex(rowKey);
         int c = this.data.getColumnIndex(columnKey);
-        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn 
-                == c) || (this.minimumRangeValueRow == r 
-                && this.minimumRangeValueColumn == c))  {
-            updateBounds();
+        if (this.maximumRangeValueRow == r 
+                && this.maximumRangeValueColumn == c) {
+            this.maximumRangeValue = Double.NaN;
         }
-        else {
+        if (this.minimumRangeValueRow == r 
+                && this.minimumRangeValueColumn == c) {
+            this.minimumRangeValue = Double.NaN;
+        }
         
-            double minval = Double.NaN;
-            if (item.getMinOutlier() != null) {
-                minval = item.getMinOutlier().doubleValue();
-            }
-            double maxval = Double.NaN;
-            if (item.getMaxOutlier() != null) {
-                maxval = item.getMaxOutlier().doubleValue();
-            }
         
-            if (Double.isNaN(this.maximumRangeValue)) {
-                this.maximumRangeValue = maxval;
-                this.maximumRangeValueRow = r;
-                this.maximumRangeValueColumn = c;
-            }
-            else if (maxval > this.maximumRangeValue) {
-                this.maximumRangeValue = maxval;
-                this.maximumRangeValueRow = r;
-                this.maximumRangeValueColumn = c;
-            }
+        double minval = Double.NaN;
+        if (item.getMinOutlier() != null) {
+            minval = item.getMinOutlier().doubleValue();
+        }
+        double maxval = Double.NaN;
+        if (item.getMaxOutlier() != null) {
+            maxval = item.getMaxOutlier().doubleValue();
+        }
         
-            if (Double.isNaN(this.minimumRangeValue)) {
-                this.minimumRangeValue = minval;
-                this.minimumRangeValueRow = r;
-                this.minimumRangeValueColumn = c;
-            }
-            else if (minval < this.minimumRangeValue) {
-                this.minimumRangeValue = minval;
-                this.minimumRangeValueRow = r;
-                this.minimumRangeValueColumn = c;
-            }
+        if (Double.isNaN(this.maximumRangeValue)) {
+            this.maximumRangeValue = maxval;
+            this.maximumRangeValueRow = r;
+            this.maximumRangeValueColumn = c;
         }
+        else if (maxval > this.maximumRangeValue) {
+            this.maximumRangeValue = maxval;
+            this.maximumRangeValueRow = r;
+            this.maximumRangeValueColumn = c;
+        }
         
+        if (Double.isNaN(this.minimumRangeValue)) {
+            this.minimumRangeValue = minval;
+            this.minimumRangeValueRow = r;
+            this.minimumRangeValueColumn = c;
+        }
+        else if (minval < this.minimumRangeValue) {
+            this.minimumRangeValue = minval;
+            this.minimumRangeValueRow = r;
+            this.minimumRangeValueColumn = c;
+        }
+        
         this.rangeBounds = new Range(this.minimumRangeValue,
               this.maximumRangeValue);
+
         fireDatasetChanged();
 
     }
@@ -735,52 +678,6 @@
     }
     
     /**
-     * Resets the cached bounds, by iterating over the entire dataset to find
-     * the current bounds.
-     */
-    private void updateBounds() {
-        this.minimumRangeValue = Double.NaN;
-        this.minimumRangeValueRow = -1;
-        this.minimumRangeValueColumn = -1;
-        this.maximumRangeValue = Double.NaN;
-        this.maximumRangeValueRow = -1;
-        this.maximumRangeValueColumn = -1;
-        int rowCount = getRowCount();
-        int columnCount = getColumnCount();
-        for (int r = 0; r < rowCount; r++) {
-            for (int c = 0; c < columnCount; c++) {
-                BoxAndWhiskerItem item = getItem(r, c);
-                if (item != null) {
-                    Number min = item.getMinOutlier();
-                    if (min != null) {
-                        double minv = min.doubleValue();
-                        if (!Double.isNaN(minv)) {
-                            if (minv < this.minimumRangeValue || Double.isNaN(
-                                    this.minimumRangeValue)) {
-                                this.minimumRangeValue = minv;
-                                this.minimumRangeValueRow = r;
-                                this.minimumRangeValueColumn = c;
-                            }
-                        }
-                    }
-                    Number max = item.getMaxOutlier();
-                    if (max != null) {
-                        double maxv = max.doubleValue();
-                        if (!Double.isNaN(maxv)) {
-                            if (maxv > this.maximumRangeValue || Double.isNaN(
-                                    this.maximumRangeValue)) {
-                                this.maximumRangeValue = maxv;
-                                this.maximumRangeValueRow = r;
-                                this.maximumRangeValueColumn = c;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    /**
      * Tests this dataset for equality with an arbitrary object.
      * 
      * @param obj  the object to test against (<code>null</code> permitted).

```

## NopolPC 

org.jfree.data.Range:335 (Suspicious rank: 9 (Ochiai), 9 (Ample), 9 (Tarantula))
```Java
((((-1)-(1))+(org.jfree.data.Range.this.upper))<=(0))||((org.jfree.data.Range.this.lower)<(((-1)-(1))+(org.jfree.data.Range.this.upper)))
```

Nb Angelic value: 1

Nb analyzed Statement: 9

Execution time: 0:00:59.628000

Grid5000 node: chimint-3.lille.grid5000.fr


# Chart 22


Nb Executed tests: 3301

Nb Failing tests: 12

>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveColumnByKey
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveValue
>	org.jfree.data.junit.KeyedObjects2DTests#testGetValueByKey
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveColumnByIndex
>	org.jfree.data.junit.KeyedObjects2DTests#testSetObject
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveRowByKey
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveColumnByKey
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveValue
>	org.jfree.data.junit.KeyedObjects2DTests#testGetValueByKey
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveColumnByIndex
>	org.jfree.data.junit.KeyedObjects2DTests#testSetObject
>	org.jfree.data.junit.KeyedObjects2DTests#testRemoveRowByKey

## Human Patch 

```Java
Index: org/jfree/data/KeyedObjects2D.java
===================================================================
--- org/jfree/data/KeyedObjects2D.java	(revision 227)
+++ org/jfree/data/KeyedObjects2D.java	(revision 225)
@@ -201,52 +199,33 @@
     /**
      * Returns the object for the given row and column keys.
      *
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      *
-     * @return The object (possibly <code>null</code>).
-     * 
-     * @throws IllegalArgumentException if <code>rowKey<code> or 
-     *         <code>columnKey</code> is <code>null</code>.
-     * @throws UnknownKeyException if <code>rowKey</code> or 
-     *         <code>columnKey</code> is not recognised.
+     * @return The object.
      */
     public Object getObject(Comparable rowKey, Comparable columnKey) {
-        if (rowKey == null) {
-            throw new IllegalArgumentException("Null 'rowKey' argument.");
-        }
-        if (columnKey == null) {
-            throw new IllegalArgumentException("Null 'columnKey' argument.");
-        }
+
+        Object result = null;
         int row = this.rowKeys.indexOf(rowKey);
-        if (row < 0) {
-            throw new UnknownKeyException("Row key (" + rowKey 
-                    + ") not recognised.");
+        if (row >= 0) {
+            KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
+            result = rowData.getObject(columnKey);
         }
-        int column = this.columnKeys.indexOf(columnKey);
-        if (column < 0) {
-            throw new UnknownKeyException("Column key (" + columnKey 
-                    + ") not recognised.");
-        }
-        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
-        int index = rowData.getIndex(columnKey);
-        if (index >= 0) {
-            return rowData.getObject(index);
-        }
-        else {
-            return null;
-        }
+        return result;
+
     }
 
     /**
      * Adds an object to the table.  Performs the same function as setObject().
      *
      * @param object  the object.
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      */
-    public void addObject(Object object, Comparable rowKey, 
-            Comparable columnKey) {
+    public void addObject(Object object, 
+                          Comparable rowKey, 
+                          Comparable columnKey) {
         setObject(object, rowKey, columnKey);
     }
 
@@ -254,18 +233,13 @@
      * Adds or updates an object.
      *
      * @param object  the object.
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      */
-    public void setObject(Object object, Comparable rowKey, 
-            Comparable columnKey) {
+    public void setObject(Object object, 
+                          Comparable rowKey, 
+                          Comparable columnKey) {
 
-        if (rowKey == null) {
-            throw new IllegalArgumentException("Null 'rowKey' argument.");
-        }
-        if (columnKey == null) {
-            throw new IllegalArgumentException("Null 'columnKey' argument.");
-        }
         KeyedObjects row;
         int rowIndex = this.rowKeys.indexOf(rowKey);
         if (rowIndex >= 0) {
@@ -285,68 +259,21 @@
     }
 
     /**
-     * Removes an object from the table by setting it to <code>null</code>.  If
-     * all the objects in the specified row and/or column are now 
-     * <code>null</code>, the row and/or column is removed from the table.
+     * Removes an object.
      *
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * @param columnKey  the column key (<code>null</code> not permitted).
-     * 
-     * @see #addObject(Object, Comparable, Comparable)
+     * @param rowKey  the row key.
+     * @param columnKey  the column key.
      */
     public void removeObject(Comparable rowKey, Comparable columnKey) {
         setObject(null, rowKey, columnKey);
-        
-        // 1. check whether the row is now empty.
-        boolean allNull = true;
-        int rowIndex = getRowIndex(rowKey);
-        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);
-
-        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; 
-             item++) {
-            if (row.getObject(item) != null) {
-                allNull = false;
-                break;
-            }
-        }
-        
-        if (allNull) {
-            this.rowKeys.remove(rowIndex);
-            this.rows.remove(rowIndex);
-        }
-        
-        // 2. check whether the column is now empty.
-        allNull = true;
-        
-        for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
-             item++) {
-            row = (KeyedObjects) this.rows.get(item);
-            int columnIndex = row.getIndex(columnKey);
-            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {
-                allNull = false;
-                break;
-            }
-        }
-        
-        if (allNull) {
-            for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
-                 item++) {
-                row = (KeyedObjects) this.rows.get(item);
-                int columnIndex = row.getIndex(columnKey);
-                if (columnIndex >= 0) {
-                    row.removeValue(columnIndex);
-                }
-            }
-            this.columnKeys.remove(columnKey);
-        }
+        // actually, a null value is different to a value that doesn't exist 
+        // at all, need to fix this code.
     }
 
     /**
-     * Removes an entire row from the table.
+     * Removes a row.
      *
      * @param rowIndex  the row index.
-     * 
-     * @see #removeColumn(int)
      */
     public void removeRow(int rowIndex) {
         this.rowKeys.remove(rowIndex);
@@ -354,29 +281,18 @@
     }
 
     /**
-     * Removes an entire row from the table.
+     * Removes a row.
      *
-     * @param rowKey  the row key (<code>null</code> not permitted).
-     * 
-     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.
-     * 
-     * @see #removeColumn(Comparable)
+     * @param rowKey  the row key.
      */
     public void removeRow(Comparable rowKey) {
-        int index = getRowIndex(rowKey);
-        if (index < 0) {
-            throw new UnknownKeyException("Row key (" + rowKey 
-                    + ") not recognised.");
-        }
-        removeRow(index);
+        removeRow(getRowIndex(rowKey));
     }
 
     /**
-     * Removes an entire column from the table.
+     * Removes a column.
      *
      * @param columnIndex  the column index.
-     * 
-     * @see #removeRow(int)
      */
     public void removeColumn(int columnIndex) {
         Comparable columnKey = getColumnKey(columnIndex);
@@ -384,27 +300,15 @@
     }
 
     /**
-     * Removes an entire column from the table.
+     * Removes a column.
      *
-     * @param columnKey  the column key (<code>null</code> not permitted).
-     * 
-     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.
-     * 
-     * @see #removeRow(Comparable)
+     * @param columnKey  the column key.
      */
     public void removeColumn(Comparable columnKey) {
-        int index = getColumnIndex(columnKey);
-        if (index < 0) {
-            throw new UnknownKeyException("Column key (" + columnKey 
-                    + ") not recognised.");
-        }
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
-            int i = rowData.getIndex(columnKey);
-            if (i >= 0) {
-                rowData.removeValue(i);
-            }
+            rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }

```

# Chart 23


Nb Executed tests: 3259

Nb Failing tests: 2

>	org.jfree.chart.renderer.category.junit.MinMaxCategoryRendererTests#testEquals
>	org.jfree.chart.renderer.category.junit.MinMaxCategoryRendererTests#testEquals

## Human Patch 

```Java
Index: org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java
===================================================================
--- org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java	(revision 210)
+++ org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java	(revision 209)
@@ -83,11 +82,12 @@
 
 import org.jfree.chart.axis.CategoryAxis;
 import org.jfree.chart.axis.ValueAxis;
+import org.jfree.chart.entity.CategoryItemEntity;
 import org.jfree.chart.entity.EntityCollection;
 import org.jfree.chart.event.RendererChangeEvent;
+import org.jfree.chart.labels.CategoryToolTipGenerator;
 import org.jfree.chart.plot.CategoryPlot;
 import org.jfree.chart.plot.PlotOrientation;
-import org.jfree.chart.util.PaintUtilities;
 import org.jfree.chart.util.SerialUtilities;
 import org.jfree.data.category.CategoryDataset;
 
@@ -216,17 +216,12 @@
 
     /**
      * Sets the stroke of the line between the minimum value and the maximum 
-     * value and sends a {@link RendererChangeEvent} to all registered 
-     * listeners.
+     * value.
      *
-     * @param stroke the new stroke (<code>null</code> not permitted).
+     * @param groupStroke The new stroke
      */
-    public void setGroupStroke(Stroke stroke) {
-        if (stroke == null) {
-            throw new IllegalArgumentException("Null 'stroke' argument.");
-        }
-        this.groupStroke = stroke;
-        notifyListeners(new RendererChangeEvent(this));        
+    public void setGroupStroke(Stroke groupStroke) {
+        this.groupStroke = groupStroke;
     }
 
     /**
@@ -414,43 +409,24 @@
                 }
             }
 
-            // add an item entity, if this information is being collected
-            EntityCollection entities = state.getEntityCollection();
-            if (entities != null && shape != null) {
-                addItemEntity(entities, dataset, row, column, shape);
+            // collect entity and tool tip information...
+            if (state.getInfo() != null) {
+                EntityCollection entities = state.getEntityCollection();
+                if (entities != null && shape != null) {
+                    String tip = null;
+                    CategoryToolTipGenerator tipster = getToolTipGenerator(row,
+                            column);
+                    if (tipster != null) {
+                        tip = tipster.generateToolTip(dataset, row, column);
+                    }
+                    CategoryItemEntity entity = new CategoryItemEntity(
+                            shape, tip, null, dataset, dataset.getRowKey(row), 
+                            dataset.getColumnKey(column));
+                    entities.add(entity);
+                }
             }
         }
     }
-    
-    /**
-     * Tests this instance for equality with an arbitrary object.  The icon fields
-     * are NOT included in the test, so this implementation is a little weak.
-     * 
-     * @param obj  the object (<code>null</code> permitted).
-     * 
-     * @return A boolean.
-     *
-     * @since 1.0.7
-     */
-    public boolean equals(Object obj) {
-        if (obj == this) {
-            return true;
-        }
-        if (!(obj instanceof MinMaxCategoryRenderer)) {
-            return false;
-        }
-        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;
-        if (this.plotLines != that.plotLines) {
-            return false;
-        }
-        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {
-            return false;
-        }
-        if (!this.groupStroke.equals(that.groupStroke)) {
-            return false;
-        }
-        return super.equals(obj);
-    }
 
     /**
      * Returns an icon.
@@ -503,7 +479,7 @@
      * @return The icon.
      */
     private Icon getIcon(Shape shape, final boolean fill, 
-            final boolean outline) {
+                         final boolean outline) {
         final int width = shape.getBounds().width;
         final int height = shape.getBounds().height;
         final GeneralPath path = new GeneralPath(shape);

```

# Chart 24


Nb Executed tests: 3253

Nb Failing tests: 2

>	org.jfree.chart.renderer.junit.GrayPaintScaleTests#testGetPaint
>	org.jfree.chart.renderer.junit.GrayPaintScaleTests#testGetPaint

## Human Patch 

```Java
Index: org/jfree/chart/renderer/GrayPaintScale.java
===================================================================
--- org/jfree/chart/renderer/GrayPaintScale.java	(revision 190)
+++ org/jfree/chart/renderer/GrayPaintScale.java	(revision 188)
@@ -115,15 +107,14 @@
     /**
      * Returns a paint for the specified value.
      * 
-     * @param value  the value (must be within the range specified by the
-     *         lower and upper bounds for the scale).
+     * @param value  the value.
      * 
      * @return A paint for the specified value.
      */
     public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
-        int g = (int) ((v - this.lowerBound) / (this.upperBound 
+        int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }

```

# Chart 25


Nb Executed tests: 3243

Nb Failing tests: 8

>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullMeanVertical
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullDeviationVertical
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullMeanHorizontal
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullDeviationHorizontal
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullMeanVertical
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullDeviationVertical
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullMeanHorizontal
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullDeviationHorizontal

## Human Patch 

```Java
Index: org/jfree/chart/renderer/category/StatisticalBarRenderer.java
===================================================================
--- org/jfree/chart/renderer/category/StatisticalBarRenderer.java	(revision 164)
+++ org/jfree/chart/renderer/category/StatisticalBarRenderer.java	(revision 162)
@@ -256,9 +255,6 @@
 
         // BAR X
         Number meanValue = dataset.getMeanValue(row, column);
-        if (meanValue == null) {
-            return;
-        }
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -315,44 +311,41 @@
         }
 
         // standard deviation lines
-        Number n = dataset.getStdDevValue(row, column);
-        if (n != null) {
-            double valueDelta = n.doubleValue();
-            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
-                    + valueDelta, dataArea, yAxisLocation);
-            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
-                    - valueDelta, dataArea, yAxisLocation);
+        double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
+        double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
+                + valueDelta, dataArea, yAxisLocation);
+        double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
+                - valueDelta, dataArea, yAxisLocation);
 
-            if (this.errorIndicatorStroke != null) {
-                g2.setStroke(this.errorIndicatorStroke);
-            }
-            else {
-                g2.setStroke(getItemOutlineStroke(row, column));
-            }
-            if (this.errorIndicatorPaint != null) {
-                g2.setPaint(this.errorIndicatorPaint);  
-            }
-            else {
-                g2.setPaint(getItemOutlinePaint(row, column));   
-            }
-        
-            Line2D line = null;
-            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, 
-                                     highVal, rectY + rectHeight / 2.0d);
-            g2.draw(line);
-            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, 
-                                     highVal, rectY + rectHeight * 0.75);
-            g2.draw(line);
-            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
-                                     lowVal, rectY + rectHeight * 0.75);
-            g2.draw(line);
+        if (this.errorIndicatorStroke != null) {
+            g2.setStroke(this.errorIndicatorStroke);
         }
+        else {
+            g2.setStroke(getItemOutlineStroke(row, column));
+        }
+        if (this.errorIndicatorPaint != null) {
+            g2.setPaint(this.errorIndicatorPaint);  
+        }
+        else {
+            g2.setPaint(getItemOutlinePaint(row, column));   
+        }
         
+        Line2D line = null;
+        line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, 
+                                 highVal, rectY + rectHeight / 2.0d);
+        g2.draw(line);
+        line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, 
+                                 highVal, rectY + rectHeight * 0.75);
+        g2.draw(line);
+        line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
+                                 lowVal, rectY + rectHeight * 0.75);
+        g2.draw(line);
+        
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
         if (generator != null && isItemLabelVisible(row, column)) {
             drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
-                    (value < 0.0));
+                (value < 0.0));
         }        
 
         // add an item entity, if this information is being collected
@@ -406,9 +399,6 @@
 
         // BAR Y
         Number meanValue = dataset.getMeanValue(row, column);
-        if (meanValue == null) {
-            return;
-        }
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -465,43 +455,40 @@
         }
 
         // standard deviation lines
-        Number n = dataset.getStdDevValue(row, column);
-        if (n != null) {
-            double valueDelta = n.doubleValue();
-            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
-                    + valueDelta, dataArea, yAxisLocation);
-            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
-                    - valueDelta, dataArea, yAxisLocation);
+        double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
+        double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
+                + valueDelta, dataArea, yAxisLocation);
+        double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
+                - valueDelta, dataArea, yAxisLocation);
 
-            if (this.errorIndicatorStroke != null) {
-                g2.setStroke(this.errorIndicatorStroke);
-            }
-            else {
-                g2.setStroke(getItemOutlineStroke(row, column));
-            }
-            if (this.errorIndicatorPaint != null) {
-                g2.setPaint(this.errorIndicatorPaint);  
-            }
-            else {
-                g2.setPaint(getItemOutlinePaint(row, column));   
-            }
-            Line2D line = null;
-            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
-                                     rectX + rectWidth / 2.0d, highVal);
-            g2.draw(line);
-            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
-                                     rectX + rectWidth / 2.0d + 5.0d, highVal);
-            g2.draw(line);
-            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
-                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);
-            g2.draw(line);
+        if (this.errorIndicatorStroke != null) {
+            g2.setStroke(this.errorIndicatorStroke);
         }
+        else {
+            g2.setStroke(getItemOutlineStroke(row, column));
+        }
+        if (this.errorIndicatorPaint != null) {
+            g2.setPaint(this.errorIndicatorPaint);  
+        }
+        else {
+            g2.setPaint(getItemOutlinePaint(row, column));   
+        }
+        Line2D line = null;
+        line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
+                                 rectX + rectWidth / 2.0d, highVal);
+        g2.draw(line);
+        line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
+                                 rectX + rectWidth / 2.0d + 5.0d, highVal);
+        g2.draw(line);
+        line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
+                                 rectX + rectWidth / 2.0d + 5.0d, lowVal);
+        g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
         if (generator != null && isItemLabelVisible(row, column)) {
             drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
-                    (value < 0.0));
+                (value < 0.0));
         }        
 
         // add an item entity, if this information is being collected

```

## NopolPC 

org.jfree.chart.renderer.category.StatisticalBarRenderer:207 (Suspicious rank: 4 (Ochiai), 1 (Ample), 47 (Tarantula))
```Java
(org.jfree.chart.renderer.category.StatisticalBarRenderer.serialVersionUID)==(1)
```

Nb Angelic value: 1

Nb analyzed Statement: 4

Execution time: 0:00:56.509000

Grid5000 node: chimint-14.lille.grid5000.fr


## NopolC 

org.jfree.data.statistics.DefaultStatisticalCategoryDataset:110 (Suspicious rank: 8 (Ochiai), 12 (Ample), 70 (Tarantula))
```Java
!(((1)==(org.jfree.data.statistics.DefaultStatisticalCategoryDataset.this.maximumRangeValue))||((org.jfree.data.statistics.DefaultStatisticalCategoryDataset.this.maximumRangeValueIncStdDev)<=(org.jfree.data.statistics.DefaultStatisticalCategoryDataset.this.maximumRangeValue)))
```

Nb Angelic value: 1

Nb analyzed Statement: 8

Execution time: 0:01:01.422000

Grid5000 node: chimint-15.lille.grid5000.fr


# Chart 26


Nb Executed tests: 3191

Nb Failing tests: 46

>	org.jfree.data.time.junit.MonthTests#testParseMonth
>	org.jfree.chart.junit.StackedAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.StackedBarChart3DTests#testDrawWithNullInfo
>	org.jfree.chart.junit.AreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.BarChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.BarChart3DTests#testDrawWithNullInfo
>	org.jfree.chart.junit.GanttChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.GanttChartTests#testDrawWithNullInfo2
>	org.jfree.chart.junit.LineChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.LineChart3DTests#testDrawWithNullInfo
>	org.jfree.chart.junit.StackedAreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.StackedBarChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.StackedBarChart3DTests#testDrawWithNullInfo
>	org.jfree.chart.junit.WaterfallChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.AreaChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.GanttChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.GanttChartTests#testDrawWithNullInfo2
>	org.jfree.chart.plot.junit.CategoryPlotTests#test1654215
>	org.jfree.chart.plot.junit.CategoryPlotTests#testSerialization3
>	org.jfree.chart.plot.junit.CategoryPlotTests#testSerialization4
>	org.jfree.chart.junit.LineChart3DTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.LayeredBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.BoxAndWhiskerRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.GroupedStackedBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.IntervalBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.LayeredBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.LevelRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.MinMaxCategoryRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.StatisticalLineAndShapeRendererTests#testDrawWithNullInfo
>	org.jfree.chart.plot.junit.CategoryPlotTests#test1654215
>	org.jfree.chart.plot.junit.CategoryPlotTests#testSerialization3
>	org.jfree.chart.plot.junit.CategoryPlotTests#testSerialization4
>	org.jfree.chart.junit.StackedBarChartTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.StatisticalLineAndShapeRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.GroupedStackedBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.junit.LineChartTests#testDrawWithNullInfo
>	org.jfree.chart.junit.BarChartTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.MinMaxCategoryRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.IntervalBarRendererTests#testDrawWithNullInfo
>	org.jfree.chart.renderer.category.junit.BoxAndWhiskerRendererTests#testDrawWithNullInfo
>	org.jfree.chart.junit.WaterfallChartTests#testDrawWithNullInfo
>	org.jfree.data.time.junit.MonthTests#testParseMonth
>	org.jfree.chart.renderer.category.junit.LevelRendererTests#testDrawWithNullInfo
>	org.jfree.chart.junit.BarChart3DTests#testDrawWithNullInfo

## Human Patch 

```Java
Index: org/jfree/chart/axis/Axis.java
===================================================================
--- org/jfree/chart/axis/Axis.java	(revision 103)
+++ org/jfree/chart/axis/Axis.java	(revision 102)
@@ -1188,13 +1187,11 @@
 
         }
         if (plotState != null && hotspot != null) {
-            ChartRenderingInfo owner = plotState.getOwner();
-            if (owner != null) {
-                EntityCollection entities = owner.getEntityCollection();
-                if (entities != null) {
-                    entities.add(new AxisLabelEntity(this, hotspot, 
-                            this.labelToolTip, this.labelURL));
-                }
+            EntityCollection entities = plotState.getOwner()
+                    .getEntityCollection();
+            if (entities != null) {
+                entities.add(new AxisLabelEntity(this, hotspot, 
+                        this.labelToolTip, this.labelURL));
             }
         }
         return state;

```

# Math 1


Nb Executed tests: 5222

Nb Failing tests: 2

>	org.apache.commons.math3.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math3.fraction.BigFractionTest#testDigitLimitConstructor

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/fraction/BigFraction.java b/org/apache/commons/math3/fraction/BigFraction.java
index 4ca33eb..5b0a6b4 100644
--- a/org/apache/commons/math3/fraction/BigFraction.java
+++ b/org/apache/commons/math3/fraction/BigFraction.java
@@ -301,11 +301,6 @@ public class BigFraction
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
             if ((p2 > overflow) || (q2 > overflow)) {
-                // in maxDenominator mode, if the last fraction was very close to the actual value
-                // q2 may overflow in the next iteration; in this case return the last one.
-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
-                    break;
-                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
diff --git a/org/apache/commons/math3/fraction/Fraction.java b/org/apache/commons/math3/fraction/Fraction.java
index 002dae9..08d3b95 100644
--- a/org/apache/commons/math3/fraction/Fraction.java
+++ b/org/apache/commons/math3/fraction/Fraction.java
@@ -83,9 +83,6 @@ public class Fraction
     /** Serializable version identifier */
     private static final long serialVersionUID = 3698073679419233275L;
 
-    /** The default epsilon used for convergence. */
-    private static final double DEFAULT_EPSILON = 1e-5;
-
     /** The denominator. */
     private final int denominator;
 
@@ -99,7 +96,7 @@ public class Fraction
      *         converge.
      */
     public Fraction(double value) throws FractionConversionException {
-        this(value, DEFAULT_EPSILON, 100);
+        this(value, 1.0e-5, 100);
     }
 
     /**
@@ -208,13 +206,7 @@ public class Fraction
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
-
             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
-                // in maxDenominator mode, if the last fraction was very close to the actual value
-                // q2 may overflow in the next iteration; in this case return the last one.
-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
-                    break;
-                }
                 throw new FractionConversionException(value, p2, q2);
             }
 

```

# Math 2


Nb Executed tests: 5195

Nb Failing tests: 1

>	org.apache.commons.math3.distribution.HypergeometricDistributionTest#testMath1021

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/distribution/HypergeometricDistribution.java b/org/apache/commons/math3/distribution/HypergeometricDistribution.java
index 81e180c..2769127 100644
--- a/org/apache/commons/math3/distribution/HypergeometricDistribution.java
+++ b/org/apache/commons/math3/distribution/HypergeometricDistribution.java
@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
-        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
+        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
     }
 
     /**

```

## Genprog 

org.apache.commons.math3.distribution.AbstractIntegerDistribution:138 (Suspicious rank: 22 (Ochiai), 16 (Ample), 16 (Tarantula))
```Java
remove
```

Execution time: 0:07:47.848000

Grid5000 node : graphene-102.nancy.grid5000.fr

## Kali 

org.apache.commons.math3.distribution.AbstractIntegerDistribution:137 (Suspicious rank: 21 (Ochiai), 22 (Ample), 22 (Tarantula))
```Java
remove
```

org.apache.commons.math3.distribution.AbstractIntegerDistribution:138 (Suspicious rank: 22 (Ochiai), 16 (Ample), 16 (Tarantula))
```Java
remove
```

org.apache.commons.math3.distribution.AbstractIntegerDistribution:129 (Suspicious rank: 26 (Ochiai), 24 (Ample), 24 (Tarantula))
```Java
remove
```

Execution time: 0:11:48.689000

Grid5000 node : graphene-74.nancy.grid5000.fr


# Math 3


Nb Executed tests: 5059

Nb Failing tests: 1

>	org.apache.commons.math3.util.MathArraysTest#testLinearCombinationWithSingleElementArray

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/util/MathArrays.java b/org/apache/commons/math3/util/MathArrays.java
index 8f83d96..1aa56cc 100644
--- a/org/apache/commons/math3/util/MathArrays.java
+++ b/org/apache/commons/math3/util/MathArrays.java
@@ -818,11 +818,6 @@ public class MathArrays {
             throw new DimensionMismatchException(len, b.length);
         }
 
-        if (len == 1) {
-            // Revert to scalar multiplication.
-            return a[0] * b[0];
-        }
-
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
 

```

# Math 4


Nb Executed tests: 5014

Nb Failing tests: 2

>	org.apache.commons.math3.geometry.euclidean.threed.SubLineTest#testIntersectionNotIntersecting
>	org.apache.commons.math3.geometry.euclidean.twod.SubLineTest#testIntersectionParallel

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java
index aad7b65..a146cb6 100644
--- a/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java
+++ b/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java
@@ -111,9 +111,6 @@ public class SubLine {
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
-        if (v1D == null) {
-            return null;
-        }
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
diff --git a/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java
index ea9e96a..a9d621a 100644
--- a/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java
+++ b/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java
@@ -115,9 +115,6 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
-        if (v2D == null) {
-            return null;
-        }
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));

```

# Math 5


Nb Executed tests: 4949

Nb Failing tests: 1

>	org.apache.commons.math3.complex.ComplexTest#testReciprocalZero

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/complex/Complex.java b/org/apache/commons/math3/complex/Complex.java
index ac8185b..22b23f2 100644
--- a/org/apache/commons/math3/complex/Complex.java
+++ b/org/apache/commons/math3/complex/Complex.java
@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {
         }
 
         if (real == 0.0 && imaginary == 0.0) {
-            return INF;
+            return NaN;
         }
 
         if (isInfinite) {

```

# Math 6


Nb Executed tests: 4942

Nb Failing tests: 28

>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest#testSumSinc
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest#testMaximize1
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest#testMaximize2
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest#testMinimize1
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest#testMinimize2
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testConstrainedRosen
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testElliRotated
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testEllipse
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testTwoAxes
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testCigar
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testRosen
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testRastrigin
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testDiagonalRosen
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testSsDiffPow
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testMaximize
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testAckley
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testCigTab
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testDiffPow
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testSphere
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testTablet
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest#testCigarWithBoundaries
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest#testMaximize1
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest#testMaximize2
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest#testMinimize1
>	org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest#testMinimize2
>	org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest#testTrivial
>	org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest#testGetIterations
>	org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest#testGetIterations

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optim/BaseOptimizer.java b/org/apache/commons/math3/optim/BaseOptimizer.java
index 927e17f..75c9757 100644
--- a/org/apache/commons/math3/optim/BaseOptimizer.java
+++ b/org/apache/commons/math3/optim/BaseOptimizer.java
@@ -48,7 +48,7 @@ public abstract class BaseOptimizer<PAIR> {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
-        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
+        iterations = new Incrementor(0, new MaxIterCallback());
     }
 
     /**
diff --git a/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java b/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
index bd12b54..e010781 100644
--- a/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
@@ -211,15 +211,16 @@ public class NonLinearConjugateGradientOptimizer
         }
 
         PointValuePair current = null;
+        int iter = 0;
         int maxEval = getMaxEvaluations();
         while (true) {
-            incrementIterationCount();
+            ++iter;
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
-                if (checker.converged(getIterations(), previous, current)) {
+                if (checker.converged(iter, previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -273,7 +274,7 @@ public class NonLinearConjugateGradientOptimizer
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
-            if (getIterations() % n == 0 ||
+            if (iter % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
diff --git a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
index fed67b1..c7216f9 100644
--- a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
@@ -385,8 +385,6 @@ public class CMAESOptimizer
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
-            incrementIterationCount();
-
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
             final RealMatrix arx = zeros(dimension, lambda);
diff --git a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
index afe8d2f..9572820 100644
--- a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
@@ -188,8 +188,9 @@ public class PowellOptimizer
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
+        int iter = 0;
         while (true) {
-            incrementIterationCount();
+            ++iter;
 
             double fX = fVal;
             double fX2 = 0;
@@ -223,7 +224,7 @@ public class PowellOptimizer
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
-                    stop = checker.converged(getIterations(), previous, current);
+                    stop = checker.converged(iter, previous, current);
                 }
             }
             if (stop) {
diff --git a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
index 0dd644e..3d16aa8 100644
--- a/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
@@ -155,7 +155,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
-            if (getIterations() > 0) {
+            if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -171,8 +171,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {
             // We still need to search.
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
-
-            incrementIterationCount();
+            ++iteration;
         }
     }
 
diff --git a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
index 844ed22..a2834f2 100644
--- a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
@@ -103,8 +103,9 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
+        int iter = 0;
         for (boolean converged = false; !converged;) {
-            incrementIterationCount();
+            ++iter;
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -156,7 +157,7 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {
 
             // Check convergence.
             if (previous != null) {
-                converged = checker.converged(getIterations(), previous, current);
+                converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
diff --git a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
index 4016131..ca2d138 100644
--- a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
@@ -319,10 +319,10 @@ public class LevenbergMarquardtOptimizer
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
+        int iter = 0;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
-            incrementIterationCount();
-
+            ++iter;
             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ public class LevenbergMarquardtOptimizer
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
-                        if (checker.converged(getIterations(), previous, current)) {
+                        if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }

```

# Math 7


Nb Executed tests: 4933

Nb Failing tests: 1

>	org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest#testEventsScheduling

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/ode/AbstractIntegrator.java b/org/apache/commons/math3/ode/AbstractIntegrator.java
index 6e0237f..00827db 100644
--- a/org/apache/commons/math3/ode/AbstractIntegrator.java
+++ b/org/apache/commons/math3/ode/AbstractIntegrator.java
@@ -338,15 +338,11 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {
                 interpolator.setSoftPreviousTime(previousT);
                 interpolator.setSoftCurrentTime(eventT);
 
-                // get state at event time
+                // trigger the event
                 interpolator.setInterpolatedTime(eventT);
                 final double[] eventY = interpolator.getInterpolatedState().clone();
-
-                // advance all event states to current time
-                for (final EventState state : eventsStates) {
-                    state.stepAccepted(eventT, eventY);
-                    isLastStep = isLastStep || state.stop();
-                }
+                currentEvent.stepAccepted(eventT, eventY);
+                isLastStep = currentEvent.stop();
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
@@ -356,19 +352,21 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 
-                boolean needReset = false;
-                for (final EventState state : eventsStates) {
-                    needReset =  needReset || state.reset(eventT, eventY);
-                }
-                if (needReset) {
+                if (currentEvent.reset(eventT, eventY)) {
                     // some event handler has triggered changes that
                     // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 

```

# Math 8


Nb Executed tests: 4850

Nb Failing tests: 1

>	org.apache.commons.math3.distribution.DiscreteRealDistributionTest#testIssue942

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/distribution/DiscreteDistribution.java b/org/apache/commons/math3/distribution/DiscreteDistribution.java
index 879eb2a..8c08dbe 100644
--- a/org/apache/commons/math3/distribution/DiscreteDistribution.java
+++ b/org/apache/commons/math3/distribution/DiscreteDistribution.java
@@ -16,9 +16,9 @@
  */
 package org.apache.commons.math3.distribution;
 
+import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.List;
-
 import org.apache.commons.math3.exception.MathArithmeticException;
 import org.apache.commons.math3.exception.MathIllegalArgumentException;
 import org.apache.commons.math3.exception.NotPositiveException;
@@ -178,13 +178,13 @@ public class DiscreteDistribution<T> {
      * @throws NotStrictlyPositiveException if {@code sampleSize} is not
      * positive.
      */
-    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
+    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
-
-        final Object[] out = new Object[sampleSize];
+        @SuppressWarnings("unchecked")
+        final T[]out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();

```

## Genprog 

org.apache.commons.math3.distribution.DiscreteDistribution:190 (Suspicious rank: 4 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
remove
```

Execution time: 0:18:52.555000

Grid5000 node : griffon-1.nancy.grid5000.fr

## Kali 

org.apache.commons.math3.distribution.DiscreteDistribution:189 (Suspicious rank: 3 (Ochiai), 4 (Ample), 4 (Tarantula))
```Java
remove
```

org.apache.commons.math3.distribution.DiscreteDistribution:190 (Suspicious rank: 4 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
remove
```

Execution time: 0:23:13.326000

Grid5000 node : griffon-39.nancy.grid5000.fr


# Math 9


Nb Executed tests: 4826

Nb Failing tests: 1

>	org.apache.commons.math3.geometry.euclidean.threed.LineTest#testRevert

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/geometry/euclidean/threed/Line.java b/org/apache/commons/math3/geometry/euclidean/threed/Line.java
index 7c9a28f..0c39411 100644
--- a/org/apache/commons/math3/geometry/euclidean/threed/Line.java
+++ b/org/apache/commons/math3/geometry/euclidean/threed/Line.java
@@ -84,9 +84,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {
      * @return a new instance, with reversed direction
      */
     public Line revert() {
-        final Line reverted = new Line(this);
-        reverted.direction = reverted.direction.negate();
-        return reverted;
+        return new Line(zero, zero.subtract(direction));
     }
 
     /** Get the normalized direction vector.

```

# Math 10


Nb Executed tests: 4582

Nb Failing tests: 1

>	org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest#testAtan2SpecialCases

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/analysis/differentiation/DSCompiler.java b/org/apache/commons/math3/analysis/differentiation/DSCompiler.java
index d5a3c18..9d08555 100644
--- a/org/apache/commons/math3/analysis/differentiation/DSCompiler.java
+++ b/org/apache/commons/math3/analysis/differentiation/DSCompiler.java
@@ -1415,9 +1415,6 @@ public class DSCompiler {
 
         }
 
-        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
-        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
-
     }
 
     /** Compute hyperbolic cosine of a derivative structure.

```

# Math 11


Nb Executed tests: 4560

Nb Failing tests: 1

>	org.apache.commons.math3.distribution.MultivariateNormalDistributionTest#testUnivariateDistribution

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java
index fd18c28..1570681 100644
--- a/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java
+++ b/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java
@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution
             throw new DimensionMismatchException(vals.length, dim);
         }
 
-        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
+        return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }

```

# Math 12


Nb Executed tests: 4546

Nb Failing tests: 4

>	org.apache.commons.math3.distribution.LogNormalDistributionTest#testDistributionClone
>	org.apache.commons.math3.distribution.NormalDistributionTest#testDistributionClone
>	org.apache.commons.math3.distribution.GammaDistributionTest#testDistributionClone
>	org.apache.commons.math3.random.EmpiricalDistributionTest#testDistributionClone

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/random/BitsStreamGenerator.java b/org/apache/commons/math3/random/BitsStreamGenerator.java
index fab295b..a621d7b 100644
--- a/org/apache/commons/math3/random/BitsStreamGenerator.java
+++ b/org/apache/commons/math3/random/BitsStreamGenerator.java
@@ -16,26 +16,21 @@
  */
 package org.apache.commons.math3.random;
 
-import java.io.Serializable;
-
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;
 
 /** Base class for random number generators that generates bits streams.
- *
+
  * @version $Id$
  * @since 2.0
+
  */
-public abstract class BitsStreamGenerator
-    implements RandomGenerator,
-               Serializable {
-    /** Serializable version identifier */
-    private static final long serialVersionUID = 20130104L;
+public abstract class BitsStreamGenerator implements RandomGenerator {
+
     /** Next gaussian. */
     private double nextGaussian;
 
-    /**
-     * Creates a new random number generator.
+    /** Creates a new random number generator.
      */
     public BitsStreamGenerator() {
         nextGaussian = Double.NaN;

```

# Math 13


Nb Executed tests: 4534

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.fitting.PolynomialFitterTest#testLargeSample

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/Weight.java b/org/apache/commons/math3/optimization/Weight.java
index 28c1619..8e7538f 100644
--- a/org/apache/commons/math3/optimization/Weight.java
+++ b/org/apache/commons/math3/optimization/Weight.java
@@ -18,7 +18,7 @@
 package org.apache.commons.math3.optimization;
 
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.linear.DiagonalMatrix;
+import org.apache.commons.math3.linear.Array2DRowRealMatrix;
 import org.apache.commons.math3.linear.NonSquareMatrixException;
 
 /**
@@ -41,7 +41,11 @@ public class Weight implements OptimizationData {
      * @param weight List of the values of the diagonal.
      */
     public Weight(double[] weight) {
-        weightMatrix = new DiagonalMatrix(weight);
+        final int dim = weight.length;
+        weightMatrix = new Array2DRowRealMatrix(dim, dim);
+        for (int i = 0; i < dim; i++) {
+            weightMatrix.setEntry(i, i, weight[i]);
+        }
     }
 
     /**
diff --git a/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java
index 982e559..b6c97e7 100644
--- a/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java
+++ b/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java
@@ -559,16 +558,7 @@ public abstract class AbstractLeastSquaresOptimizer
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
-        if (m instanceof DiagonalMatrix) {
-            final int dim = m.getRowDimension();
-            final RealMatrix sqrtM = new DiagonalMatrix(dim);
-            for (int i = 0; i < dim; i++) {
-               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
-            }
-            return sqrtM;
-        } else {
-            final EigenDecomposition dec = new EigenDecomposition(m);
-            return dec.getSquareRoot();
-        }
+        final EigenDecomposition dec = new EigenDecomposition(m);
+        return dec.getSquareRoot();
     }
 }

```

# Math 14


Nb Executed tests: 4533

Nb Failing tests: 1

>	org.apache.commons.math3.fitting.PolynomialFitterTest#testLargeSample

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optim/nonlinear/vector/Weight.java b/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
index aa3299a..789bc25 100644
--- a/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
+++ b/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
@@ -18,7 +18,7 @@ package org.apache.commons.math3.optim.nonlinear.vector;
 
 import org.apache.commons.math3.optim.OptimizationData;
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.linear.DiagonalMatrix;
+import org.apache.commons.math3.linear.MatrixUtils;
 import org.apache.commons.math3.linear.NonSquareMatrixException;
 
 /**
@@ -40,7 +40,10 @@ public class Weight implements OptimizationData {
      */
     public Weight(double[] weight) {
         final int dim = weight.length;
-        weightMatrix = new DiagonalMatrix(weight);
+        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);
+        for (int i = 0; i < dim; i++) {
+            weightMatrix.setEntry(i, i, weight[i]);
+        }
     }
 
     /**
diff --git a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
index ef52943..b7bb6f5 100644
--- a/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
+++ b/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
@@ -264,16 +263,7 @@ public abstract class AbstractLeastSquaresOptimizer
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
-        if (m instanceof DiagonalMatrix) {
-            final int dim = m.getRowDimension();
-            final RealMatrix sqrtM = new DiagonalMatrix(dim);
-            for (int i = 0; i < dim; i++) {
-                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
-            }
-            return sqrtM;
-        } else {
-            final EigenDecomposition dec = new EigenDecomposition(m);
-            return dec.getSquareRoot();
-        }
+        final EigenDecomposition dec = new EigenDecomposition(m);
+        return dec.getSquareRoot();
     }
 }

```

# Math 15


Nb Executed tests: 4263

Nb Failing tests: 1

>	org.apache.commons.math3.util.FastMathTest#testMath904

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/util/FastMath.java b/org/apache/commons/math3/util/FastMath.java
index 9dc84c6..fd1ce2d 100644
--- a/org/apache/commons/math3/util/FastMath.java
+++ b/org/apache/commons/math3/util/FastMath.java
@@ -309,8 +309,6 @@ public class FastMath {
 
     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
     private static final double TWO_POWER_52 = 4503599627370496.0;
-    /** 2^53 - double numbers this large must be even. */
-    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
 
     /** Constant: {@value}. */
     private static final double F_1_3 = 1d / 3d;
@@ -1539,7 +1537,7 @@ public class FastMath {
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
-            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
+            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 

```

# Math 16


Nb Executed tests: 4261

Nb Failing tests: 2

>	org.apache.commons.math3.util.FastMathTest#testMath905LargePositive
>	org.apache.commons.math3.util.FastMathTest#testMath905LargeNegative

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/util/FastMath.java b/org/apache/commons/math3/util/FastMath.java
index fd1ce2d..22ed157 100644
--- a/org/apache/commons/math3/util/FastMath.java
+++ b/org/apache/commons/math3/util/FastMath.java
@@ -78,8 +78,6 @@ import java.io.PrintStream;
  * @since 2.2
  */
 public class FastMath {
-    /** StrictMath.log(Double.MAX_VALUE): {@value} */
-    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -391,25 +389,15 @@ public class FastMath {
       // for numbers with magnitude 20 or so,
       // exp(-z) can be ignored in comparison with exp(z)
 
-      if (x > 20) {
-          if (x >= LOG_MAX_VALUE) {
-              // Avoid overflow (MATH-905).
-              final double t = exp(0.5 * x);
-              return (0.5 * t) * t;
-          } else {
-              return 0.5 * exp(x);
-          }
-      } else if (x < -20) {
-          if (x <= -LOG_MAX_VALUE) {
-              // Avoid overflow (MATH-905).
-              final double t = exp(-0.5 * x);
-              return (0.5 * t) * t;
-          } else {
-              return 0.5 * exp(-x);
-          }
+      if (x > 20.0) {
+          return exp(x)/2.0;
+      }
+
+      if (x < -20) {
+          return exp(-x)/2.0;
       }
 
-      final double hiPrec[] = new double[2];
+      double hiPrec[] = new double[2];
       if (x < 0.0) {
           x = -x;
       }
@@ -461,22 +449,12 @@ public class FastMath {
       // for values of z larger than about 20,
       // exp(-z) can be ignored in comparison with exp(z)
 
-      if (x > 20) {
-          if (x >= LOG_MAX_VALUE) {
-              // Avoid overflow (MATH-905).
-              final double t = exp(0.5 * x);
-              return (0.5 * t) * t;
-          } else {
-              return 0.5 * exp(x);
-          }
-      } else if (x < -20) {
-          if (x <= -LOG_MAX_VALUE) {
-              // Avoid overflow (MATH-905).
-              final double t = exp(-0.5 * x);
-              return (-0.5 * t) * t;
-          } else {
-              return -0.5 * exp(-x);
-          }
+      if (x > 20.0) {
+          return exp(x)/2.0;
+      }
+
+      if (x < -20) {
+          return -exp(-x)/2.0;
       }
 
       if (x == 0) {

```

# Math 17


Nb Executed tests: 4176

Nb Failing tests: 1

>	org.apache.commons.math3.dfp.DfpTest#testMultiply

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/dfp/Dfp.java b/org/apache/commons/math3/dfp/Dfp.java
index 3a91982..d278a31 100644
--- a/org/apache/commons/math3/dfp/Dfp.java
+++ b/org/apache/commons/math3/dfp/Dfp.java
@@ -1595,24 +1595,12 @@ public class Dfp implements FieldElement<Dfp> {
 
     }
 
-    /** Multiply this by a single digit x.
-     * @param x multiplicand
-     * @return product of this and x
-     */
-    public Dfp multiply(final int x) {
-        if (x >= 0 && x < RADIX) {
-            return multiplyFast(x);
-        } else {
-            return multiply(newInstance(x));
-        }
-    }
-
     /** Multiply this by a single digit 0&lt;=x&lt;radix.
-     * There are speed advantages in this special case.
+     * There are speed advantages in this special case
      * @param x multiplicand
      * @return product of this and x
      */
-    private Dfp multiplyFast(final int x) {
+    public Dfp multiply(final int x) {
         Dfp result = newInstance(this);
 
         /* handle special cases */

```

# Math 18


Nb Executed tests: 4171

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.direct.CMAESOptimizerTest#testFitAccuracyDependsOnBoundary

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
index 866c8fd..f6a4f28 100644
--- a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
+++ b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
@@ -585,8 +585,8 @@ public class CMAESOptimizer
         // initialize sigma
         double[][] sigmaArray = new double[guess.length][1];
         for (int i = 0; i < guess.length; i++) {
-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];
-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;
+            final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];
+            sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;
         }
         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);
         sigma = max(insigma); // overall standard deviation
@@ -929,7 +929,7 @@ public class CMAESOptimizer
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
-                res[i] = x[i] / diff;
+                res[i] = (x[i] - boundaries[0][i]) / diff;
             }
             return res;
         }
@@ -955,7 +955,7 @@ public class CMAESOptimizer
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
-                res[i] = diff * x[i];
+                res[i] = diff * x[i] + boundaries[0][i];
             }
             return res;
         }
@@ -986,15 +986,11 @@ public class CMAESOptimizer
             if (boundaries == null) {
                 return true;
             }
-
-            final double[] bLoEnc = encode(boundaries[0]);
-            final double[] bHiEnc = encode(boundaries[1]);
-
             for (int i = 0; i < x.length; i++) {
-                if (x[i] < bLoEnc[i]) {
+                if (x[i] < 0) {
                     return false;
                 }
-                if (x[i] > bHiEnc[i]) {
+                if (x[i] > 1.0) {
                     return false;
                 }
             }

```

# Math 19


Nb Executed tests: 4165

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.direct.CMAESOptimizerTest#testBoundaryRangeTooLarge

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
index f6a4f28..b54cb37 100644
--- a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
+++ b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
@@ -24,8 +24,8 @@ import java.util.List;
 import org.apache.commons.math3.analysis.MultivariateFunction;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathUnsupportedOperationException;
+import org.apache.commons.math3.exception.MathIllegalStateException;
 import org.apache.commons.math3.exception.NotPositiveException;
-import org.apache.commons.math3.exception.NumberIsTooLargeException;
 import org.apache.commons.math3.exception.OutOfRangeException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.exception.util.LocalizedFormats;
@@ -535,21 +529,6 @@ public class CMAESOptimizer
                 boundaries = new double[2][];
                 boundaries[0] = lB;
                 boundaries[1] = uB;
-
-                // Abort early if the normalization will overflow (cf. "encode" method).
-                for (int i = 0; i < lB.length; i++) {
-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
-                        final double max = Double.MAX_VALUE + boundaries[0][i];
-                        final NumberIsTooLargeException e
-                            = new NumberIsTooLargeException(boundaries[1][i],
-                                                            max,
-                                                            true);
-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
-
-                        throw e;
-                    }
-                }
             }
         } else {
             // Convert API to internal handling of boundaries.

```

# Math 20


Nb Executed tests: 4164

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.direct.CMAESOptimizerTest#testMath864

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
index b54cb37..d01cd15 100644
--- a/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
+++ b/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
@@ -416,7 +414,7 @@ public class CMAESOptimizer
                     bestValue = bestFitness;
                     lastResult = optimum;
                     optimum = new PointValuePair(
-                            fitfun.repairAndDecode(bestArx.getColumn(0)),
+                            fitfun.decode(bestArx.getColumn(0)),
                             isMinimize ? bestFitness : -bestFitness);
                     if (getConvergenceChecker() != null && lastResult != null) {
                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
@@ -915,16 +913,6 @@ public class CMAESOptimizer
 
         /**
          * @param x Normalized objective variables.
-         * @return the original objective variables, possibly repaired.
-         */
-        public double[] repairAndDecode(final double[] x) {
-            return boundaries != null && isRepairMode ?
-                decode(repair(x)) :
-                decode(x);
-        }
-
-        /**
-         * @param x Normalized objective variables.
          * @return the original objective variables.
          */
         public double[] decode(final double[] x) {

```

# Math 21


Nb Executed tests: 4126

Nb Failing tests: 3

>	org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest#testMath789
>	org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest#testFullRank
>	org.apache.commons.math3.random.CorrelatedRandomVectorGeneratorTest#testSampleWithZeroCovariance

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
index aba7b98..38584d4 100644
--- a/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
+++ b/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
@@ -62,10 +62,11 @@ public class RectangularCholeskyDecomposition {
     public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         throws NonPositiveDefiniteMatrixException {
 
-        final int order = matrix.getRowDimension();
-        final double[][] c = matrix.getData();
-        final double[][] b = new double[order][order];
+        int order = matrix.getRowDimension();
+        double[][] c = matrix.getData();
+        double[][] b = new double[order][order];
 
+        int[] swap  = new int[order];
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;
@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {
         for (boolean loop = true; loop;) {
 
             // find maximal diagonal element
-            int swapR = r;
+            swap[r] = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
-                int isr = index[swapR];
-                if (c[ii][ii] > c[isr][isr]) {
-                    swapR = i;
+                int isi = index[swap[i]];
+                if (c[ii][ii] > c[isi][isi]) {
+                    swap[r] = i;
                 }
             }
 
 
             // swap elements
-            if (swapR != r) {
-                final int tmpIndex    = index[r];
-                index[r]              = index[swapR];
-                index[swapR]          = tmpIndex;
-                final double[] tmpRow = b[r];
-                b[r]                  = b[swapR];
-                b[swapR]              = tmpRow;
+            if (swap[r] != r) {
+                int tmp = index[r];
+                index[r] = index[swap[r]];
+                index[swap[r]] = tmp;
             }
 
             // check diagonal element
@@ -120,18 +118,17 @@ public class RectangularCholeskyDecomposition {
             } else {
 
                 // transform the matrix
-                final double sqrt = FastMath.sqrt(c[ir][ir]);
+                double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
-                final double inverse  = 1 / sqrt;
-                final double inverse2 = 1 / c[ir][ir];
+                double inverse = 1 / sqrt;
                 for (int i = r + 1; i < order; ++i) {
-                    final int ii = index[i];
-                    final double e = inverse * c[ii][ir];
+                    int ii = index[i];
+                    double e = inverse * c[ii][ir];
                     b[i][r] = e;
-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;
+                    c[ii][ii] -= e * e;
                     for (int j = r + 1; j < i; ++j) {
-                        final int ij = index[j];
-                        final double f = c[ii][ij] - e * b[j][r];
+                        int ij = index[j];
+                        double f = c[ii][ij] - e * b[j][r];
                         c[ii][ij] = f;
                         c[ij][ii] = f;
                     }

```

# Math 22


Nb Executed tests: 4118

Nb Failing tests: 2

>	org.apache.commons.math3.distribution.UniformRealDistributionTest#testIsSupportUpperBoundInclusive
>	org.apache.commons.math3.distribution.FDistributionTest#testIsSupportLowerBoundInclusive

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/distribution/FDistribution.java b/org/apache/commons/math3/distribution/FDistribution.java
index e301e2e..8b0993c 100644
--- a/org/apache/commons/math3/distribution/FDistribution.java
+++ b/org/apache/commons/math3/distribution/FDistribution.java
@@ -272,7 +272,7 @@ public class FDistribution extends AbstractRealDistribution {
 
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
-        return false;
+        return true;
     }
 
     /** {@inheritDoc} */
diff --git a/org/apache/commons/math3/distribution/UniformRealDistribution.java b/org/apache/commons/math3/distribution/UniformRealDistribution.java
index 0d279de..5d32f6e 100644
--- a/org/apache/commons/math3/distribution/UniformRealDistribution.java
+++ b/org/apache/commons/math3/distribution/UniformRealDistribution.java
@@ -181,7 +181,7 @@ public class UniformRealDistribution extends AbstractRealDistribution {
 
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
-        return true;
+        return false;
     }
 
     /**

```

# Math 23


Nb Executed tests: 4096

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.univariate.BrentOptimizerTest#testKeepInitIfBest

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
index 25f2f50..cff5bfd 100644
--- a/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
+++ b/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
@@ -147,8 +141,6 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
         UnivariatePointValuePair previous = null;
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
-        // Best point encountered so far (which is the initial guess).
-        UnivariatePointValuePair best = current;
 
         int iter = 0;
         while (true) {
@@ -232,15 +224,10 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
                 // User-defined convergence checker.
                 previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
-                best = best(best,
-                            best(current,
-                                 previous,
-                                 isMinim),
-                            isMinim);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
-                        return best;
+                        return best(current, previous, isMinim);
                     }
                 }
 
@@ -277,11 +264,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
                     }
                 }
             } else { // Default termination (Brent's criterion).
-                return best(best,
-                            best(current,
-                                 previous,
-                                 isMinim),
-                            isMinim);
+                return best(current, previous, isMinim);
             }
             ++iter;
         }
@@ -309,9 +291,9 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
         }
 
         if (isMinim) {
-            return a.getValue() <= b.getValue() ? a : b;
+            return a.getValue() < b.getValue() ? a : b;
         } else {
-            return a.getValue() >= b.getValue() ? a : b;
+            return a.getValue() > b.getValue() ? a : b;
         }
     }
 }

```

# Math 24


Nb Executed tests: 4095

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.univariate.BrentOptimizerTest#testMath855

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
index cff5bfd..ee2227c 100644
--- a/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
+++ b/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
@@ -227,7 +226,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
-                        return best(current, previous, isMinim);
+                        return current;
                     }
                 }
 
@@ -264,36 +263,9 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {
                     }
                 }
             } else { // Default termination (Brent's criterion).
-                return best(current, previous, isMinim);
+                return current;
             }
             ++iter;
         }
     }
-
-    /**
-     * Selects the best of two points.
-     *
-     * @param a Point and value.
-     * @param b Point and value.
-     * @param isMinim {@code true} if the selected point must be the one with
-     * the lowest value.
-     * @return the best point, or {@code null} if {@code a} and {@code b} are
-     * both {@code null}.
-     */
-    private UnivariatePointValuePair best(UnivariatePointValuePair a,
-                                          UnivariatePointValuePair b,
-                                          boolean isMinim) {
-        if (a == null) {
-            return b;
-        }
-        if (b == null) {
-            return a;
-        }
-
-        if (isMinim) {
-            return a.getValue() < b.getValue() ? a : b;
-        } else {
-            return a.getValue() > b.getValue() ? a : b;
-        }
-    }
 }

```

# Math 25


Nb Executed tests: 4061

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.fitting.HarmonicFitterTest#testMath844

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/exception/util/LocalizedFormats.java b/org/apache/commons/math3/exception/util/LocalizedFormats.java
index 04edd0b..1ca5635 100644
--- a/org/apache/commons/math3/exception/util/LocalizedFormats.java
+++ b/org/apache/commons/math3/exception/util/LocalizedFormats.java
@@ -344,7 +344,7 @@ public enum LocalizedFormats implements Localizable {
     WRONG_BLOCK_LENGTH("wrong array shape (block length = {0}, expected {1})"),
     WRONG_NUMBER_OF_POINTS("{0} points are required, got only {1}"),
     NUMBER_OF_POINTS("number of points ({0})"), /* keep */
-    ZERO_DENOMINATOR("denominator must be different from 0"), /* keep */
+    ZERO_DENOMINATOR("denominator must be different from 0"),
     ZERO_DENOMINATOR_IN_FRACTION("zero denominator in fraction {0}/{1}"),
     ZERO_FRACTION_TO_DIVIDE_BY("the fraction to divide by must not be zero: {0}/{1}"),
     ZERO_NORM("zero norm"),
diff --git a/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java
index c7af9ae..ebb36d3 100644
--- a/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java
+++ b/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java
@@ -320,12 +317,6 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
-                if (c2 == 0) {
-                    // In some ill-conditioned cases (cf. MATH-844), the guesser
-                    // procedure cannot produce sensible results.
-                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
-                }
-
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
             }

```

# Math 26


Nb Executed tests: 3982

Nb Failing tests: 1

>	org.apache.commons.math3.fraction.FractionTest#testIntegerOverflow

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/fraction/Fraction.java b/org/apache/commons/math3/fraction/Fraction.java
index 08d3b95..f81ff0a 100644
--- a/org/apache/commons/math3/fraction/Fraction.java
+++ b/org/apache/commons/math3/fraction/Fraction.java
@@ -178,7 +178,7 @@ public class Fraction
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
-        if (FastMath.abs(a0) > overflow) {
+        if (a0 > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 
@@ -206,7 +206,7 @@ public class Fraction
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
-            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
+            if ((p2 > overflow) || (q2 > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 

```

# Math 27


Nb Executed tests: 3982

Nb Failing tests: 1

>	org.apache.commons.math3.fraction.FractionTest#testMath835

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/fraction/Fraction.java b/org/apache/commons/math3/fraction/Fraction.java
index f81ff0a..f84218e 100644
--- a/org/apache/commons/math3/fraction/Fraction.java
+++ b/org/apache/commons/math3/fraction/Fraction.java
@@ -594,7 +594,7 @@ public class Fraction
      * @return the fraction percentage as a <tt>double</tt>.
      */
     public double percentageValue() {
-        return 100 * doubleValue();
+        return multiply(100).doubleValue();
     }
 
     /**

```

# Math 28


Nb Executed tests: 3981

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.linear.SimplexSolverTest#testMath828Cycle

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/org/apache/commons/math3/optimization/linear/SimplexSolver.java
index dec310b..c2fa14d 100644
--- a/org/apache/commons/math3/optimization/linear/SimplexSolver.java
+++ b/org/apache/commons/math3/optimization/linear/SimplexSolver.java
@@ -116,14 +116,12 @@ public class SimplexSolver extends AbstractLinearOptimizer {
             // there's a degeneracy as indicated by a tie in the minimum ratio test
 
             // 1. check if there's an artificial variable that can be forced out of the basis
-            if (tableau.getNumArtificialVariables() > 0) {
-                for (Integer row : minRatioPositions) {
-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
-                        int column = i + tableau.getArtificialVariableOffset();
-                        final double entry = tableau.getEntry(row, column);
-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
-                            return row;
-                        }
+            for (Integer row : minRatioPositions) {
+                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
+                    int column = i + tableau.getArtificialVariableOffset();
+                    final double entry = tableau.getEntry(row, column);
+                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
+                        return row;
                     }
                 }
             }
@@ -133,26 +131,20 @@ public class SimplexSolver extends AbstractLinearOptimizer {
             //
             // see http://www.stanford.edu/class/msande310/blandrule.pdf
             // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
-            //
-            // Additional heuristic: if we did not get a solution after half of maxIterations
-            //                       revert to the simple case of just returning the top-most row
-            // This heuristic is based on empirical data gathered while investigating MATH-828.
-            if (getIterations() < getMaxIterations() / 2) {
-                Integer minRow = null;
-                int minIndex = tableau.getWidth();
-                for (Integer row : minRatioPositions) {
-                    int i = tableau.getNumObjectiveFunctions();
-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
-                        if (row == tableau.getBasicRow(i)) {
-                            if (i < minIndex) {
-                                minIndex = i;
-                                minRow = row;
-                            }
+            Integer minRow = null;
+            int minIndex = tableau.getWidth();
+            for (Integer row : minRatioPositions) {
+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {
+                    if (row == tableau.getBasicRow(i)) {
+                        if (i < minIndex) {
+                            minIndex = i;
+                            minRow = row;
                         }
                     }
                 }
-                return minRow;
             }
+
+            return minRow;
         }
         return minRatioPositions.get(0);
     }

```

# Math 29


Nb Executed tests: 3761

Nb Failing tests: 3

>	org.apache.commons.math3.linear.SparseRealVectorTest#testEbeDivideMixedTypes
>	org.apache.commons.math3.linear.SparseRealVectorTest#testEbeMultiplyMixedTypes
>	org.apache.commons.math3.linear.SparseRealVectorTest#testEbeMultiplySameType

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/linear/OpenMapRealVector.java b/org/apache/commons/math3/linear/OpenMapRealVector.java
index 294ac57..2ca3447 100644
--- a/org/apache/commons/math3/linear/OpenMapRealVector.java
+++ b/org/apache/commons/math3/linear/OpenMapRealVector.java
@@ -341,14 +341,10 @@ public class OpenMapRealVector extends SparseRealVector
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
-        /*
-         * MATH-803: it is not sufficient to loop through non zero entries of
-         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
-         * this[i] / v[i] = NaN, and not 0d.
-         */
-        final int n = getDimension();
-        for (int i = 0; i < n; i++) {
-            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            iter.advance();
+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
         }
         return res;
     }
@@ -363,25 +359,6 @@ public class OpenMapRealVector extends SparseRealVector
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
         }
-        /*
-         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
-         * which allows to consider only the non-zero entries of this. However,
-         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
-         *
-         * These special cases are handled below.
-         */
-        if (v.isNaN() || v.isInfinite()) {
-            final int n = getDimension();
-            for (int i = 0; i < n; i++) {
-                final double y = v.getEntry(i);
-                if (Double.isNaN(y)) {
-                    res.setEntry(i, Double.NaN);
-                } else if (Double.isInfinite(y)) {
-                    final double x = this.getEntry(i);
-                    res.setEntry(i, x * y);
-                }
-            }
-        }
         return res;
     }
 

```

# Math 30


Nb Executed tests: 3717

Nb Failing tests: 1

>	org.apache.commons.math3.stat.inference.MannWhitneyUTestTest#testBigDataSet

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java
index a161737..a4acf2f 100644
--- a/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java
+++ b/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java
@@ -170,11 +170,11 @@ public class MannWhitneyUTest {
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
-        final double n1n2prod = n1 * n2;
+        final int n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
-        final double EU = n1n2prod / 2.0;
-        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;
+        final double EU = (double) n1n2prod / 2.0;
+        final double VarU = (double) (n1n2prod * (n1 + n2 + 1)) / 12.0;
 
         final double z = (Umin - EU) / FastMath.sqrt(VarU);
 

```

# Math 31


Nb Executed tests: 3602

Nb Failing tests: 2

>	org.apache.commons.math3.distribution.BinomialDistributionTest#testMath718
>	org.apache.commons.math3.distribution.FDistributionTest#testMath785

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/util/ContinuedFraction.java b/org/apache/commons/math3/util/ContinuedFraction.java
index 253f3c5..35fe916 100644
--- a/org/apache/commons/math3/util/ContinuedFraction.java
+++ b/org/apache/commons/math3/util/ContinuedFraction.java
@@ -121,53 +122,72 @@ public abstract class ContinuedFraction {
      * @throws ConvergenceException if the algorithm fails to converge.
      */
     public double evaluate(double x, double epsilon, int maxIterations) {
-        final double small = 1e-50;
-        double hPrev = getA(0, x);
-
-        // use the value of small as epsilon criteria for zero checks
-        if (Precision.equals(hPrev, 0.0, small)) {
-            hPrev = small;
-        }
-
-        int n = 1;
-        double dPrev = 0.0;
-        double cPrev = hPrev;
-        double hN = hPrev;
-
-        while (n < maxIterations) {
-            final double a = getA(n, x);
-            final double b = getB(n, x);
-
-            double dN = a + b * dPrev;
-            if (Precision.equals(dN, 0.0, small)) {
-                dN = small;
+        double p0 = 1.0;
+        double p1 = getA(0, x);
+        double q0 = 0.0;
+        double q1 = 1.0;
+        double c = p1 / q1;
+        int n = 0;
+        double relativeError = Double.MAX_VALUE;
+        while (n < maxIterations && relativeError > epsilon) {
+            ++n;
+            double a = getA(n, x);
+            double b = getB(n, x);
+            double p2 = a * p1 + b * p0;
+            double q2 = a * q1 + b * q0;
+            boolean infinite = false;
+            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
+                /*
+                 * Need to scale. Try successive powers of the larger of a or b
+                 * up to 5th power. Throw ConvergenceException if one or both
+                 * of p2, q2 still overflow.
+                 */
+                double scaleFactor = 1d;
+                double lastScaleFactor = 1d;
+                final int maxPower = 5;
+                final double scale = FastMath.max(a,b);
+                if (scale <= 0) {  // Can't scale
+                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
+                                                   x);
+                }
+                infinite = true;
+                for (int i = 0; i < maxPower; i++) {
+                    lastScaleFactor = scaleFactor;
+                    scaleFactor *= scale;
+                    if (a != 0.0 && a > b) {
+                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);
+                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);
+                    } else if (b != 0) {
+                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;
+                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;
+                    }
+                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);
+                    if (!infinite) {
+                        break;
+                    }
+                }
             }
-            double cN = a + b / cPrev;
-            if (Precision.equals(cN, 0.0, small)) {
-                cN = small;
+
+            if (infinite) {
+               // Scaling failed
+               throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
+                                              x);
             }
 
-            dN = 1 / dN;
-            final double deltaN = cN * dN;
-            hN = hPrev * deltaN;
+            double r = p2 / q2;
 
-            if (Double.isInfinite(hN)) {
-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
-                                               x);
-            }
-            if (Double.isNaN(hN)) {
+            if (Double.isNaN(r)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
                                                x);
             }
-
-            if (FastMath.abs(deltaN - 1.0) < epsilon) {
-                break;
-            }
-
-            dPrev = dN;
-            cPrev = cN;
-            hPrev = hN;
-            n++;
+            relativeError = FastMath.abs(r / c - 1.0);
+
+            // prepare for next iteration
+            c = p2 / q2;
+            p0 = p1;
+            p1 = p2;
+            q0 = q1;
+            q1 = q2;
         }
 
         if (n >= maxIterations) {
@@ -175,7 +195,6 @@ public abstract class ContinuedFraction {
                                                 maxIterations, x);
         }
 
-        return hN;
+        return c;
     }
-
 }

```

# Math 32


Nb Executed tests: 3593

Nb Failing tests: 1

>	org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest#testIssue780

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java
index add24ac..6ba72be 100644
--- a/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java
+++ b/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java
@@ -132,9 +132,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {
         final Vector2D[][] v = getVertices();
 
         if (v.length == 0) {
-            final BSPTree<Euclidean2D> tree = getTree(false);
-            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
-                // the instance covers the whole space
+            if ((Boolean) getTree(false).getAttribute()) {
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
             } else {

```

## NopolPC 

org.apache.commons.math3.geometry.partitioning.AbstractRegion:214 (Suspicious rank: 221 (Ochiai), 190 (Ample), 190 (Tarantula))
```Java
((!(((boundary.size())-(plusList.size()))<(minusList.size())))&&((1)<=(plusList.size())))||((minusList.size())==((boundary.size())+(-1)))
```

Nb Angelic value: 1

Nb analyzed Statement: 221

Execution time: 0:16:53.994000

Grid5000 node: chimint-14.lille.grid5000.fr


# Math 33


Nb Executed tests: 3575

Nb Failing tests: 1

>	org.apache.commons.math3.optimization.linear.SimplexSolverTest#testMath781

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/org/apache/commons/math3/optimization/linear/SimplexTableau.java
index 327b2ae..9a6993a 100644
--- a/org/apache/commons/math3/optimization/linear/SimplexTableau.java
+++ b/org/apache/commons/math3/optimization/linear/SimplexTableau.java
@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
-            if (Precision.compareTo(entry, 0d, epsilon) > 0) {
+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }

```

## NopolPC 

org.apache.commons.math3.optimization.linear.SimplexTableau:339 (Suspicious rank: 6 (Ochiai), 4 (Ample), 4 (Tarantula))
```Java
(org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size())!=(org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables)
```

Nb Angelic value: 1

Nb analyzed Statement: 6

Execution time: 0:12:40.949000

Grid5000 node: chinqchint-24.lille.grid5000.fr


## NopolC 

org.apache.commons.math3.optimization.linear.SimplexTableau:338 (Suspicious rank: 22 (Ochiai), 17 (Ample), 17 (Tarantula))
```Java
!(((org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables)==(org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()))||((entry)<=(0)))
```

Nb Angelic value: 1

Nb analyzed Statement: 22

Execution time: 0:15:43.998000

Grid5000 node: chimint-15.lille.grid5000.fr


# Math 34


Nb Executed tests: 3559

Nb Failing tests: 1

>	org.apache.commons.math3.genetics.ListPopulationTest#testIterator

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/genetics/ListPopulation.java b/org/apache/commons/math3/genetics/ListPopulation.java
index 3f3919c..8fe3ffe 100644
--- a/org/apache/commons/math3/genetics/ListPopulation.java
+++ b/org/apache/commons/math3/genetics/ListPopulation.java
@@ -200,12 +200,11 @@ public abstract class ListPopulation implements Population {
     }
 
     /**
-     * Returns an iterator over the unmodifiable list of chromosomes.
-     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
+     * Chromosome list iterator
      *
      * @return chromosome iterator
      */
     public Iterator<Chromosome> iterator() {
-        return getChromosomes().iterator();
+        return chromosomes.iterator();
     }
 }

```

# Math 35


Nb Executed tests: 3550

Nb Failing tests: 4

>	org.apache.commons.math3.genetics.ElitisticListPopulationTest#testChromosomeListConstructorTooLow
>	org.apache.commons.math3.genetics.ElitisticListPopulationTest#testConstructorTooHigh
>	org.apache.commons.math3.genetics.ElitisticListPopulationTest#testConstructorTooLow
>	org.apache.commons.math3.genetics.ElitisticListPopulationTest#testChromosomeListConstructorTooHigh

## Human Patch 

```Java
diff --git a/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/org/apache/commons/math3/genetics/ElitisticListPopulation.java
index 829c97d..a309080 100644
--- a/org/apache/commons/math3/genetics/ElitisticListPopulation.java
+++ b/org/apache/commons/math3/genetics/ElitisticListPopulation.java
@@ -42,13 +42,12 @@ public class ElitisticListPopulation extends ListPopulation {
      * @param populationLimit maximal size of the population
      * @param elitismRate how many best chromosomes will be directly transferred to the
      *                    next generation [in %]
-     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range
      */
     public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
-        setElitismRate(elitismRate);
+        this.elitismRate = elitismRate;
     }
 
     /**
@@ -58,11 +57,10 @@ public class ElitisticListPopulation extends ListPopulation {
      * @param populationLimit maximal size of the population
      * @param elitismRate how many best chromosomes will be directly transferred to the
      *                    next generation [in %]
-     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range
      */
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
-        setElitismRate(elitismRate);
+        this.elitismRate = elitismRate;
     }
 
     /**

```

# Math 36


Nb Executed tests: 3540

Nb Failing tests: 2

>	org.apache.commons.math.fraction.BigFractionTest#testFloatValueForLargeNumeratorAndDenominator
>	org.apache.commons.math.fraction.BigFractionTest#testDoubleValueForLargeNumeratorAndDenominator

## Human Patch 

```Java
diff --git a/org/apache/commons/math/fraction/BigFraction.java b/org/apache/commons/math/fraction/BigFraction.java
index a6672e4..e93d76d 100644
--- a/org/apache/commons/math/fraction/BigFraction.java
+++ b/org/apache/commons/math/fraction/BigFraction.java
@@ -682,16 +682,7 @@ public class BigFraction
      */
     @Override
     public double doubleValue() {
-        double result = numerator.doubleValue() / denominator.doubleValue();
-        if (Double.isNaN(result)) {
-            // Numerator and/or denominator must be out of range:
-            // Calculate how far to shift them to put them in range.
-            int shift = Math.max(numerator.bitLength(),
-                                 denominator.bitLength()) - Double.MAX_EXPONENT;
-            result = numerator.shiftRight(shift).doubleValue() /
-                denominator.shiftRight(shift).doubleValue();
-        }
-        return result;
+        return numerator.doubleValue() / denominator.doubleValue();
     }
 
     /**
@@ -735,16 +726,7 @@ public class BigFraction
      */
     @Override
     public float floatValue() {
-        float result = numerator.floatValue() / denominator.floatValue();
-        if (Double.isNaN(result)) {
-            // Numerator and/or denominator must be out of range:
-            // Calculate how far to shift them to put them in range.
-            int shift = Math.max(numerator.bitLength(),
-                                 denominator.bitLength()) - Float.MAX_EXPONENT;
-            result = numerator.shiftRight(shift).floatValue() /
-                denominator.shiftRight(shift).floatValue();
-        }
-        return result;
+        return numerator.floatValue() / denominator.floatValue();
     }
 
     /**

```

# Math 37


Nb Executed tests: 3582

Nb Failing tests: 4

>	org.apache.commons.math.complex.ComplexTest#testTanhInf
>	org.apache.commons.math.complex.ComplexTest#testTan
>	org.apache.commons.math.complex.ComplexTest#testTanh
>	org.apache.commons.math.complex.ComplexTest#testTanInf

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/Complex.java b/org/apache/commons/math/complex/Complex.java
index ed76a29..3822a89 100644
--- a/org/apache/commons/math/complex/Complex.java
+++ b/org/apache/commons/math/complex/Complex.java
@@ -1015,15 +1015,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {
      * @since 1.2
      */
     public Complex tan() {
-        if (isNaN || Double.isInfinite(real)) {
+        if (isNaN) {
             return NaN;
         }
-        if (imaginary > 20.0) {
-            return createComplex(0.0, 1.0);
-        }
-        if (imaginary < -20.0) {
-            return createComplex(0.0, -1.0);
-        }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
@@ -1066,15 +1060,10 @@ public class Complex implements FieldElement<Complex>, Serializable  {
      * @since 1.2
      */
     public Complex tanh() {
-        if (isNaN || Double.isInfinite(imaginary)) {
+        if (isNaN) {
             return NaN;
         }
-        if (real > 20.0) {
-            return createComplex(1.0, 0.0);
-        }
-        if (real < -20.0) {
-            return createComplex(-1.0, 0.0);
-        }
+
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

```

# Math 38


Nb Executed tests: 3260

Nb Failing tests: 1

>	org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest#testConstrainedRosenWithMoreInterpolationPoints

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java b/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java
index ba3fe26..e31b156 100644
--- a/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java
+++ b/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java
@@ -1657,12 +1657,10 @@ public class BOBYQAOptimizer
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
-//                     throw new PathIsExploredException(); // XXX
+                    throw new PathIsExploredException(); // XXX
                 }
-                final int iptMinus1 = ipt - 1;
-                final int jptMinus1 = jpt - 1;
-                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
-                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
+                interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));
+                interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));
             }
 
             // Calculate the next value of F. The least function value so far and
@@ -1749,7 +1747,7 @@ public class BOBYQAOptimizer
                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
-//                 throw new PathIsExploredException(); // XXX
+                throw new PathIsExploredException(); // XXX
             }
         } while (getEvaluations() < npt);
     } // prelim
@@ -2464,19 +2462,19 @@ public class BOBYQAOptimizer
     private static void printMethod() {
         //        System.out.println(caller(2));
     }
+}
 
-    /**
-     * Marker for code paths that are not explored with the current unit tests.
-     * If the path becomes explored, it should just be removed from the code.
-     */
-    private static class PathIsExploredException extends RuntimeException {
-        private static final long serialVersionUID = 745350979634801853L;
+/**
+ * Marker for code paths that are not explored with the current unit tests.
+ * If the path becomes explored, it should just be removed from the code.
+ */
+class PathIsExploredException extends RuntimeException {
+    private static final long serialVersionUID = 745350979634801853L;
 
-        private static final String PATH_IS_EXPLORED
-            = "If this exception is thrown, just remove it from the code";
+    private static final String PATH_IS_EXPLORED
+        = "If this exception is thrown, just remove it from the code";
 
-        PathIsExploredException() {
-            super(PATH_IS_EXPLORED + " " + BOBYQAOptimizer.caller(3));
-        }
+    PathIsExploredException() {
+        super(PATH_IS_EXPLORED);
     }
 }

```

# Math 39


Nb Executed tests: 3259

Nb Failing tests: 1

>	org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testTooLargeFirstStep

## Human Patch 

```Java
diff --git a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
index d2bbf67..13ced27 100644
--- a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
@@ -247,15 +247,6 @@ public abstract class EmbeddedRungeKuttaIntegrator
         }
 
         stepSize = hNew;
-        if (forward) {
-            if (stepStart + stepSize >= t) {
-                stepSize = t - stepStart;
-            }
-        } else {
-            if (stepStart + stepSize <= t) {
-                stepSize = t - stepStart;
-            }
-        }
 
         // next stages
         for (int k = 1; k < stages; ++k) {

```

# Math 40


Nb Executed tests: 3199

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest#testIssue716

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java
index 59dc461..93dd3bb 100644
--- a/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java
@@ -232,16 +232,10 @@ public class BracketingNthOrderBrentSolver
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
-                final int p = agingA - MAXIMAL_AGING;
-                final double weightA = (1 << p) - 1;
-                final double weightB = p + 1;
-                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
+                targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
-                final int p = agingB - MAXIMAL_AGING;
-                final double weightA = p + 1;
-                final double weightB = (1 << p) - 1;
-                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
+                targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;

```

## NopolC 

org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:260 (Suspicious rank: 31 (Ochiai), 40 (Ample), 40 (Tarantula))
```Java
(((xA)<=(absYA))||((signChangeIndex - start) >= (end - signChangeIndex)))&&(x!=null)
```

Nb Angelic value: 1

Nb analyzed Statement: 31

Execution time: 0:08:20.974000

Grid5000 node: chinqchint-43.lille.grid5000.fr


## Genprog 

org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:269 (Suspicious rank: 32 (Ochiai), 42 (Ample), 42 (Tarantula))
```Java
signChangeIndex = 2
```

Execution time: 0:47:28.899000

Grid5000 node : graphene-100.nancy.grid5000.fr

# Math 41


Nb Executed tests: 3194

Nb Failing tests: 1

>	org.apache.commons.math.stat.descriptive.moment.VarianceTest#testEvaluateArraySegmentWeighted

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/descriptive/moment/Variance.java b/org/apache/commons/math/stat/descriptive/moment/Variance.java
index 1de139f..e5518e3 100644
--- a/org/apache/commons/math/stat/descriptive/moment/Variance.java
+++ b/org/apache/commons/math/stat/descriptive/moment/Variance.java
@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se
                 }
 
                 double sumWts = 0;
-                for (int i = begin; i < begin + length; i++) {
+                for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 

```

## NopolPC 

org.apache.commons.math.stat.descriptive.moment.Variance:322 (Suspicious rank: 12 (Ochiai), 15 (Ample), 15 (Tarantula))
```Java
(((-1)-(1))*((-1)-(1)))<(((-1)-(1))+(length))
```

Nb Angelic value: 3

Nb analyzed Statement: 6

Execution time: 0:54:07.396000

Grid5000 node: chimint-10.lille.grid5000.fr


## NopolC 

org.apache.commons.math.stat.descriptive.moment.Variance:322 (Suspicious rank: 12 (Ochiai), 15 (Ample), 15 (Tarantula))
```Java
(((-1)-(1))*((-1)-(1)))<(((-1)-(1))+(length))
```

Nb Angelic value: 3

Nb analyzed Statement: 6

Execution time: 0:45:32.957000

Grid5000 node: chinqchint-15.lille.grid5000.fr


# Math 42


Nb Executed tests: 3173

Nb Failing tests: 1

>	org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath713NegativeVariable

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/linear/SimplexTableau.java b/org/apache/commons/math/optimization/linear/SimplexTableau.java
index d96c916..fd89432 100644
--- a/org/apache/commons/math/optimization/linear/SimplexTableau.java
+++ b/org/apache/commons/math/optimization/linear/SimplexTableau.java
@@ -407,12 +407,7 @@ class SimplexTableau implements Serializable {
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
-          if (basicRow != null && basicRow == 0) {
-              // if the basic row is found to be the objective function row
-              // set the coefficient to 0 -> this case handles unconstrained 
-              // variables that are still part of the objective function
-              coefficients[i] = 0;
-          } else if (basicRows.contains(basicRow)) {
+          if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);

```

## NopolPC 

org.apache.commons.math.optimization.linear.SimplexTableau:317 (Suspicious rank: 24 (Ochiai), 27 (Ample), 27 (Tarantula))
```Java
!((org.apache.commons.math.optimization.linear.SimplexTableau.this.restrictToNonNegative)&&(((org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)<=(org.apache.commons.math.optimization.linear.SimplexTableau.this.epsilon))||(org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.isEmpty())))
```

Nb Angelic value: 9

Nb analyzed Statement: 24

Execution time: 0:47:09.826000

Grid5000 node: chinqchint-20.lille.grid5000.fr


# Math 43


Nb Executed tests: 3153

Nb Failing tests: 6

>	org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testOverrideMeanWithMathClass
>	org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testOverrideGeoMeanWithMathClass
>	org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest#testOverrideVarianceWithMathClass
>	org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testOverrideMeanWithMathClass
>	org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testOverrideGeoMeanWithMathClass
>	org.apache.commons.math.stat.descriptive.SummaryStatisticsTest#testOverrideVarianceWithMathClass

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
index da987cd..1203d51 100644
--- a/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
+++ b/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
@@ -155,13 +155,13 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
-        if (meanImpl != mean) {
+        if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
-        if (varianceImpl != variance) {
+        if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
-        if (geoMeanImpl != geoMean) {
+        if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;

```

# Math 44


Nb Executed tests: 3119

Nb Failing tests: 1

>	org.apache.commons.math.ode.events.EventStateTest#testIssue695

## Human Patch 

```Java
diff --git a/org/apache/commons/math/ode/AbstractIntegrator.java b/org/apache/commons/math/ode/AbstractIntegrator.java
index 8f315e3..2d878b1 100644
--- a/org/apache/commons/math/ode/AbstractIntegrator.java
+++ b/org/apache/commons/math/ode/AbstractIntegrator.java
@@ -40,6 +40,7 @@ import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;
 import org.apache.commons.math.ode.sampling.StepHandler;
 import org.apache.commons.math.util.FastMath;
 import org.apache.commons.math.util.Incrementor;
+import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.Precision;
 
 /**
@@ -277,6 +278,7 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
+            resetOccurred = false;
 
             // initialize the events states if needed
             if (! statesInitialized) {
@@ -330,9 +332,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }
                     return eventT;
                 }
 
@@ -342,9 +341,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }
                     return eventT;
                 }
 

```

## Genprog 

org.apache.commons.math.ode.AbstractIntegrator:325 (Suspicious rank: 31 (Ochiai), 28 (Ample), 28 (Tarantula))
```Java
statesInitialized = false
```

Execution time: 0:09:47.091000

Grid5000 node : graphite-3.nancy.grid5000.fr

# Math 45


Nb Executed tests: 3074

Nb Failing tests: 1

>	org.apache.commons.math.linear.OpenMapRealMatrixTest#testMath679

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/OpenMapRealMatrix.java b/org/apache/commons/math/linear/OpenMapRealMatrix.java
index f05c878..4369db7 100644
--- a/org/apache/commons/math/linear/OpenMapRealMatrix.java
+++ b/org/apache/commons/math/linear/OpenMapRealMatrix.java
@@ -47,11 +46,6 @@ public class OpenMapRealMatrix extends AbstractRealMatrix
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
-        long lRow = (long) rowDimension;
-        long lCol = (long) columnDimension;
-        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
-            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
-        }
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);

```

# Math 46


Nb Executed tests: 2997

Nb Failing tests: 2

>	org.apache.commons.math.complex.ComplexTest#testAtanI
>	org.apache.commons.math.complex.ComplexTest#testDivideZero

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/Complex.java b/org/apache/commons/math/complex/Complex.java
index dd0b00a..137765c 100644
--- a/org/apache/commons/math/complex/Complex.java
+++ b/org/apache/commons/math/complex/Complex.java
@@ -256,8 +256,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {
         }
 
         if (divisor.isZero) {
-            // return isZero ? NaN : INF; // See MATH-657
-            return NaN;
+            return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
@@ -293,8 +292,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {
             return NaN;
         }
         if (divisor == 0d) {
-            // return isZero ? NaN : INF; // See MATH-657
-            return NaN;
+            return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;

```

# Math 47


Nb Executed tests: 2997

Nb Failing tests: 2

>	org.apache.commons.math.complex.ComplexTest#testAtanI
>	org.apache.commons.math.complex.ComplexTest#testDivideZero

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/Complex.java b/org/apache/commons/math/complex/Complex.java
index 137765c..ac31e4b 100644
--- a/org/apache/commons/math/complex/Complex.java
+++ b/org/apache/commons/math/complex/Complex.java
@@ -78,8 +78,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {
     private final transient boolean isNaN;
     /** Record whether this complex number is infinite. */
     private final transient boolean isInfinite;
-    /** Record whether this complex number is zero. */
-    private final transient boolean isZero;
 
     /**
      * Create a complex number given only the real part.
@@ -103,7 +101,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
-        isZero = real == 0 && imaginary == 0;
     }
 
     /**
@@ -255,17 +249,16 @@ public class Complex implements FieldElement<Complex>, Serializable  {
             return NaN;
         }
 
-        if (divisor.isZero) {
-            return isZero ? NaN : INF;
+        final double c = divisor.getReal();
+        final double d = divisor.getImaginary();
+        if (c == 0.0 && d == 0.0) {
+            return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
-        final double c = divisor.getReal();
-        final double d = divisor.getImaginary();
-
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
@@ -292,7 +285,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {
             return NaN;
         }
         if (divisor == 0d) {
-            return isZero ? NaN : INF;
+            return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;

```

# Math 48


Nb Executed tests: 2995

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest#testIssue631

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
index 0347525..c781a90 100644
--- a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
@@ -184,11 +183,7 @@ public abstract class BaseSecantSolver
                     f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
-                    // Detect early that algorithm is stuck, instead of waiting
-                    // for the maximum number of iterations to be exceeded.
-                    if (x == x1) {
-                        throw new ConvergenceException();
-                    }
+                    // Nothing.
                     break;
                 default:
                     // Should never happen.

```

# Math 49


Nb Executed tests: 2954

Nb Failing tests: 1

>	org.apache.commons.math.linear.SparseRealVectorTest#testConcurrentModification

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/OpenMapRealVector.java b/org/apache/commons/math/linear/OpenMapRealVector.java
index 13ebfd2..5db4884 100644
--- a/org/apache/commons/math/linear/OpenMapRealVector.java
+++ b/org/apache/commons/math/linear/OpenMapRealVector.java
@@ -342,7 +342,7 @@ public class OpenMapRealVector extends AbstractRealVector
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
-        Iterator iter = entries.iterator();
+        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
@@ -355,7 +355,7 @@ public class OpenMapRealVector extends AbstractRealVector
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
-        Iterator iter = entries.iterator();
+        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
@@ -367,7 +367,7 @@ public class OpenMapRealVector extends AbstractRealVector
     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
-        Iterator iter = entries.iterator();
+        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
@@ -380,7 +380,7 @@ public class OpenMapRealVector extends AbstractRealVector
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
-        Iterator iter = entries.iterator();
+        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);

```

## NopolPC 

org.apache.commons.math.linear.OpenMapRealVector:667 (Suspicious rank: 14 (Ochiai), 14 (Ample), 14 (Tarantula))
```Java
(org.apache.commons.math.linear.OpenMapRealVector.this.epsilon)==(org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE)
```

Nb Angelic value: 1

Nb analyzed Statement: 14

Execution time: 0:06:26.350000

Grid5000 node: chimint-5.lille.grid5000.fr


## Genprog 

org.apache.commons.math.util.OpenIntToDoubleHashMap:399 (Suspicious rank: 44 (Ochiai), 40 (Ample), 40 (Tarantula))
```Java
remove
```

Execution time: 0:04:11.776000

Grid5000 node : graphene-102.nancy.grid5000.fr

## Kali 

org.apache.commons.math.util.OpenIntToDoubleHashMap:399 (Suspicious rank: 44 (Ochiai), 40 (Ample), 40 (Tarantula))
```Java
remove
```

Execution time: 0:04:57.796000

Grid5000 node : griffon-8.nancy.grid5000.fr


# Math 50


Nb Executed tests: 2952

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest#testIssue631

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
index c781a90..b3a23a1 100644
--- a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
@@ -183,7 +183,14 @@ public abstract class BaseSecantSolver
                     f0 *= f1 / (f1 + fx);
                     break;
                 case REGULA_FALSI:
-                    // Nothing.
+                    if (x == x1) {
+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
+                                                          atol);
+                        // Update formula cannot make any progress: Update the
+                        // search interval.
+                        x0 = 0.5 * (x0 + x1 - delta);
+                        f0 = computeObjectiveValue(x0);
+                    }
                     break;
                 default:
                     // Should never happen.

```

## NopolPC 

org.apache.commons.math.analysis.solvers.BaseSecantSolver:240 (Suspicious rank: 8 (Ochiai), 8 (Ample), 8 (Tarantula))
```Java
(((-1)!=(x))&&((f0)<=(atol)))||((ftol)==(atol))
```

Nb Angelic value: 2

Nb analyzed Statement: 8

Execution time: 0:18:41.312000

Grid5000 node: chimint-19.lille.grid5000.fr


## NopolC 

org.apache.commons.math.analysis.solvers.BaseSecantSolver:186 (Suspicious rank: 6 (Ochiai), 6 (Ample), 6 (Tarantula))
```Java
(f0)<(-1)
```

Nb Angelic value: 1

Nb analyzed Statement: 6

Execution time: 0:09:12.688000

Grid5000 node: chimint-15.lille.grid5000.fr


## Genprog 

org.apache.commons.math.analysis.solvers.BaseSecantSolver:191 (Suspicious rank: 2 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
remove
```

Execution time: 0:03:46.161000

Grid5000 node : graphene-103.nancy.grid5000.fr

## Kali 

org.apache.commons.math.analysis.solvers.BaseSecantSolver:191 (Suspicious rank: 2 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
remove
```

Execution time: 0:04:49.932000

Grid5000 node : graphene-74.nancy.grid5000.fr


# Math 51


Nb Executed tests: 2941

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest#testIssue631

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
index b3a23a1..fde7172 100644
--- a/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
@@ -169,37 +169,25 @@ public abstract class BaseSecantSolver
 
             // Update the bounds with the new approximation.
             if (f1 * fx < 0) {
-                // The value of x1 has switched to the other bound, thus inverting
+                // We had [x0..x1]. We update it to [x1, x]. Note that the
+                // value of x1 has switched to the other bound, thus inverting
                 // the interval.
                 x0 = x1;
                 f0 = f1;
+                x1 = x;
+                f1 = fx;
                 inverted = !inverted;
             } else {
-                switch (method) {
-                case ILLINOIS:
+                // We had [x0..x1]. We update it to [x0, x].
+                if (method == Method.ILLINOIS) {
                     f0 *= 0.5;
-                    break;
-                case PEGASUS:
+                }
+                if (method == Method.PEGASUS) {
                     f0 *= f1 / (f1 + fx);
-                    break;
-                case REGULA_FALSI:
-                    if (x == x1) {
-                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
-                                                          atol);
-                        // Update formula cannot make any progress: Update the
-                        // search interval.
-                        x0 = 0.5 * (x0 + x1 - delta);
-                        f0 = computeObjectiveValue(x0);
-                    }
-                    break;
-                default:
-                    // Should never happen.
-                    throw new MathInternalError();
                 }
+                x1 = x;
+                f1 = fx;
             }
-            // Update from [x0, x1] to [x0, x].
-            x1 = x;
-            f1 = fx;
 
             // If the function value of the last approximation is too small,
             // given the function value accuracy, then we can't get closer to

```

# Math 52


Nb Executed tests: 2918

Nb Failing tests: 1

>	org.apache.commons.math.geometry.euclidean.threed.RotationTest#testIssue639

## Human Patch 

```Java
diff --git a/org/apache/commons/math/geometry/euclidean/threed/Rotation.java b/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
index ada0a8f..bfa7f26 100644
--- a/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
+++ b/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
@@ -313,51 +313,92 @@ public class Rotation implements Serializable {
   public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
 
   // norms computation
-  double u1u1 = u1.getNormSq();
-  double u2u2 = u2.getNormSq();
-  double v1v1 = v1.getNormSq();
-  double v2v2 = v2.getNormSq();
+  double u1u1 = Vector3D.dotProduct(u1, u1);
+  double u2u2 = Vector3D.dotProduct(u2, u2);
+  double v1v1 = Vector3D.dotProduct(v1, v1);
+  double v2v2 = Vector3D.dotProduct(v2, v2);
   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
     throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
   }
 
-  // normalize v1 in order to have (v1'|v1') = (u1|u1)
-  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);
+  double u1x = u1.getX();
+  double u1y = u1.getY();
+  double u1z = u1.getZ();
+
+  double u2x = u2.getX();
+  double u2y = u2.getY();
+  double u2z = u2.getZ();
 
-  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
-  double u1u2   = u1.dotProduct(u2);
-  double v1v2   = v1.dotProduct(v2);
+  // normalize v1 in order to have (v1'|v1') = (u1|u1)
+  double coeff = FastMath.sqrt (u1u1 / v1v1);
+  double v1x   = coeff * v1.getX();
+  double v1y   = coeff * v1.getY();
+  double v1z   = coeff * v1.getZ();
+  v1 = new Vector3D(v1x, v1y, v1z);
+
+  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)
+  double u1u2   = Vector3D.dotProduct(u1, u2);
+  double v1v2   = Vector3D.dotProduct(v1, v2);
   double coeffU = u1u2 / u1u1;
   double coeffV = v1v2 / u1u1;
   double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
   double alpha  = coeffU - beta * coeffV;
-  v2 = new Vector3D(alpha, v1, beta, v2);
-
-  // preliminary computation
-  Vector3D uRef  = u1;
-  Vector3D vRef  = v1;
-  Vector3D v1Su1 = v1.subtract(u1);
-  Vector3D v2Su2 = v2.subtract(u2);
-  Vector3D k     = v1Su1.crossProduct(v2Su2);
-  Vector3D u3    = u1.crossProduct(u2);
-  double c       = k.dotProduct(u3);
-  final double inPlaneThreshold = 0.001;
-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
-    // the (q1, q2, q3) vector is close to the (u1, u2) plane
+  double v2x    = alpha * v1x + beta * v2.getX();
+  double v2y    = alpha * v1y + beta * v2.getY();
+  double v2z    = alpha * v1z + beta * v2.getZ();
+  v2 = new Vector3D(v2x, v2y, v2z);
+
+  // preliminary computation (we use explicit formulation instead
+  // of relying on the Vector3D class in order to avoid building lots
+  // of temporary objects)
+  Vector3D uRef = u1;
+  Vector3D vRef = v1;
+  double dx1 = v1x - u1.getX();
+  double dy1 = v1y - u1.getY();
+  double dz1 = v1z - u1.getZ();
+  double dx2 = v2x - u2.getX();
+  double dy2 = v2y - u2.getY();
+  double dz2 = v2z - u2.getZ();
+  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,
+                            dz1 * dx2 - dx1 * dz2,
+                            dx1 * dy2 - dy1 * dx2);
+  double c = k.getX() * (u1y * u2z - u1z * u2y) +
+             k.getY() * (u1z * u2x - u1x * u2z) +
+             k.getZ() * (u1x * u2y - u1y * u2x);
+
+  if (c == 0) {
+    // the (q1, q2, q3) vector is in the (u1, u2) plane
     // we try other vectors
+    Vector3D u3 = Vector3D.crossProduct(u1, u2);
     Vector3D v3 = Vector3D.crossProduct(v1, v2);
-    Vector3D v3Su3 = v3.subtract(u3);
-    k = v1Su1.crossProduct(v3Su3);
-    Vector3D u2Prime = u1.crossProduct(u3);
-    c = k.dotProduct(u2Prime);
-
-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
-      k = v2Su2.crossProduct(v3Su3);;
-      c = k.dotProduct(u2.crossProduct(u3));;
-
-      if (c <= 0) {
+    double u3x  = u3.getX();
+    double u3y  = u3.getY();
+    double u3z  = u3.getZ();
+    double v3x  = v3.getX();
+    double v3y  = v3.getY();
+    double v3z  = v3.getZ();
+
+    double dx3 = v3x - u3x;
+    double dy3 = v3y - u3y;
+    double dz3 = v3z - u3z;
+    k = new Vector3D(dy1 * dz3 - dz1 * dy3,
+                     dz1 * dx3 - dx1 * dz3,
+                     dx1 * dy3 - dy1 * dx3);
+    c = k.getX() * (u1y * u3z - u1z * u3y) +
+        k.getY() * (u1z * u3x - u1x * u3z) +
+        k.getZ() * (u1x * u3y - u1y * u3x);
+
+    if (c == 0) {
+      // the (q1, q2, q3) vector is aligned with u1:
+      // we try (u2, u3) and (v2, v3)
+      k = new Vector3D(dy2 * dz3 - dz2 * dy3,
+                       dz2 * dx3 - dx2 * dz3,
+                       dx2 * dy3 - dy2 * dx3);
+      c = k.getX() * (u2y * u3z - u2z * u3y) +
+          k.getY() * (u2z * u3x - u2x * u3z) +
+          k.getZ() * (u2x * u3y - u2y * u3x);
+
+      if (c == 0) {
         // the (q1, q2, q3) vector is aligned with everything
         // this is really the identity rotation
         q0 = 1.0;
@@ -386,7 +427,8 @@ public class Rotation implements Serializable {
    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
                     uRef.getZ() * q1 - uRef.getX() * q3,
                     uRef.getX() * q2 - uRef.getY() * q1);
-  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());
+   c = Vector3D.dotProduct(k, k);
+  q0 = Vector3D.dotProduct(vRef, k) / (c + c);
 
   }
 
@@ -410,7 +452,7 @@ public class Rotation implements Serializable {
         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
     }
 
-    double dot = u.dotProduct(v);
+    double dot = Vector3D.dotProduct(u, v);
 
     if (dot < ((2.0e-15 - 1.0) * normProduct)) {
       // special case u = -v: we select a PI angle rotation around
@@ -425,10 +467,9 @@ public class Rotation implements Serializable {
       // the shortest possible rotation: axis orthogonal to this plane
       q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));
       double coeff = 1.0 / (2.0 * q0 * normProduct);
-      Vector3D q = v.crossProduct(u);
-      q1 = coeff * q.getX();
-      q2 = coeff * q.getY();
-      q3 = coeff * q.getZ();
+      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());
+      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());
+      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());
     }
 
   }

```

# Math 53


Nb Executed tests: 2525

Nb Failing tests: 1

>	org.apache.commons.math.complex.ComplexTest#testAddNaN

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/Complex.java b/org/apache/commons/math/complex/Complex.java
index ab58c78..e0a8e97 100644
--- a/org/apache/commons/math/complex/Complex.java
+++ b/org/apache/commons/math/complex/Complex.java
@@ -150,9 +150,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
-        if (isNaN || rhs.isNaN) {
-            return NaN;
-        }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }

```

# Math 54


Nb Executed tests: 2420

Nb Failing tests: 1

>	org.apache.commons.math.dfp.DfpTest#testIssue567

## Human Patch 

```Java
diff --git a/org/apache/commons/math/dfp/Dfp.java b/org/apache/commons/math/dfp/Dfp.java
index 54aabc4..04e6613 100644
--- a/org/apache/commons/math/dfp/Dfp.java
+++ b/org/apache/commons/math/dfp/Dfp.java
@@ -269,10 +269,6 @@ public class Dfp implements FieldElement<Dfp> {
         if (exponent == -1023) {
             // Zero or sub-normal
             if (x == 0) {
-                // make sure 0 has the right sign
-                if ((bits & 0x8000000000000000L) != 0) {
-                    sign = -1;
-                }
                 return;
             }
 
@@ -2319,10 +2315,7 @@ public class Dfp implements FieldElement<Dfp> {
 
         Dfp y = this;
         boolean negate = false;
-        int cmp0 = compare(this, getZero());
-        if (cmp0 == 0) {
-            return sign < 0 ? -0.0 : +0.0;
-        } else if (cmp0 < 0) {
+        if (lessThan(getZero())) {
             y = negate();
             negate = true;
         }

```

# Math 55


Nb Executed tests: 2401

Nb Failing tests: 1

>	org.apache.commons.math.geometry.Vector3DTest#testCrossProductCancellation

## Human Patch 

```Java
diff --git a/org/apache/commons/math/geometry/Vector3D.java b/org/apache/commons/math/geometry/Vector3D.java
index 2d915e5..0a4adb8 100644
--- a/org/apache/commons/math/geometry/Vector3D.java
+++ b/org/apache/commons/math/geometry/Vector3D.java
@@ -454,41 +454,10 @@ public class Vector3D implements Serializable {
    * @param v2 second vector
    * @return the cross product v1 ^ v2 as a new Vector
    */
-  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
-
-      final double n1 = v1.getNormSq();
-      final double n2 = v2.getNormSq();
-      if ((n1 * n2) < MathUtils.SAFE_MIN) {
-          return ZERO;
-      }
-
-      // rescale both vectors without losing precision,
-      // to ensure their norm are the same order of magnitude
-      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
-      final double x1    = FastMath.scalb(v1.x, -deltaExp);
-      final double y1    = FastMath.scalb(v1.y, -deltaExp);
-      final double z1    = FastMath.scalb(v1.z, -deltaExp);
-      final double x2    = FastMath.scalb(v2.x,  deltaExp);
-      final double y2    = FastMath.scalb(v2.y,  deltaExp);
-      final double z2    = FastMath.scalb(v2.z,  deltaExp);
-
-      // we reduce cancellation errors by preconditioning,
-      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
-      // v3 without loss of precision. See Kahan lecture
-      // "Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces"
-      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
-
-      // compute rho as an 8 bits approximation of v1.v2 / v2.v2
-      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
-      final double rho   = FastMath.rint(256 * ratio) / 256;
-
-      final double x3 = x1 - rho * x2;
-      final double y3 = y1 - rho * y2;
-      final double z3 = z1 - rho * z2;
-
-      // compute cross product from v3 and v2 instead of v1 and v2
-      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
-
+  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
+    return new Vector3D(v1.y * v2.z - v1.z * v2.y,
+                        v1.z * v2.x - v1.x * v2.z,
+                        v1.x * v2.y - v1.y * v2.x);
   }
 
   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.

```

# Math 56


Nb Executed tests: 2400

Nb Failing tests: 1

>	org.apache.commons.math.util.MultidimensionalCounterTest#testIterationConsistency

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MultidimensionalCounter.java b/org/apache/commons/math/util/MultidimensionalCounter.java
index fb0614e..56c9ffe 100644
--- a/org/apache/commons/math/util/MultidimensionalCounter.java
+++ b/org/apache/commons/math/util/MultidimensionalCounter.java
@@ -234,7 +234,13 @@ public class MultidimensionalCounter implements Iterable<Integer> {
             indices[i] = idx;
         }
 
-        indices[last] = index - count;
+        int idx = 1;
+        while (count < index) {
+            count += idx;
+            ++idx;
+        }
+        --idx;
+        indices[last] = idx;
 
         return indices;
     }

```

# Math 57


Nb Executed tests: 2383

Nb Failing tests: 1

>	org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#testSmallDistances

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java
index e09bbc3..b73ac9d 100644
--- a/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java
+++ b/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java
@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {
         while (resultSet.size() < k) {
             // For each data point x, compute D(x), the distance between x and
             // the nearest center that has already been chosen.
-            double sum = 0;
+            int sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);

```

## NopolC 

org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:85 (Suspicious rank: 50 (Ochiai), 48 (Ample), 48 (Tarantula))
```Java
((1)<(otherPoint.length))&&((point[i]) != (otherPoint[i]))
```

Nb Angelic value: 1

Nb analyzed Statement: 50

Execution time: 0:24:10.930000

Grid5000 node: chinqchint-11.lille.grid5000.fr


# Math 58


Nb Executed tests: 2354

Nb Failing tests: 1

>	org.apache.commons.math.optimization.fitting.GaussianFitterTest#testMath519

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/org/apache/commons/math/optimization/fitting/GaussianFitter.java
index e1b54f4..8c107de 100644
--- a/org/apache/commons/math/optimization/fitting/GaussianFitter.java
+++ b/org/apache/commons/math/optimization/fitting/GaussianFitter.java
@@ -117,8 +117,8 @@ public class GaussianFitter extends CurveFitter {
      * observed points (in the same order as above).
      */
     public double[] fit() {
-        final double[] guess = (new ParameterGuesser(getObservations())).guess();
-        return fit(guess);
+        return fit(new Gaussian.Parametric(),
+                   (new ParameterGuesser(getObservations())).guess());
     }
 
     /**

```

## NopolC 

org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:613 (Suspicious rank: 92 (Ochiai), 86 (Ample), 86 (Tarantula))
```Java
(fp > 0)||((gNorm)<=(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance))
```

Nb Angelic value: 1

Nb analyzed Statement: 92

Execution time: 0:09:46.654000

Grid5000 node: chimint-1.lille.grid5000.fr


# Math 59


Nb Executed tests: 2235

Nb Failing tests: 1

>	org.apache.commons.math.util.FastMathTest#testMinMaxFloat

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/FastMath.java b/org/apache/commons/math/util/FastMath.java
index 4f7d447..8cba4d4 100644
--- a/org/apache/commons/math/util/FastMath.java
+++ b/org/apache/commons/math/util/FastMath.java
@@ -3479,7 +3479,7 @@ public class FastMath {
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
     }
 
     /** Compute the maximum of two values

```

# Math 60


Nb Executed tests: 2218

Nb Failing tests: 1

>	org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues

## Human Patch 

```Java
diff --git a/org/apache/commons/math/distribution/NormalDistributionImpl.java b/org/apache/commons/math/distribution/NormalDistributionImpl.java
index 0d7ce7d..456555b 100644
--- a/org/apache/commons/math/distribution/NormalDistributionImpl.java
+++ b/org/apache/commons/math/distribution/NormalDistributionImpl.java
@@ -114,20 +114,26 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
 
     /**
      * For this distribution, {@code X}, this method returns {@code P(X < x)}.
-     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,
-     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.
      *
      * @param x Value at which the CDF is evaluated.
      * @return CDF evaluated at {@code x}.
-     * @throws MathException if the algorithm fails to converge
+     * @throws MathException if the algorithm fails to converge; unless
+     * {@code x} is more than 20 standard deviations from the mean, in which
+     * case the convergence exception is caught and 0 or 1 is returned.
      */
     public double cumulativeProbability(double x) throws MathException {
-        final double dev = x - mean;
-        if (FastMath.abs(dev) > 40 * standardDeviation) { 
-            return dev < 0 ? 0.0d : 1.0d;
-        }
-        return 0.5 * (1.0 + Erf.erf((dev) /
+        try {
+            return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * FastMath.sqrt(2.0))));
+        } catch (MaxIterationsExceededException ex) {
+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
+                return 0;
+            } else if (x > (mean + 20 * standardDeviation)) {
+                return 1;
+            } else {
+                throw ex;
+            }
+        }
     }
 
     /**

```

# Math 61


Nb Executed tests: 2366

Nb Failing tests: 1

>	org.apache.commons.math.distribution.PoissonDistributionTest#testMean

## Human Patch 

```Java
diff --git a/org/apache/commons/math/distribution/PoissonDistribution.java b/org/apache/commons/math/distribution/PoissonDistribution.java
index d20eb53..6aca509 100644
--- a/org/apache/commons/math/distribution/PoissonDistribution.java
+++ b/org/apache/commons/math/distribution/PoissonDistribution.java
@@ -40,6 +41,18 @@ public interface PoissonDistribution extends IntegerDistribution {
     double getMean();
 
     /**
+     * Set the mean for the distribution.
+     * The parameter value must be positive; otherwise an
+     * <code>IllegalArgument</code> is thrown.
+     *
+     * @param p the mean
+     * @throws IllegalArgumentException if p &le; 0
+     * @deprecated as of v2.1
+     */
+    @Deprecated
+    void setMean(double p);
+
+    /**
      * Calculates the Poisson distribution function using a normal approximation.
      *
      * @param x the upper bound, inclusive
@@ -47,4 +60,5 @@ public interface PoissonDistribution extends IntegerDistribution {
      * @throws MathException if an error occurs computing the normal approximation
      */
     double normalApproximateProbability(int x) throws MathException;
+
 }
diff --git a/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/org/apache/commons/math/distribution/PoissonDistributionImpl.java
index 0a81233..64f792b 100644
--- a/org/apache/commons/math/distribution/PoissonDistributionImpl.java
+++ b/org/apache/commons/math/distribution/PoissonDistributionImpl.java
@@ -19,7 +19,7 @@ package org.apache.commons.math.distribution;
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.exception.NotStrictlyPositiveException;
+import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;
@@ -77,7 +77,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
      * @throws IllegalArgumentException if p &le; 0
      */
     public PoissonDistributionImpl(double p) {
-        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);
+        this(p, new NormalDistributionImpl());
     }
 
     /**
@@ -90,11 +90,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
      * @since 2.1
      */
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
-        if (p <= 0) {
-            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
-        }
-        mean = p;
-        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
+        setMean(p);
         this.epsilon = epsilon;
         this.maxIterations = maxIterations;
     }
@@ -107,7 +103,8 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
      * @since 2.1
      */
     public PoissonDistributionImpl(double p, double epsilon) {
-        this(p, epsilon, DEFAULT_MAX_ITERATIONS);
+        setMean(p);
+        this.epsilon = epsilon;
     }
 
     /**
@@ -118,7 +115,26 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
      * @since 2.1
      */
     public PoissonDistributionImpl(double p, int maxIterations) {
-        this(p, DEFAULT_EPSILON, maxIterations);
+        setMean(p);
+        this.maxIterations = maxIterations;
+    }
+
+
+    /**
+     * Create a new Poisson distribution with the given the mean. The mean value
+     * must be positive; otherwise an <code>IllegalArgument</code> is thrown.
+     *
+     * @param p the Poisson mean
+     * @param z a normal distribution used to compute normal approximations.
+     * @throws IllegalArgumentException if p &le; 0
+     * @since 1.2
+     * @deprecated as of 2.1 (to avoid possibly inconsistent state, the
+     * "NormalDistribution" will be instantiated internally)
+     */
+    @Deprecated
+    public PoissonDistributionImpl(double p, NormalDistribution z) {
+        super();
+        setNormalAndMeanInternal(z, p);
     }
 
     /**
@@ -131,6 +147,38 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
     }
 
     /**
+     * Set the Poisson mean for the distribution. The mean value must be
+     * positive; otherwise an <code>IllegalArgument</code> is thrown.
+     *
+     * @param p the Poisson mean value
+     * @throws IllegalArgumentException if p &le; 0
+     * @deprecated as of 2.1 (class will become immutable in 3.0)
+     */
+    @Deprecated
+    public void setMean(double p) {
+        setNormalAndMeanInternal(normal, p);
+    }
+    /**
+     * Set the Poisson mean for the distribution. The mean value must be
+     * positive; otherwise an <code>IllegalArgument</code> is thrown.
+     *
+     * @param z the new distribution
+     * @param p the Poisson mean value
+     * @throws IllegalArgumentException if p &le; 0
+     */
+    private void setNormalAndMeanInternal(NormalDistribution z,
+                                          double p) {
+        if (p <= 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                    LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
+        }
+        mean = p;
+        normal = z;
+        normal.setMean(p);
+        normal.setStandardDeviation(FastMath.sqrt(p));
+    }
+
+    /**
      * The probability mass function P(X = x) for a Poisson distribution.
      *
      * @param x the value at which the probability density function is
@@ -238,4 +286,18 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution
     protected int getDomainUpperBound(double p) {
         return Integer.MAX_VALUE;
     }
+
+    /**
+     * Modify the normal distribution used to compute normal approximations. The
+     * caller is responsible for insuring the normal distribution has the proper
+     * parameter settings.
+     *
+     * @param value the new distribution
+     * @since 1.2
+     * @deprecated as of 2.1 (class will become immutable in 3.0)
+     */
+    @Deprecated
+    public void setNormal(NormalDistribution value) {
+        setNormalAndMeanInternal(value, mean);
+    }
 }

```

# Math 62


Nb Executed tests: 2365

Nb Failing tests: 1

>	org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest#testQuinticMin

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java
index 952e565..aa14ce6 100644
--- a/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java
+++ b/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java
@@ -143,22 +143,18 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
-        return optimize(f, goal, min, max, min + 0.5 * (max - min));
-    }
 
-    /** {@inheritDoc} */
-    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
-                                                 final double min, final double max,
-                                                 final double startValue)
-        throws FunctionEvaluationException {
         optima = new UnivariateRealPointValuePair[starts];
         totalEvaluations = 0;
 
         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
-                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
-                optima[i] = optimizer.optimize(f, goal, min, max, s);
+                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
+                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
+                optima[i] = optimizer.optimize(f, goal,
+                                               FastMath.min(bound1, bound2),
+                                               FastMath.max(bound1, bound2));
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
@@ -181,6 +177,16 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti
         return optima[0];
     }
 
+    /** {@inheritDoc} */
+    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType,
+                                                 final double min, final double max,
+                                                 final double startValue)
+            throws FunctionEvaluationException {
+        // XXX Main code should be here, using "startValue" for the first start.
+        // XXX This method should set "startValue" to min + 0.5 * (max - min)
+        return optimize(f, goalType, min, max);
+    }
+
     /**
      * Sort the optima from best to worst, followed by {@code null} elements.
      *

```

# Math 63


Nb Executed tests: 2282

Nb Failing tests: 1

>	org.apache.commons.math.util.MathUtilsTest#testArrayEquals

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MathUtils.java b/org/apache/commons/math/util/MathUtils.java
index ab0fe33..887dc66 100644
--- a/org/apache/commons/math/util/MathUtils.java
+++ b/org/apache/commons/math/util/MathUtils.java
@@ -407,14 +407,20 @@ public final class MathUtils {
 
     /**
      * Returns true iff they are equal as defined by
-     * {@link #equals(double,double,int) equals(x, y, 1)}.
+     * {@link #equals(double,double,int) this method}.
      *
      * @param x first value
      * @param y second value
      * @return {@code true} if the values are equal.
+     * @deprecated This method considers that {@code NaN == NaN}. In release
+     * 3.0, the semantics will change in order to comply with IEEE754 where it
+     * is specified that {@code NaN != NaN}.
+     * New methods have been added for those cases wher the old semantics is
+     * useful (see e.g. {@link #equalsIncludingNaN(double,double)
+     * equalsIncludingNaN}.
      */
     public static boolean equals(double x, double y) {
-        return equals(x, y, 1);
+        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
     }
 
     /**
@@ -1090,6 +1102,29 @@ public final class MathUtils {
     }
 
     /**
+     * Get the next machine representable number after a number, moving
+     * in the direction of another number.
+     * <p>
+     * If <code>direction</code> is greater than or equal to<code>d</code>,
+     * the smallest machine representable number strictly greater than
+     * <code>d</code> is returned; otherwise the largest representable number
+     * strictly less than <code>d</code> is returned.</p>
+     * <p>
+     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
+     *
+     * @param d base number
+     * @param direction (the only important thing is whether
+     * direction is greater or smaller than d)
+     * @return the next machine representable number in the specified direction
+     * @since 1.2
+     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}
+     */
+    @Deprecated
+    public static double nextAfter(double d, double direction) {
+        return FastMath.nextAfter(d, direction);
+    }
+
+    /**
      * Scale a number by 2<sup>scaleFactor</sup>.
      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>
      *
@@ -1283,23 +1318,23 @@ public final class MathUtils {
         switch (roundingMethod) {
         case BigDecimal.ROUND_CEILING :
             if (sign == -1) {
-                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
+                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             } else {
-                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));
+                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
             }
             break;
         case BigDecimal.ROUND_DOWN :
-            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
+            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             break;
         case BigDecimal.ROUND_FLOOR :
             if (sign == -1) {
-                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));
+                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
             } else {
-                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
+                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             }
             break;
         case BigDecimal.ROUND_HALF_DOWN : {
-            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);
+            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);
             double fraction = unscaled - FastMath.floor(unscaled);
             if (fraction > 0.5) {
                 unscaled = FastMath.ceil(unscaled);
@@ -1326,7 +1361,7 @@ public final class MathUtils {
             break;
         }
         case BigDecimal.ROUND_HALF_UP : {
-            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);
+            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);
             double fraction = unscaled - FastMath.floor(unscaled);
             if (fraction >= 0.5) {
                 unscaled = FastMath.ceil(unscaled);
@@ -1341,7 +1376,7 @@ public final class MathUtils {
             }
             break;
         case BigDecimal.ROUND_UP :
-            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));
+            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));
             break;
         default :
             throw MathRuntimeException.createIllegalArgumentException(
@@ -1870,6 +1905,24 @@ public final class MathUtils {
     }
 
     /**
+     * Checks that the given array is sorted.
+     *
+     * @param val Values
+     * @param dir Order direction (-1 for decreasing, 1 for increasing)
+     * @param strict Whether the order should be strict
+     * @throws NonMonotonousSequenceException if the array is not sorted.
+     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)
+     * checkOrder} method). To be removed in 3.0.
+     */
+    public static void checkOrder(double[] val, int dir, boolean strict) {
+        if (dir > 0) {
+            checkOrder(val, OrderDirection.INCREASING, strict);
+        } else {
+            checkOrder(val, OrderDirection.DECREASING, strict);
+        }
+    }
+
+    /**
      * Returns the Cartesian norm (2-norm), handling both overflow and underflow.
      * Translation of the minpack enorm subroutine.
      *

```

# Math 64


Nb Executed tests: 2274

Nb Failing tests: 2

>	org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson
>	org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
index c4b1985..152c30c 100644
--- a/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
+++ b/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
@@ -247,7 +247,12 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul
      * @return chi-square value
      */
     public double getChiSquare() {
-        return cost*cost;
+        double chiSquare = 0;
+        for (int i = 0; i < rows; ++i) {
+            final double residual = residuals[i];
+            chiSquare += residual * residual * residualsWeights[i];
+        }
+        return chiSquare;
     }
 
     /**
diff --git a/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
index b41456e..4cf4ee0 100644
--- a/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
+++ b/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
@@ -255,8 +255,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
-        double[] oldObj  = new double[rows];
-        double[] qtf     = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];
@@ -269,9 +267,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
-            for (int i=0;i<rows;i++) {
-                qtf[i]=residuals[i];
-            }
+
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
@@ -280,7 +276,8 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
             qrDecomposition();
 
             // compute Qt.res
-            qTy(qtf);
+            qTy(residuals);
+
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
@@ -318,7 +315,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
-                            sum += jacobian[i][pj] * qtf[i];
+                            sum += jacobian[i][pj] * residuals[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }
@@ -326,8 +323,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
-            	updateResidualsAndCost();
-            	current = new VectorialPointValuePair(point, objective);
                 return current;
             }
 
@@ -348,12 +343,9 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
-                tmpVec    = objective;
-                objective = oldObj;
-                oldObj    = tmpVec;
 
                 // determine the Levenberg-Marquardt parameter
-                determineLMParameter(qtf, delta, diag, work1, work2, work3);
+                determineLMParameter(oldRes, delta, diag, work1, work2, work3);
 
                 // compute the new point and the norm of the evolution direction
                 double lmNorm = 0;
@@ -372,6 +365,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
+                current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -427,15 +421,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
-                    current = new VectorialPointValuePair(point, objective);
-
-                    // tests for convergence.
-                    if (checker != null) {
-                    // we use the vectorial convergence checker
-                    	if (checker.converged(getIterations(), previous, current)) {
-                    		return current;
-                    	}
-                    }
                 } else {
                     // failed iteration, reset the previous values
                     cost = previousCost;
@@ -446,18 +431,24 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
-                    tmpVec    = objective;
-                    objective = oldObj;
-                    oldObj    = tmpVec;
                 }
-                if (checker==null) {
-                	if (((Math.abs(actRed) <= costRelativeTolerance) &&
-                        (preRed <= costRelativeTolerance) &&
-                        (ratio <= 2.0)) ||
-                       (delta <= parRelativeTolerance * xNorm)) {
-                       return current;
-                   }
+
+                // tests for convergence.
+                if (checker != null) {
+                    // we use the vectorial convergence checker
+                    if (checker.converged(getIterations(), previous, current)) {
+                        return current;
+                    }
+                } else {
+                    // we use the Levenberg-Marquardt specific convergence parameters
+                    if (((Math.abs(actRed) <= costRelativeTolerance) &&
+                         (preRed <= costRelativeTolerance) &&
+                         (ratio <= 2.0)) ||
+                        (delta <= parRelativeTolerance * xNorm)) {
+                        return current;
+                    }
                 }
+
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
                 if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {

```

## Genprog 

org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:426 (Suspicious rank: 38 (Ochiai), 42 (Ample), 42 (Tarantula))
```Java
current = new org.apache.commons.math.optimization.VectorialPointValuePair(point , objective)
```

Execution time: 0:05:40.881000

Grid5000 node : graphene-2.nancy.grid5000.fr


# Math 65


Nb Executed tests: 2273

Nb Failing tests: 1

>	org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest#testCircleFitting

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/EigenDecompositionImpl.java b/org/apache/commons/math/linear/EigenDecompositionImpl.java
index 468dca7..d1531a8 100644
--- a/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ b/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -561,7 +561,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {
                             z[ia][i] = c * z[ia][i] - s * p;
                         }
                     }
-                    if (t == 0.0 && i >= j)
+                    if (e[i + 1] == 0.0 && i >= j)
                         continue;
                     realEigenvalues[j] -= u;
                     e[j] = q;
diff --git a/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
index 597f6c4..3abf3f0 100644
--- a/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
+++ b/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
@@ -108,7 +108,7 @@ public class SingularValueDecompositionImpl implements
                 for (int k = 0; k < n; k++) {
                     matAAT[i][j] += localcopy[i][k] * localcopy[j][k];
                 }
-                 matAAT[j][i]=matAAT[i][j];
+                matAAT[j][i]=matAAT[i][j];
             }
         }
         int p;
@@ -140,7 +141,7 @@ public class SingularValueDecompositionImpl implements
             singularValues[i] = Math.sqrt(Math.abs(singularValues[i]));
         }
         // Up to this point, U and V are computed independently of each other.
-        // There still a sign indetermination of each column of, say, U.
+        // There still an sign indetermination of each column of, say, U.
         // The sign is set such that A.V_i=sigma_i.U_i (i<=p)
         // The right sign corresponds to a positive dot product of A.V_i and U_i
         for (int i = 0; i < p; i++) {
diff --git a/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
index 5a60da8..10f7762 100644
--- a/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
+++ b/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
@@ -237,20 +237,23 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul
      * @return RMS value
      */
     public double getRMS() {
-        return Math.sqrt(getChiSquare() / rows);
+        double criterion = 0;
+        for (int i = 0; i < rows; ++i) {
+            final double residual = residuals[i];
+            criterion += residualsWeights[i] * residual * residual;
+        }
+        return Math.sqrt(criterion / rows);
     }
 
     /**
-     * Get a Chi-Square-like value assuming the N residuals follow N
-     * distinct normal distributions centered on 0 and whose variances are
-     * the reciprocal of the weights.
+     * Get the Chi-Square value.
      * @return chi-square value
      */
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
-            chiSquare += residual * residual * residualsWeights[i];
+            chiSquare += residual * residual / residualsWeights[i];
         }
         return chiSquare;
     }

```

# Math 66


Nb Executed tests: 2261

Nb Failing tests: 4

>	org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin
>	org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testSinMin
>	org.apache.commons.math.optimization.univariate.BrentOptimizerTest#testQuinticMinStatistics
>	org.apache.commons.math.optimization.univariate.BrentOptimizerTest#testSinMin

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/univariate/BrentOptimizer.java b/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
index 46c4afa..4544d6e 100644
--- a/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
+++ b/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
@@ -41,10 +41,7 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
      * Construct a solver.
      */
     public BrentOptimizer() {
-        setMaxEvaluations(1000);
-        setMaximalIterationCount(100);
-        setAbsoluteAccuracy(1e-11);
-        setRelativeAccuracy(1e-9);
+        super(100, 1E-10);
     }
 
     /**
@@ -54,9 +51,23 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
      */
     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
-        return localMin(getGoalType() == GoalType.MINIMIZE,
-                        getMin(), getStartValue(), getMax(),
-                        getRelativeAccuracy(), getAbsoluteAccuracy());
+        throw new UnsupportedOperationException();
+    }
+
+    /** {@inheritDoc} */
+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,
+                           final double min, final double max, final double startValue)
+        throws MaxIterationsExceededException, FunctionEvaluationException {
+        clearResult();
+        return localMin(f, goalType, min, startValue, max,
+                    getRelativeAccuracy(), getAbsoluteAccuracy());
+    }
+
+    /** {@inheritDoc} */
+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,
+                           final double min, final double max)
+        throws MaxIterationsExceededException, FunctionEvaluationException {
+        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));
     }
 
     /**
@@ -83,7 +94,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
      * @throws FunctionEvaluationException if an error occurs evaluating
      * the function.
      */
-    private double localMin(boolean isMinim,
+    private double localMin(UnivariateRealFunction f,
+                            GoalType goalType,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {
@@ -105,16 +117,16 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
         double x = mid;
         double v = x;
         double w = x;
-        double d = 0;
         double e = 0;
-        double fx = computeObjectiveValue(x);
-        if (!isMinim) {
+        double fx = computeObjectiveValue(f, x);
+        if (goalType == GoalType.MAXIMIZE) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
-        while (true) {
+        int count = 0;
+        while (count < maximalIterationCount) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;
@@ -124,6 +136,7 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
                 double p = 0;
                 double q = 0;
                 double r = 0;
+                double d = 0;
                 double u = 0;
 
                 if (Math.abs(e) > tol1) { // Fit parabola.
@@ -187,8 +200,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
                     u = x + d;
                 }
 
-                double fu = computeObjectiveValue(u);
-                if (!isMinim) {
+                double fu = computeObjectiveValue(f, u);
+                if (goalType == GoalType.MAXIMIZE) {
                     fu = -fu;
                 }
 
@@ -225,10 +238,11 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
                     }
                 }
             } else { // termination
-                setFunctionValue(isMinim ? fx : -fx);
+                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
                 return x;
             }
-            incrementIterationsCounter();
+            ++count;
         }
+        throw new MaxIterationsExceededException(maximalIterationCount);
     }
 }

```

# Math 67


Nb Executed tests: 2255

Nb Failing tests: 1

>	org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest#testQuinticMin

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java b/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java
index 26fd5e0..10bc9e6 100644
--- a/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java
+++ b/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java
@@ -89,12 +89,12 @@ public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimize
 
     /** {@inheritDoc} */
     public double getFunctionValue() {
-        return optimaValues[0];
+        return optimizer.getFunctionValue();
     }
 
     /** {@inheritDoc} */
     public double getResult() {
-        return optima[0];
+        return optimizer.getResult();
     }
 
     /** {@inheritDoc} */

```

# Math 68


Nb Executed tests: 2186

Nb Failing tests: 2

>	org.apache.commons.math.optimization.general.MinpackTest#testMinpackJennrichSampson
>	org.apache.commons.math.optimization.general.MinpackTest#testMinpackFreudensteinRoth

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
index 28aee43..ea0f20d 100644
--- a/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
+++ b/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
@@ -163,7 +157,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
         setMaxIterations(1000);
 
         // default values for the tuning parameters
-        setConvergenceChecker(null);
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);
@@ -245,13 +235,11 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
-        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
-            VectorialPointValuePair previous = current;
             updateJacobian();
             qrDecomposition();
 
@@ -303,7 +291,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
-                return current;
+                return new VectorialPointValuePair(point, objective);
             }
 
             // rescale if necessary
@@ -345,7 +333,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
-                current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -414,19 +401,11 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
                 }
 
                 // tests for convergence.
-                if (checker != null) {
-                    // we use the vectorial convergence checker
-                    if (checker.converged(getIterations(), previous, current)) {
-                        return current;                        
-                    }
-                } else {
-                    // we use the Levenberg-Marquardt specific convergence parameters
-                    if (((Math.abs(actRed) <= costRelativeTolerance) &&
-                         (preRed <= costRelativeTolerance) &&
-                         (ratio <= 2.0)) ||
+                if (((Math.abs(actRed) <= costRelativeTolerance) &&
+                        (preRed <= costRelativeTolerance) &&
+                        (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
-                        return current;
-                    }
+                    return new VectorialPointValuePair(point, objective);
                 }
 
                 // tests for termination and stringent tolerances

```

# Math 69


Nb Executed tests: 2186

Nb Failing tests: 2

>	org.apache.commons.math.stat.correlation.PearsonsCorrelationTest#testPValueNearZero
>	org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest#testPValueNearZero

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java b/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java
index dc83314..83b4c41 100644
--- a/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java
+++ b/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java
@@ -168,7 +168,7 @@ public class PearsonsCorrelation {
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
-                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
+                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }

```

## NopolPC 

org.apache.commons.math.stat.correlation.PearsonsCorrelation:189 (Suspicious rank: 14 (Ochiai), 21 (Ample), 21 (Tarantula))
```Java
((1)-((-1)+(-1)))<=(nVars)
```

Nb Angelic value: 1

Nb analyzed Statement: 14

Execution time: 0:00:44.238000

Grid5000 node: chinqchint-23.lille.grid5000.fr


# Math 70


Nb Executed tests: 2184

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.BisectionSolverTest#testMath369

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/org/apache/commons/math/analysis/solvers/BisectionSolver.java
index 180caef..3f66927 100644
--- a/org/apache/commons/math/analysis/solvers/BisectionSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BisectionSolver.java
@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {
     /** {@inheritDoc} */
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
-        return solve(f, min, max);
+        return solve(min, max);
     }
 
     /** {@inheritDoc} */

```

## Genprog 

org.apache.commons.math.analysis.solvers.BisectionSolver:72 (Suspicious rank: 1 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
return solve(f, min, max)
```

Execution time: 0:00:45.360000

Grid5000 node : graphene-102.nancy.grid5000.fr

# Math 71


Nb Executed tests: 2169

Nb Failing tests: 2

>	org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest#testMissedEndEvent
>	org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest#testMissedEndEvent

## Human Patch 

```Java
diff --git a/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java b/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java
index 6ee9bd5..935bb8b 100644
--- a/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java
@@ -271,16 +271,8 @@ public class AdamsBashforthIntegrator extends AdamsIntegrator {
                     if (manager.evaluateStep(interpolatorTmp)) {
                         final double dt = manager.getEventTime() - stepStart;
                         if (Math.abs(dt) <= Math.ulp(stepStart)) {
-                            // we cannot simply truncate the step, reject the current computation
-                            // and let the loop compute another state with the truncated step.
-                            // it is so small (much probably exactly 0 due to limited accuracy)
-                            // that the code above would fail handling it.
-                            // So we set up an artificial 0 size step by copying states
-                            interpolator.storeTime(stepStart);
-                            System.arraycopy(y, 0, yTmp, 0, y0.length);
-                            hNew     = 0;
-                            stepSize = 0;
-                            loop     = false;
+                            // rejecting the step would lead to a too small next step, we accept it
+                            loop = false;
                         } else {
                             // reject the step to match exactly the next switch time
                             hNew = dt;
diff --git a/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java b/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java
index e0e2f0d..27ade7b 100644
--- a/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java
@@ -289,16 +289,8 @@ public class AdamsMoultonIntegrator extends AdamsIntegrator {
                     if (manager.evaluateStep(interpolatorTmp)) {
                         final double dt = manager.getEventTime() - stepStart;
                         if (Math.abs(dt) <= Math.ulp(stepStart)) {
-                            // we cannot simply truncate the step, reject the current computation
-                            // and let the loop compute another state with the truncated step.
-                            // it is so small (much probably exactly 0 due to limited accuracy)
-                            // that the code above would fail handling it.
-                            // So we set up an artificial 0 size step by copying states
-                            interpolator.storeTime(stepStart);
-                            System.arraycopy(y, 0, yTmp, 0, y0.length);
-                            hNew     = 0;
-                            stepSize = 0;
-                            loop     = false;
+                            // rejecting the step would lead to a too small next step, we accept it
+                            loop = false;
                         } else {
                             // reject the step to match exactly the next switch time
                             hNew = dt;
diff --git a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
index e03be9e..34b3dc1 100644
--- a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
@@ -292,16 +292,8 @@ public abstract class EmbeddedRungeKuttaIntegrator
           if (manager.evaluateStep(interpolator)) {
               final double dt = manager.getEventTime() - stepStart;
               if (Math.abs(dt) <= Math.ulp(stepStart)) {
-                  // we cannot simply truncate the step, reject the current computation
-                  // and let the loop compute another state with the truncated step.
-                  // it is so small (much probably exactly 0 due to limited accuracy)
-                  // that the code above would fail handling it.
-                  // So we set up an artificial 0 size step by copying states
-                  interpolator.storeTime(stepStart);
-                  System.arraycopy(y, 0, yTmp, 0, y0.length);
-                  hNew     = 0;
-                  stepSize = 0;
-                  loop     = false;
+                  // rejecting the step would lead to a too small next step, we accept it
+                  loop = false;
               } else {
                   // reject the step to match exactly the next switch time
                   hNew = dt;
diff --git a/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java
index b61b0b1..3227b98 100644
--- a/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java
@@ -172,15 +172,8 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {
         if (manager.evaluateStep(interpolator)) {
             final double dt = manager.getEventTime() - stepStart;
             if (Math.abs(dt) <= Math.ulp(stepStart)) {
-                // we cannot simply truncate the step, reject the current computation
-                // and let the loop compute another state with the truncated step.
-                // it is so small (much probably exactly 0 due to limited accuracy)
-                // that the code above would fail handling it.
-                // So we set up an artificial 0 size step by copying states
-                interpolator.storeTime(stepStart);
-                System.arraycopy(y, 0, yTmp, 0, y0.length);
-                stepSize = 0;
-                loop     = false;
+                // rejecting the step would lead to a too small next step, we accept it
+                loop = false;
             } else {
                 // reject the step to match exactly the next switch time
                 stepSize = dt;

```

# Math 72


Nb Executed tests: 2140

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.BrentSolverTest#testRootEndpoints

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BrentSolver.java b/org/apache/commons/math/analysis/solvers/BrentSolver.java
index 7fc090e..e0cb427 100644
--- a/org/apache/commons/math/analysis/solvers/BrentSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BrentSolver.java
@@ -112,7 +112,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {
         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
-            setResult(min, 0);
+            setResult(yMin, 0);
             return result;
         }
 
@@ -124,7 +124,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {
         // return the second endpoint if it is good enough
         double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
-            setResult(max, 0);
+            setResult(yMax, 0);
             return result;
         }
 

```

# Math 73


Nb Executed tests: 2140

Nb Failing tests: 1

>	org.apache.commons.math.analysis.solvers.BrentSolverTest#testBadEndpoints

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/BrentSolver.java b/org/apache/commons/math/analysis/solvers/BrentSolver.java
index e0cb427..4e95ed5 100644
--- a/org/apache/commons/math/analysis/solvers/BrentSolver.java
+++ b/org/apache/commons/math/analysis/solvers/BrentSolver.java
@@ -32,11 +32,6 @@ import org.apache.commons.math.analysis.UnivariateRealFunction;
  */
 public class BrentSolver extends UnivariateRealSolverImpl {
 
-    /** Error message for non-bracketing interval. */
-    private static final String NON_BRACKETING_MESSAGE =
-        "function values at endpoints do not have different signs.  " +
-        "Endpoints: [{0}, {1}], Values: [{2}, {3}]";
-
     /** Serializable version identifier */
     private static final long serialVersionUID = 7694577816772532779L;
 
@@ -133,11 +128,6 @@ public class BrentSolver extends UnivariateRealSolverImpl {
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
-        if (yMin * yMax > 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
-        }
-
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
 
@@ -186,7 +176,9 @@ public class BrentSolver extends UnivariateRealSolverImpl {
             } else {
                 // neither value is close to zero and min and max do not bracket root.
                 throw MathRuntimeException.createIllegalArgumentException(
-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+                        "function values at endpoints do not have different signs.  " +
+                        "Endpoints: [{0}, {1}], Values: [{2}, {3}]",
+                        min, max, yMin, yMax);
             }
         } else if (sign < 0){
             // solve using only the first endpoint as initial guess

```

## NopolC 

org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:225 (Suspicious rank: 16 (Ochiai), 17 (Ample), 17 (Tarantula))
```Java
((initial)<=(lower))||((!((1)!=(lower)))&&((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result)<(1)))
```

Nb Angelic value: 1

Nb analyzed Statement: 16

Execution time: 0:00:40.261000

Grid5000 node: chinqchint-24.lille.grid5000.fr


## Genprog 

org.apache.commons.math.analysis.solvers.BrentSolver:132 (Suspicious rank: 1 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
return solve(f, min, max)
```

Execution time: 0:00:43.821000

Grid5000 node : graphene-100.nancy.grid5000.fr

# Math 74


Nb Executed tests: 2131

Nb Failing tests: 1

>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#polynomial

## Human Patch 

```Java
diff --git a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
index 1bbad3e..70b2a2b 100644
--- a/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
+++ b/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
@@ -17,6 +17,8 @@
 
 package org.apache.commons.math.ode.nonstiff;
 
+import java.util.Arrays;
+
 import org.apache.commons.math.ode.DerivativeException;
 import org.apache.commons.math.ode.FirstOrderDifferentialEquations;
 import org.apache.commons.math.ode.IntegratorException;
@@ -242,16 +244,13 @@ public abstract class EmbeddedRungeKuttaIntegrator
         }
 
         if (firstTime) {
-          final double[] scale = new double[y0.length];
-          if (vecAbsoluteTolerance == null) {
-              for (int i = 0; i < scale.length; ++i) {
-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
-              }
-            } else {
-              for (int i = 0; i < scale.length; ++i) {
-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
-              }
-            }
+          final double[] scale;
+          if (vecAbsoluteTolerance != null) {
+            scale = vecAbsoluteTolerance;
+          } else {
+            scale = new double[y0.length];
+            Arrays.fill(scale, scalAbsoluteTolerance);
+          }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
           firstTime = false;

```

# Math 75


Nb Executed tests: 2135

Nb Failing tests: 1

>	org.apache.commons.math.stat.FrequencyTest#testPcts

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/Frequency.java b/org/apache/commons/math/stat/Frequency.java
index 68c8bf2..c45d728 100644
--- a/org/apache/commons/math/stat/Frequency.java
+++ b/org/apache/commons/math/stat/Frequency.java
@@ -300,7 +300,7 @@ public class Frequency implements Serializable {
      */
     @Deprecated
     public double getPct(Object v) {
-        return getPct((Comparable<?>) v);
+        return getCumPct((Comparable<?>) v);
     }
 
     /**

```

# Math 76


Nb Executed tests: 2135

Nb Failing tests: 2

>	org.apache.commons.math.linear.SingularValueSolverTest#testMath320A
>	org.apache.commons.math.linear.SingularValueSolverTest#testMath320B

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
index e418c08..6003ed6 100644
--- a/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
+++ b/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
@@ -159,28 +159,27 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
-                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
-                for (int i = 0; i < p; ++i) {
+                for (int i = 0; i < p - 1; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
+                    final double si = secondaryBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
-                    if (i < n - 1) {
-                        ei1 = eData[i + 1];
-                        final double si = secondaryBidiagonal[i];
-                        for (int j = 0; j < p; ++j) {
-                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
-                        }
-                    } else {
-                        for (int j = 0; j < p; ++j) {
-                            wi[j] = mi * ei0[j] / singularValues[j];
-                        }
+                    ei1 = eData[i + 1];
+                    for (int j = 0; j < p; ++j) {
+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                     }
                 }
-
+                // last row
+                final double lastMain = mainBidiagonal[p - 1];
+                final double[] wr1  = wData[p - 1];
+                for (int j = 0; j < p; ++j) {
+                    wr1[j] = ei1[j] * lastMain / singularValues[j];
+                }
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
                 }
@@ -248,26 +247,26 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
-                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
-                for (int i = 0; i < p; ++i) {
+                for (int i = 0; i < p - 1; ++i) {
                     final double mi = mainBidiagonal[i];
+                    final double si = secondaryBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
-                    if (i < m - 1) {
-                        ei1 = eData[i + 1];
-                        final double si = secondaryBidiagonal[i];
-                        for (int j = 0; j < p; ++j) {
-                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
-                        }
-                    } else {
-                        for (int j = 0; j < p; ++j) {
-                            wi[j] = mi * ei0[j] / singularValues[j];
-                        }
+                    ei1 = eData[i + 1];
+                    for (int j = 0; j < p; ++j) {
+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                     }
                 }
+                // last row
+                final double lastMain = mainBidiagonal[p - 1];
+                final double[] wr1  = wData[p - 1];
+                for (int j = 0; j < p; ++j) {
+                    wr1[j] = ei1[j] * lastMain / singularValues[j];
+                }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }

```

# Math 77


Nb Executed tests: 2129

Nb Failing tests: 2

>	org.apache.commons.math.linear.ArrayRealVectorTest#testBasicFunctions
>	org.apache.commons.math.linear.SparseRealVectorTest#testBasicFunctions

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/AbstractRealVector.java b/org/apache/commons/math/linear/AbstractRealVector.java
index ace4b8d..cf103c0 100644
--- a/org/apache/commons/math/linear/AbstractRealVector.java
+++ b/org/apache/commons/math/linear/AbstractRealVector.java
@@ -206,40 +206,6 @@ public abstract class AbstractRealVector implements RealVector {
     }
 
     /** {@inheritDoc} */
-    public double getNorm() {
-        double sum = 0;
-        Iterator<Entry> it = sparseIterator();
-        Entry e;
-        while (it.hasNext() && (e = it.next()) != null) {
-            final double value = e.getValue();
-            sum += value * value;
-        }
-        return Math.sqrt(sum);
-    }
-
-    /** {@inheritDoc} */
-    public double getL1Norm() {
-        double norm = 0;
-        Iterator<Entry> it = sparseIterator();
-        Entry e;
-        while (it.hasNext() && (e = it.next()) != null) {
-            norm += Math.abs(e.getValue());
-        }
-        return norm;
-    }
-
-    /** {@inheritDoc} */
-    public double getLInfNorm() {
-        double norm = 0;
-        Iterator<Entry> it = sparseIterator();
-        Entry e;
-        while (it.hasNext() && (e = it.next()) != null) {
-            norm = Math.max(norm, Math.abs(e.getValue()));
-        }
-        return norm;
-    }
-
-    /** {@inheritDoc} */
     public double getDistance(double[] v) throws IllegalArgumentException {
         return getDistance(new ArrayRealVector(v,false));
     }
diff --git a/org/apache/commons/math/linear/ArrayRealVector.java b/org/apache/commons/math/linear/ArrayRealVector.java
index 22d0a28..45c0919 100644
--- a/org/apache/commons/math/linear/ArrayRealVector.java
+++ b/org/apache/commons/math/linear/ArrayRealVector.java
@@ -694,7 +694,6 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable
     }
 
     /** {@inheritDoc} */
-    @Override
     public double getNorm() {
         double sum = 0;
         for (double a : data) {
@@ -704,7 +703,6 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable
     }
 
     /** {@inheritDoc} */
-    @Override
     public double getL1Norm() {
         double sum = 0;
         for (double a : data) {
@@ -714,11 +712,10 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable
     }
 
     /** {@inheritDoc} */
-    @Override
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
-            max = Math.max(max, Math.abs(a));
+            max += Math.max(max, Math.abs(a));
         }
         return max;
     }
diff --git a/org/apache/commons/math/linear/OpenMapRealVector.java b/org/apache/commons/math/linear/OpenMapRealVector.java
index eb5be1b..febea7a 100644
--- a/org/apache/commons/math/linear/OpenMapRealVector.java
+++ b/org/apache/commons/math/linear/OpenMapRealVector.java
@@ -495,6 +495,17 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV
         return max;
     }
 
+    /** {@inheritDoc} */
+    public double getL1Norm() {
+        double res = 0;
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            iter.advance();
+            res += Math.abs(iter.value());
+        }
+        return res;
+    }
+
     /**
      * Optimized method to compute LInfDistance.
      * @param v The vector to compute from
@@ -546,6 +557,28 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV
     }
 
     /** {@inheritDoc} */
+    public double getLInfNorm() {
+        double max = 0;
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            iter.advance();
+            max += iter.value();
+        }
+        return max;
+    }
+
+    /** {@inheritDoc} */
+    public double getNorm() {
+        double res = 0;
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            iter.advance();
+            res += iter.value() * iter.value();
+        }
+        return Math.sqrt(res);
+    }
+
+    /** {@inheritDoc} */
     public boolean isInfinite() {
         boolean infiniteFound = false;
         Iterator iter = entries.iterator();

```

# Math 78


Nb Executed tests: 2106

Nb Failing tests: 1

>	org.apache.commons.math.ode.events.EventStateTest#closeEvents

## Human Patch 

```Java
diff --git a/org/apache/commons/math/ode/events/EventState.java b/org/apache/commons/math/ode/events/EventState.java
index ff09646..44f6742 100644
--- a/org/apache/commons/math/ode/events/EventState.java
+++ b/org/apache/commons/math/ode/events/EventState.java
@@ -188,26 +187,6 @@ public class EventState {
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
-                    if (ga * gb > 0) {
-                        // this is a corner case:
-                        // - there was an event near ta,
-                        // - there is another event between ta and tb
-                        // - when ta was computed, convergence was reached on the "wrong side" of the interval
-                        // this implies that the real sign of ga is the same as gb, so we need to slightly
-                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
-                        // about bracketing
-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;
-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
-                            ta += epsilon;
-                            interpolator.setInterpolatedTime(ta);
-                            ga = handler.g(ta, interpolator.getInterpolatedState());
-                        }
-                        if (ga * gb > 0) {
-                            // this should never happen
-                            throw MathRuntimeException.createInternalError(null);
-                        }
-                    }
-                         
                     // variation direction, with respect to the integration direction
                     increasing = gb >= ga;
 
@@ -226,9 +205,16 @@ public class EventState {
                     final BrentSolver solver = new BrentSolver();
                     solver.setAbsoluteAccuracy(convergence);
                     solver.setMaximalIterationCount(maxIterationCount);
-                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
-                    if ((Math.abs(root - ta) <= convergence) &&
-                         (Math.abs(root - previousEventTime) <= convergence)) {
+                    double root;
+                    try {
+                        root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
+                    } catch (IllegalArgumentException iae) {
+                        // the interval did not really bracket a root
+                        root = Double.NaN;
+                    }
+                    if (Double.isNaN(root) ||
+                        ((Math.abs(root - ta) <= convergence) &&
+                         (Math.abs(root - previousEventTime) <= convergence))) {
                         // we have either found nothing or found (again ?) a past event, we simply ignore it
                         ta = tb;
                         ga = gb;

```

## NopolPC 

org.apache.commons.math.analysis.solvers.BrentSolver:282 (Suspicious rank: 8 (Ochiai), 8 (Ample), 8 (Tarantula))
```Java
(-1)<=(delta)
```

Nb Angelic value: 1

Nb analyzed Statement: 8

Execution time: 0:00:54.086000

Grid5000 node: chinqchint-14.lille.grid5000.fr


## Genprog 

org.apache.commons.math.ode.events.EventState:283 (Suspicious rank: 56 (Ochiai), 50 (Ample), 50 (Tarantula))
```Java
remove
```

Execution time: 0:02:21.006000

Grid5000 node : graphene-103.nancy.grid5000.fr

## Kali 

org.apache.commons.math.ode.events.EventState:283 (Suspicious rank: 56 (Ochiai), 50 (Ample), 50 (Tarantula))
```Java
remove
```

Execution time: 0:01:16.086000

Grid5000 node : graphene-74.nancy.grid5000.fr


# Math 79


Nb Executed tests: 2104

Nb Failing tests: 1

>	org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest#testPerformClusterAnalysisDegenerate

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MathUtils.java b/org/apache/commons/math/util/MathUtils.java
index ad77a56..46368dc 100644
--- a/org/apache/commons/math/util/MathUtils.java
+++ b/org/apache/commons/math/util/MathUtils.java
@@ -1621,9 +1621,9 @@ public final class MathUtils {
      * @return the L<sub>2</sub> distance between the two points
      */
     public static double distance(int[] p1, int[] p2) {
-      double sum = 0;
+      int sum = 0;
       for (int i = 0; i < p1.length; i++) {
-          final double dp = p1[i] - p2[i];
+          final int dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);

```

## NopolPC 

org.apache.commons.math.util.MathUtils:1627 (Suspicious rank: 26 (Ochiai), 24 (Ample), 24 (Tarantula))
```Java
(p2!=null)&&(!(((dp)<=((org.apache.commons.math.util.MathUtils.TWO_PI)-((org.apache.commons.math.util.MathUtils.FACTORIALS.length)+(org.apache.commons.math.util.MathUtils.FACTORIALS.length))))||(((org.apache.commons.math.util.MathUtils.FACTORIALS.length)+(org.apache.commons.math.util.MathUtils.FACTORIALS.length))<(dp))))
```

Nb Angelic value: 1

Nb analyzed Statement: 26

Execution time: 0:35:17.086000

Grid5000 node: chinqchint-2.lille.grid5000.fr


# Math 80


Nb Executed tests: 2102

Nb Failing tests: 1

>	org.apache.commons.math.linear.EigenDecompositionImplTest#testMathpbx02

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/EigenDecompositionImpl.java b/org/apache/commons/math/linear/EigenDecompositionImpl.java
index 9d1b797..3fc328d 100644
--- a/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ b/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
-            int j = 4 * (n - 1);
+            int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];

```

## NopolPC 

org.apache.commons.math.linear.EigenDecompositionImpl:1137 (Suspicious rank: 16 (Ochiai), 28 (Ample), 28 (Tarantula))
```Java
org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null
```

Nb Angelic value: 1

Nb analyzed Statement: 16

Execution time: 0:00:50.133000

Grid5000 node: chinqchint-11.lille.grid5000.fr


## Genprog 

org.apache.commons.math.linear.EigenDecompositionImpl:1139 (Suspicious rank: 18 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
tau = (g) * (dMin)
```

Execution time: 0:03:07.020000

Grid5000 node : griffon-1.nancy.grid5000.fr

## Kali 

org.apache.commons.math.linear.EigenDecompositionImpl:1136 (Suspicious rank: 15 (Ochiai), 5 (Ample), 5 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1137 (Suspicious rank: 16 (Ochiai), 28 (Ample), 28 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1139 (Suspicious rank: 18 (Ochiai), 3 (Ample), 3 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:840 (Suspicious rank: 110 (Ochiai), 124 (Ample), 124 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1133 (Suspicious rank: 195 (Ochiai), 125 (Ample), 125 (Tarantula))
```Java
remove
```

Execution time: 0:23:24.050000

Grid5000 node : griffon-56.nancy.grid5000.fr


# Math 81


Nb Executed tests: 2101

Nb Failing tests: 1

>	org.apache.commons.math.linear.EigenDecompositionImplTest#testMath308

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/EigenDecompositionImpl.java b/org/apache/commons/math/linear/EigenDecompositionImpl.java
index 3fc328d..53a40f0 100644
--- a/org/apache/commons/math/linear/EigenDecompositionImpl.java
+++ b/org/apache/commons/math/linear/EigenDecompositionImpl.java
@@ -595,12 +595,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {
         }
 
         final double dCurrent = main[m - 1];
-        final double lower = dCurrent - eCurrent;
-        work[lowerStart + m - 1] = lower;
-        lowerSpectra = Math.min(lowerSpectra, lower);
-        final double upper = dCurrent + eCurrent;
-        work[upperStart + m - 1] = upper;
-        upperSpectra = Math.max(upperSpectra, upper);
+        work[lowerStart + m - 1] = dCurrent - eCurrent;
+        work[upperStart + m - 1] = dCurrent + eCurrent;
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }
@@ -903,8 +899,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
-                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
@@ -1541,7 +1537,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
-                if (end - start > 3) {
+                if (end - start > 2) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {

```

## NopolPC 

org.apache.commons.math.linear.EigenDecompositionImpl:1540 (Suspicious rank: 10 (Ochiai), 14 (Ample), 14 (Tarantula))
```Java
(org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin)!=(b2)
```

Nb Angelic value: 1

Nb analyzed Statement: 10

Execution time: 0:00:51.503000

Grid5000 node: chinqchint-2.lille.grid5000.fr


## NopolC 

org.apache.commons.math.linear.EigenDecompositionImpl:1534 (Suspicious rank: 8 (Ochiai), 12 (Ample), 12 (Tarantula))
```Java
(org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE)<=(org.apache.commons.math.linear.EigenDecompositionImpl.this.lowerSpectra)
```

Nb Angelic value: 1

Nb analyzed Statement: 8

Execution time: 0:00:44.994000

Grid5000 node: chinqchint-27.lille.grid5000.fr


## Genprog 

org.apache.commons.math.linear.EigenDecompositionImpl:1541 (Suspicious rank: 11 (Ochiai), 15 (Ample), 15 (Tarantula))
```Java
remove
```

Execution time: 0:02:09.255000

Grid5000 node : graphene-1.nancy.grid5000.fr

## Kali 

org.apache.commons.math.linear.EigenDecompositionImpl:1540 (Suspicious rank: 10 (Ochiai), 14 (Ample), 14 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1541 (Suspicious rank: 11 (Ochiai), 15 (Ample), 15 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1477 (Suspicious rank: 17 (Ochiai), 22 (Ample), 22 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1481 (Suspicious rank: 19 (Ochiai), 27 (Ample), 27 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1517 (Suspicious rank: 40 (Ochiai), 41 (Ample), 41 (Tarantula))
```Java
remove
```

org.apache.commons.math.linear.EigenDecompositionImpl:1518 (Suspicious rank: 41 (Ochiai), 42 (Ample), 42 (Tarantula))
```Java
remove
```

Execution time: 0:21:58.785000

Grid5000 node : griffon-11.nancy.grid5000.fr


# Math 82


Nb Executed tests: 2056

Nb Failing tests: 1

>	org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath288

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/linear/SimplexSolver.java b/org/apache/commons/math/optimization/linear/SimplexSolver.java
index 60a1b3a..16d3bae 100644
--- a/org/apache/commons/math/optimization/linear/SimplexSolver.java
+++ b/org/apache/commons/math/optimization/linear/SimplexSolver.java
@@ -77,10 +77,9 @@ public class SimplexSolver extends AbstractLinearOptimizer {
         double minRatio = Double.MAX_VALUE;
         Integer minRatioPos = null;
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
-            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
-            final double entry = tableau.getEntry(i, col);
-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
-                final double ratio = rhs / entry;
+            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
+            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {
+                double ratio = rhs / tableau.getEntry(i, col);
                 if (ratio < minRatio) {
                     minRatio = ratio;
                     minRatioPos = i; 

```

## NopolPC 

org.apache.commons.math.optimization.linear.SimplexSolver:63 (Suspicious rank: 47 (Ochiai), 32 (Ample), 32 (Tarantula))
```Java
(0)!=(minValue)
```

Nb Angelic value: 1

Nb analyzed Statement: 47

Execution time: 0:19:01.288000

Grid5000 node: chimint-12.lille.grid5000.fr


## Genprog 

org.apache.commons.math.optimization.linear.SimplexSolver:63 (Suspicious rank: 47 (Ochiai), 32 (Ample), 32 (Tarantula))
```Java
remove
```

Execution time: 0:05:02.170000

Grid5000 node : graphene-103.nancy.grid5000.fr

## Kali 

org.apache.commons.math.optimization.linear.SimplexSolver:63 (Suspicious rank: 47 (Ochiai), 32 (Ample), 32 (Tarantula))
```Java
remove
```

Execution time: 0:02:24.165000

Grid5000 node : griffon-5.nancy.grid5000.fr


# Math 83


Nb Executed tests: 2055

Nb Failing tests: 1

>	org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath286

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/linear/SimplexTableau.java b/org/apache/commons/math/optimization/linear/SimplexTableau.java
index b387767..6cd5507 100644
--- a/org/apache/commons/math/optimization/linear/SimplexTableau.java
+++ b/org/apache/commons/math/optimization/linear/SimplexTableau.java
@@ -289,8 +289,7 @@ class SimplexTableau implements Serializable {
      */
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
-        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
-        for (int i = start; i < getHeight(); i++) {
+        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
@@ -338,11 +337,11 @@ class SimplexTableau implements Serializable {
      */
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
-      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
-      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
+      Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
+      double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
-          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
+           basicRow = getBasicRow(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0

```

# Math 84


Nb Executed tests: 2054

Nb Failing tests: 2

>	org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMinimizeMaximize
>	org.apache.commons.math.optimization.direct.MultiDirectionalTest#testMath283

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/direct/MultiDirectional.java b/org/apache/commons/math/optimization/direct/MultiDirectional.java
index 929560c..955d0d8 100644
--- a/org/apache/commons/math/optimization/direct/MultiDirectional.java
+++ b/org/apache/commons/math/optimization/direct/MultiDirectional.java
@@ -61,7 +60,6 @@ public class MultiDirectional extends DirectSearchOptimizer {
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
-        final RealConvergenceChecker checker = getConvergenceChecker();
         while (true) {
 
             incrementIterationsCounter();
@@ -93,16 +91,6 @@ public class MultiDirectional extends DirectSearchOptimizer {
                 return;
             }
 
-            // check convergence
-            final int iter = getIterations();
-            boolean converged = true;
-            for (int i = 0; i < simplex.length; ++i) {
-                converged &= checker.converged(iter, original[i], simplex[i]);
-            }
-            if (converged) {
-                return;
-            }
-
         }
 
     }

```

## Genprog 

org.apache.commons.math.optimization.direct.MultiDirectional:90 (Suspicious rank: 7 (Ochiai), 6 (Ample), 6 (Tarantula))
```Java
return 
```

Execution time: 0:05:54.614000

Grid5000 node : griffon-1.nancy.grid5000.fr

# Math 85


Nb Executed tests: 1983

Nb Failing tests: 1

>	org.apache.commons.math.distribution.NormalDistributionTest#testMath280

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java
index e6398f6..5b76415 100644
--- a/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java
+++ b/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java
@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
-        if (fa * fb > 0.0 ) {
+        if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       "number of iterations={0}, maximum iterations={1}, " +
                       "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +

```

## NopolC 

org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:198 (Suspicious rank: 46 (Ochiai), 38 (Ample), 38 (Tarantula))
```Java
(fa)==(maximumIterations)
```

Nb Angelic value: 1

Nb analyzed Statement: 46

Execution time: 0:00:42.239000

Grid5000 node: chinqchint-43.lille.grid5000.fr


## Genprog 

org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:199 (Suspicious rank: 1 (Ochiai), 2 (Ample), 2 (Tarantula))
```Java
remove
```

Execution time: 0:00:37.372000

Grid5000 node : graphene-104.nancy.grid5000.fr

## Kali 

org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:199 (Suspicious rank: 1 (Ochiai), 2 (Ample), 2 (Tarantula))
```Java
remove
```

org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:198 (Suspicious rank: 46 (Ochiai), 38 (Ample), 38 (Tarantula))
```Java
remove
```

Execution time: 0:05:53.615000

Grid5000 node : griffon-23.nancy.grid5000.fr


# Math 86


Nb Executed tests: 1894

Nb Failing tests: 2

>	org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274
>	org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
index 67e372f..39faa9a 100644
--- a/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
+++ b/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
@@ -111,6 +111,11 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {
 
             final double[] lI = lTData[i];
 
+            // check diagonal element
+            if (lTData[i][i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }
+
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -129,12 +134,6 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {
         for (int i = 0; i < order; ++i) {
 
             final double[] ltI = lTData[i];
-
-            // check diagonal element
-            if (ltI[i] < absolutePositivityThreshold) {
-                throw new NotPositiveDefiniteMatrixException();
-            }
-
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
 

```

# Math 87


Nb Executed tests: 1893

Nb Failing tests: 1

>	org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/linear/SimplexTableau.java b/org/apache/commons/math/optimization/linear/SimplexTableau.java
index b0d114e..a6d7419 100644
--- a/org/apache/commons/math/optimization/linear/SimplexTableau.java
+++ b/org/apache/commons/math/optimization/linear/SimplexTableau.java
@@ -272,10 +272,12 @@ class SimplexTableau implements Serializable {
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
-                row = i;
-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
-                return null;
+            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
+                if (row == null) {
+                    row = i;
+                } else {
+                    return null;
+                }
             }
         }
         return row;

```

## NopolPC 

org.apache.commons.math.optimization.linear.SimplexTableau:161 (Suspicious rank: 25 (Ochiai), 73 (Ample), 73 (Tarantula))
```Java
(org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)!=(1)
```

Nb Angelic value: 1

Nb analyzed Statement: 25

Execution time: 0:07:55.383000

Grid5000 node: chinqchint-2.lille.grid5000.fr


## NopolC 

org.apache.commons.math.optimization.linear.SimplexTableau:160 (Suspicious rank: 127 (Ochiai), 120 (Ample), 120 (Tarantula))
```Java
((1)!=(org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables))&&(!(restrictToNonNegative))
```

Nb Angelic value: 1

Nb analyzed Statement: 127

Execution time: 0:00:58.674000

Grid5000 node: chinqchint-24.lille.grid5000.fr


# Math 88


Nb Executed tests: 1880

Nb Failing tests: 1

>	org.apache.commons.math.optimization.linear.SimplexSolverTest#testMath272

## Human Patch 

```Java
diff --git a/org/apache/commons/math/optimization/linear/SimplexTableau.java b/org/apache/commons/math/optimization/linear/SimplexTableau.java
index a6d7419..ba57722 100644
--- a/org/apache/commons/math/optimization/linear/SimplexTableau.java
+++ b/org/apache/commons/math/optimization/linear/SimplexTableau.java
@@ -323,27 +321,39 @@ class SimplexTableau implements Serializable {
      */
     protected RealPointValuePair getSolution() {
         double[] coefficients = new double[getOriginalNumDecisionVariables()];
-        Integer basicRow =
-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
-        Set<Integer> basicRows = new HashSet<Integer>();
+        double mostNegative = getDecisionVariableValue(getOriginalNumDecisionVariables());
         for (int i = 0; i < coefficients.length; i++) {
-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);
-            if (basicRows.contains(basicRow)) {
-                // if multiple variables can take a given value 
-                // then we choose the first and set the rest equal to 0
-                coefficients[i] = 0;
-            } else {
-                basicRows.add(basicRow);
-                coefficients[i] =
-                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
-                    (restrictToNonNegative ? 0 : mostNegative);
-            }
+            coefficients[i] =
+                getDecisionVariableValue(i) - (restrictToNonNegative ? 0 : mostNegative); 
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
     }
 
     /**
+     * Get the value of the given decision variable.  This is not the actual
+     * value as it is guaranteed to be >= 0 and thus must be corrected before
+     * being returned to the user.
+     * 
+     * @param decisionVariable The index of the decision variable
+     * @return The value of the given decision variable.
+     */
+    protected double getDecisionVariableValue(final int decisionVariable) {
+      int col = getNumObjectiveFunctions() + decisionVariable;  
+      Integer basicRow = getBasicRow(col);
+      if (basicRow == null) {
+          return 0;
+      }
+      // if there are multiple variables that can take the value on the RHS
+      // then we'll give the first variable that value
+      for (int i = getNumObjectiveFunctions(); i < col; i++) {
+          if (tableau.getEntry(basicRow, i) == 1) {
+              return 0;
+          }
+      }
+      return getEntry(basicRow, getRhsOffset()); 
+  }
+
+    /**
      * Subtracts a multiple of one row from another.
      * <p>
      * After application of this operation, the following will hold:

```

## NopolPC 

org.apache.commons.math.optimization.linear.SimplexTableau:352 (Suspicious rank: 1 (Ochiai), 1 (Ample), 1 (Tarantula))
```Java
(org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)<(org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size())
```

Nb Angelic value: 1

Nb analyzed Statement: 1

Execution time: 0:00:39.755000

Grid5000 node: chimint-16.lille.grid5000.fr


# Math 89


Nb Executed tests: 1692

Nb Failing tests: 2

>	org.apache.commons.math.stat.FrequencyTest#testAddNonComparable
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/Frequency.java b/org/apache/commons/math/stat/Frequency.java
index 70d622d..237c2f6 100644
--- a/org/apache/commons/math/stat/Frequency.java
+++ b/org/apache/commons/math/stat/Frequency.java
@@ -101,17 +101,13 @@ public class Frequency implements Serializable {
      * </p>
      * 
      * @param v the value to add.
-     * @throws IllegalArgumentException if <code>v</code> is not Comparable, 
-     *         or is not comparable with previous entries
+     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
+     * @throws ClassCastException if <code>v</code> is not Comparable
      * @deprecated use {@link #addValue(Comparable)} instead
      */
     @Deprecated
     public void addValue(Object v) {
-        if (v instanceof Comparable<?>){
-            addValue((Comparable<?>) v);            
-        } else {
-            throw new IllegalArgumentException("Object must implement Comparable");
-        }
+        addValue((Comparable<?>) v);
     }
     
     /**

```

# Math 90


Nb Executed tests: 1692

Nb Failing tests: 2

>	org.apache.commons.math.stat.FrequencyTest#testAddNonComparable
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/Frequency.java b/org/apache/commons/math/stat/Frequency.java
index 237c2f6..a5b8d7b 100644
--- a/org/apache/commons/math/stat/Frequency.java
+++ b/org/apache/commons/math/stat/Frequency.java
@@ -101,26 +101,9 @@ public class Frequency implements Serializable {
      * </p>
      * 
      * @param v the value to add.
-     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
-     * @throws ClassCastException if <code>v</code> is not Comparable
-     * @deprecated use {@link #addValue(Comparable)} instead
+     * @throws IllegalArgumentException if <code>v</code> is not comparable.
      */
-    @Deprecated
     public void addValue(Object v) {
-        addValue((Comparable<?>) v);
-    }
-    
-    /**
-     * Adds 1 to the frequency count for v.
-     * <p>
-     * If other objects have already been added to this Frequency, v must
-     * be comparable to those that have already been added.
-     * </p>
-     * 
-     * @param v the value to add.
-     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
-     */
-    public void addValue(Comparable<?>v){
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());

```

# Math 91


Nb Executed tests: 1672

Nb Failing tests: 2

>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/apache/commons/math/fraction/Fraction.java b/org/apache/commons/math/fraction/Fraction.java
index d6d2f18..fa396fb 100644
--- a/org/apache/commons/math/fraction/Fraction.java
+++ b/org/apache/commons/math/fraction/Fraction.java
@@ -256,9 +256,20 @@ public class Fraction extends Number implements Comparable<Fraction> {
      *         than <tt>object</tt>, 0 if they are equal.
      */
     public int compareTo(Fraction object) {
-        long nOd = ((long) numerator) * object.denominator;
-        long dOn = ((long) denominator) * object.numerator;
-        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
+        int ret = 0;
+        
+        if (this != object) { 
+            double first = doubleValue();
+            double second = object.doubleValue();
+            
+            if (first < second) {
+                ret = -1;
+            } else if (first > second) {
+                ret = 1;
+            }
+        }
+        
+        return ret;
     }
     
     /**

```

# Math 92


Nb Executed tests: 1508

Nb Failing tests: 62

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolve
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testPredictorCoefficients
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testCorrectorCoefficients
>	junit.framework.TestSuite$1#warning
>	org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testCoefficients

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MathUtils.java b/org/apache/commons/math/util/MathUtils.java
index 03c92eb..8cb7590 100644
--- a/org/apache/commons/math/util/MathUtils.java
+++ b/org/apache/commons/math/util/MathUtils.java
@@ -181,42 +181,11 @@ public final class MathUtils {
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
-        // Use symmetry for large k
-        if (k > n / 2)
-            return binomialCoefficient(n, n - k);
-        
-        // We use the formula
-        // (n choose k) = n! / (n-k)! / k!
-        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
-        // which could be written
-        // (n choose k) == (n-1 choose k-1) * n / k
-        long result = 1;
-        if (n <= 61) {
-            // For n <= 61, the naive implementation cannot overflow.
-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
-                result = result * i / j;
-            }
-        } else if (n <= 66) {
-            // For n > 61 but n <= 66, the result cannot overflow,
-            // but we must take care not to overflow intermediate values.
-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
-                // We know that (result * i) is divisible by j,
-                // but (result * i) may overflow, so we split j:
-                // Filter out the gcd, d, so j/d and i/d are integer.
-                // result is divisible by (j/d) because (j/d)
-                // is relative prime to (i/d) and is a divisor of
-                // result * (i/d).
-                long d = gcd(i, j);
-                result = (result / (j / d)) * (i / d);
-            }
-        } else {
-            // For n > 66, a result overflow might occur, so we check
-            // the multiplication, taking care to not overflow
-            // unnecessary.
-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
-                long d = gcd(i, j);
-                result = mulAndCheck((result / (j / d)), (i / d));
-            }
+
+        long result = Math.round(binomialCoefficientDouble(n, k));
+        if (result == Long.MAX_VALUE) {
+            throw new ArithmeticException(
+                "result too large to represent in a long integer");
         }
         return result;
     }
@@ -244,33 +213,7 @@ public final class MathUtils {
      * @throws IllegalArgumentException if preconditions are not met.
      */
     public static double binomialCoefficientDouble(final int n, final int k) {
-        if (n < k) {
-            throw new IllegalArgumentException(
-                "must have n >= k for binomial coefficient (n,k)");
-        }
-        if (n < 0) {
-            throw new IllegalArgumentException(
-                "must have n >= 0 for binomial coefficient (n,k)");
-        }
-        if ((n == k) || (k == 0)) {
-            return 1d;
-        }
-        if ((k == 1) || (k == n - 1)) {
-            return n;
-        }
-        if (k > n/2) {
-            return binomialCoefficientDouble(n, n - k);
-        }
-        if (n < 67) {
-            return binomialCoefficient(n,k);
-        }
-        
-        double result = 1d;
-        for (int i = 1; i <= k; i++) {
-             result *= (double)(n - k + i) / (double)i;
-        }
-  
-        return Math.floor(result + 0.5);
+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
     }
     
     /**
@@ -304,28 +247,8 @@ public final class MathUtils {
             return 0;
         }
         if ((k == 1) || (k == n - 1)) {
-            return Math.log((double) n);
-        }
-        
-        /*
-         * For values small enough to do exact integer computation,
-         * return the log of the exact value 
-         */
-        if (n < 67) {  
-            return Math.log(binomialCoefficient(n,k));
+            return Math.log((double)n);
         }
-        
-        /*
-         * Return the log of binomialCoefficientDouble for values that will not
-         * overflow binomialCoefficientDouble
-         */
-        if (n < 1030) { 
-            return Math.log(binomialCoefficientDouble(n, k));
-        } 
-        
-        /*
-         * Sum logs for values that could overflow
-         */
         double logSum = 0;
 
         // n!/k!
@@ -338,7 +261,7 @@ public final class MathUtils {
             logSum -= Math.log((double)i);
         }
 
-        return logSum;      
+        return logSum;
     }
     
     /**

```

# Math 93


Nb Executed tests: 1504

Nb Failing tests: 62

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolve
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testPredictorCoefficients
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testCorrectorCoefficients
>	junit.framework.TestSuite$1#warning
>	org.apache.commons.math.util.MathUtilsTest#testFactorial
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testCoefficients

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MathUtils.java b/org/apache/commons/math/util/MathUtils.java
index 1389d5a..50ed22a 100644
--- a/org/apache/commons/math/util/MathUtils.java
+++ b/org/apache/commons/math/util/MathUtils.java
@@ -311,13 +311,6 @@ public final class MathUtils {
         }
         return true;
     }
-    
-    /** All long-representable factorials */
-    private static final long[] factorials = new long[] 
-       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,
-        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,
-        355687428096000l, 6402373705728000l, 121645100408832000l,
-        2432902008176640000l};
 
     /**
      * Returns n!. Shorthand for <code>n</code> <a
@@ -342,14 +335,12 @@ public final class MathUtils {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
-        if (n < 0) {
-            throw new IllegalArgumentException("must have n >= 0 for n!");
-        }
-        if (n > 20) {
+        long result = Math.round(factorialDouble(n));
+        if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
-                    "factorial value is too large to fit in a long");
+                "result too large to represent in a long integer");
         }
-        return factorials[n];
+        return result;
     }
 
     /**
@@ -376,9 +367,6 @@ public final class MathUtils {
         if (n < 0) {
             throw new IllegalArgumentException("must have n >= 0 for n!");
         }
-        if (n < 21) {
-            return factorial(n);
-        }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -399,9 +387,6 @@ public final class MathUtils {
         if (n < 0) {
             throw new IllegalArgumentException("must have n > 0 for n!");
         }
-        if (n < 21) {
-            return Math.log(factorial(n));
-        }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);

```

# Math 94


Nb Executed tests: 1501

Nb Failing tests: 62

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolve
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveDimensionErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testSolveSingularityErrors
>	org.apache.commons.math.linear.SingularValueSolverTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testUOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreColumns
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testDimensions
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testConditionNumber
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testAEqualUSVt
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMoreRows
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testVOrthogonal
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues1
>	org.apache.commons.math.linear.SingularValueDecompositionImplTest#testMatricesValues2
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testPredictorCoefficients
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testCorrectorCoefficients
>	junit.framework.TestSuite$1#warning
>	org.apache.commons.math.util.MathUtilsTest#testGcd
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testCoefficients

## Human Patch 

```Java
diff --git a/org/apache/commons/math/util/MathUtils.java b/org/apache/commons/math/util/MathUtils.java
index df71405..c5342ae 100644
--- a/org/apache/commons/math/util/MathUtils.java
+++ b/org/apache/commons/math/util/MathUtils.java
@@ -409,7 +409,7 @@ public final class MathUtils {
      * @since 1.1
      */
     public static int gcd(int u, int v) {
-        if ((u == 0) || (v == 0)) {
+        if (u * v == 0) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to

```

# Math 95


Nb Executed tests: 1301

Nb Failing tests: 49

>	org.apache.commons.math.distribution.FDistributionTest#testSmallDegreesOfFreedom
>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testPredictorCoefficients
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testCorrectorCoefficients
>	junit.framework.TestSuite$1#warning
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBackward
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testCoefficients

## Human Patch 

```Java
diff --git a/org/apache/commons/math/distribution/FDistributionImpl.java b/org/apache/commons/math/distribution/FDistributionImpl.java
index 59aeb07..3959403 100644
--- a/org/apache/commons/math/distribution/FDistributionImpl.java
+++ b/org/apache/commons/math/distribution/FDistributionImpl.java
@@ -141,13 +141,8 @@ public class FDistributionImpl
      * @return initial domain value
      */
     protected double getInitialDomain(double p) {
-        double ret = 1.0;
-        double d = getDenominatorDegreesOfFreedom();
-        if (d > 2.0) {
-            // use mean
-            ret = d / (d - 2.0);
-        }
-        return ret;
+        return getDenominatorDegreesOfFreedom() /
+            (getDenominatorDegreesOfFreedom() - 2.0);
     }
     
     /**

```

## Genprog 

org.apache.commons.math.distribution.FDistributionImpl:144 (Suspicious rank: 105 (Ochiai), 168 (Ample), 83 (Tarantula))
```Java
return 0.0
```

Execution time: 0:00:27.361000

Grid5000 node : graphene-104.nancy.grid5000.fr

# Math 96


Nb Executed tests: 1272

Nb Failing tests: 47

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.complex.ComplexTest#testMath221
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testPredictorCoefficients
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest#testCorrectorCoefficients
>	junit.framework.TestSuite$1#warning
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDimensionCheck
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testSmallStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testDecreasingSteps
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testBigStep
>	org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegratorTest#testCoefficients

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/Complex.java b/org/apache/commons/math/complex/Complex.java
index 8b622cb..16b3873 100644
--- a/org/apache/commons/math/complex/Complex.java
+++ b/org/apache/commons/math/complex/Complex.java
@@ -255,7 +255,10 @@ public class Complex implements Serializable  {
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
-                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
+                ret = (Double.doubleToRawLongBits(real) ==
+                        Double.doubleToRawLongBits(rhs.getReal())) &&
+                    (Double.doubleToRawLongBits(imaginary) ==
+                        Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception

```

# Math 97


Nb Executed tests: 1095

Nb Failing tests: 35

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.analysis.BrentSolverTest#testRootEndpoints

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/BrentSolver.java b/org/apache/commons/math/analysis/BrentSolver.java
index 57f64a9..01a9ee5 100644
--- a/org/apache/commons/math/analysis/BrentSolver.java
+++ b/org/apache/commons/math/analysis/BrentSolver.java
@@ -128,41 +128,20 @@ public class BrentSolver extends UnivariateRealSolverImpl {
         clearResult();
         verifyInterval(min, max);
         
-        double ret = Double.NaN;
-        
         double yMin = f.value(min);
         double yMax = f.value(max);
         
         // Verify bracketing
-        double sign = yMin * yMax;
-        if (sign > 0) {
-            // check if either value is close to a zero
-            if (Math.abs(yMin) <= functionValueAccuracy) {
-                setResult(min, 0);
-                ret = min;
-            } else if (Math.abs(yMax) <= functionValueAccuracy) {
-                setResult(max, 0);
-                ret = max;
-            } else {
-                // neither value is close to zero and min and max do not bracket root.
-                throw new IllegalArgumentException
-                ("Function values at endpoints do not have different signs." +
-                        "  Endpoints: [" + min + "," + max + "]" + 
-                        "  Values: [" + yMin + "," + yMax + "]");
-            }
-        } else if (sign < 0){
-            // solve using only the first endpoint as initial guess
-            ret = solve(min, yMin, max, yMax, min, yMin);
-        } else {
-            // either min or max is a root
-            if (yMin == 0.0) {
-                ret = min;
-            } else {
-                ret = max;
-            }
+        if (yMin * yMax >= 0) {
+            throw new IllegalArgumentException
+            ("Function values at endpoints do not have different signs." +
+                    "  Endpoints: [" + min + "," + max + "]" + 
+                    "  Values: [" + yMin + "," + yMax + "]");       
         }
 
-        return ret;
+        // solve using only the first endpoint as initial guess
+        return solve(min, yMin, max, yMax, min, yMin);
+
     }
         
     /**

```

## NopolPC 

org.apache.commons.math.analysis.BrentSolver:136 (Suspicious rank: 68 (Ochiai), 68 (Ample), 68 (Tarantula))
```Java
(min)<=(1)
```

Nb Angelic value: 1

Nb analyzed Statement: 68

Execution time: 0:00:34.149000

Grid5000 node: chinqchint-14.lille.grid5000.fr


## NopolC 

org.apache.commons.math.analysis.BrentSolver:135 (Suspicious rank: 90 (Ochiai), 95 (Ample), 87 (Tarantula))
```Java
(((yMin)<(yMax))&&((yMin * yMax) >= 0))||((min)==(yMin))
```

Nb Angelic value: 1

Nb analyzed Statement: 90

Execution time: 0:01:04.637000

Grid5000 node: chinqchint-16.lille.grid5000.fr


# Math 98


Nb Executed tests: 1094

Nb Failing tests: 36

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.linear.BigMatrixImplTest#testMath209
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.linear.RealMatrixImplTest#testMath209

## Human Patch 

```Java
diff --git a/org/apache/commons/math/linear/BigMatrixImpl.java b/org/apache/commons/math/linear/BigMatrixImpl.java
index 919a5ba..7cd61cb 100644
--- a/org/apache/commons/math/linear/BigMatrixImpl.java
+++ b/org/apache/commons/math/linear/BigMatrixImpl.java
@@ -988,7 +988,7 @@ public class BigMatrixImpl implements BigMatrix, Serializable {
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
-        final BigDecimal[] out = new BigDecimal[nRows];
+        final BigDecimal[] out = new BigDecimal[v.length];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
diff --git a/org/apache/commons/math/linear/RealMatrixImpl.java b/org/apache/commons/math/linear/RealMatrixImpl.java
index 3a717ff..7910644 100644
--- a/org/apache/commons/math/linear/RealMatrixImpl.java
+++ b/org/apache/commons/math/linear/RealMatrixImpl.java
@@ -776,7 +776,7 @@ public class RealMatrixImpl implements RealMatrix, Serializable {
         if (v.length != nCols) {
             throw new IllegalArgumentException("vector has wrong length");
         }
-        final double[] out = new double[nRows];
+        final double[] out = new double[v.length];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;

```

# Math 99


Nb Executed tests: 1180

Nb Failing tests: 35

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.analysis.BrentSolverTest#testRootEndpoints

## Human Patch 

```Java
diff --git a/org/apache/commons/math/analysis/BrentSolver.java b/org/apache/commons/math/analysis/BrentSolver.java
index da8b3f5..01a9ee5 100644
--- a/org/apache/commons/math/analysis/BrentSolver.java
+++ b/org/apache/commons/math/analysis/BrentSolver.java
@@ -128,41 +128,20 @@ public class BrentSolver extends UnivariateRealSolverImpl {
         clearResult();
         verifyInterval(min, max);
         
-        double ret = Double.NaN;
-        
         double yMin = f.value(min);
         double yMax = f.value(max);
         
         // Verify bracketing
-        double sign = yMin * yMax;
-        if (sign > 0) {
-            // check if either value is close to a zero
-            if (Math.abs(yMin) <= functionValueAccuracy) {
-                setResult(min, 0);
-                ret = min;
-            } else if (Math.abs(yMax) <= functionValueAccuracy) {
-                setResult(max, 0);
-                ret = max;
-            } else {
-                // neither value is close to zero and min and max do not bracket root.
-                throw new IllegalArgumentException
-                ("Function values at endpoints do not have different signs." +
-                        "  Endpoints: [" + min + "," + max + "]" + 
-                        "  Values: [" + yMin + "," + yMax + "]");
-            }
-        } else if (sign < 0){
-            // solve using only the first endpoint as initial guess
-            ret = solve(min, yMin, max, yMax, min, yMin);
-        } else {
-            // either min or max is a root
-            if (yMin == 0.0) {
-                ret = min;
-            } else {
-                ret = max;
-            }
+        if (yMin * yMax >= 0) {
+            throw new IllegalArgumentException
+            ("Function values at endpoints do not have different signs." +
+                    "  Endpoints: [" + min + "," + max + "]" + 
+                    "  Values: [" + yMin + "," + yMax + "]");       
         }
 
-        return ret;
+        // solve using only the first endpoint as initial guess
+        return solve(min, yMin, max, yMax, min, yMin);
+
     }
         
     /**

```

## NopolPC 

org.apache.commons.math.analysis.BrentSolver:136 (Suspicious rank: 68 (Ochiai), 68 (Ample), 68 (Tarantula))
```Java
(min)<=(1)
```

Nb Angelic value: 1

Nb analyzed Statement: 68

Execution time: 0:00:36.213000

Grid5000 node: chimint-1.lille.grid5000.fr


## NopolC 

org.apache.commons.math.analysis.BrentSolver:135 (Suspicious rank: 90 (Ochiai), 95 (Ample), 87 (Tarantula))
```Java
((!((1)<(min)))||((yMax)<=(org.apache.commons.math.analysis.BrentSolver.serialVersionUID)))&&((yMin * yMax) >= 0)
```

Nb Angelic value: 1

Nb analyzed Statement: 90

Execution time: 0:01:05.160000

Grid5000 node: chinqchint-14.lille.grid5000.fr


# Math 100


Nb Executed tests: 1179

Nb Failing tests: 35

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.estimation.GaussNewtonEstimatorTest#testBoundParameters
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative

## Human Patch 

```Java
diff --git a/org/apache/commons/math/estimation/AbstractEstimator.java b/org/apache/commons/math/estimation/AbstractEstimator.java
index 8e5fe1a..19e06a0 100644
--- a/org/apache/commons/math/estimation/AbstractEstimator.java
+++ b/org/apache/commons/math/estimation/AbstractEstimator.java
@@ -163,7 +163,7 @@ public abstract class AbstractEstimator implements Estimator {
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
-        final int cols = problem.getUnboundParameters().length;
+        final int cols = problem.getAllParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
@@ -199,12 +199,12 @@ public abstract class AbstractEstimator implements Estimator {
     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
-        int p = problem.getUnboundParameters().length;
+        int p = problem.getAllParameters().length;
         if (m <= p) {
             throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
-        double[] errors = new double[problem.getUnboundParameters().length];
+        double[] errors = new double[problem.getAllParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {

```

# Math 101


Nb Executed tests: 1177

Nb Failing tests: 36

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testEpsilonLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testDoubleConstructor
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testDigitLimitConstructor
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testGoldenRatio
>	org.apache.commons.math.fraction.FractionTest#testIntegerOverflow
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.complex.FrenchComplexFormatTest#testForgottenImaginaryCharacter
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.complex.ComplexFormatTest#testForgottenImaginaryCharacter

## Human Patch 

```Java
diff --git a/org/apache/commons/math/complex/ComplexFormat.java b/org/apache/commons/math/complex/ComplexFormat.java
index 0757d9b..c22d873 100644
--- a/org/apache/commons/math/complex/ComplexFormat.java
+++ b/org/apache/commons/math/complex/ComplexFormat.java
@@ -374,9 +374,7 @@ public class ComplexFormat extends Format implements Serializable {
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
-        if ((startIndex >= source.length()) ||
-            (endIndex > source.length()) ||
-            source.substring(startIndex, endIndex).compareTo(
+        if (source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
             // character examined.

```

# Math 102


Nb Executed tests: 1146

Nb Failing tests: 35

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testCostExceptions
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquareLargeTestStatistic
>	org.apache.commons.math.stat.inference.ChiSquareFactoryTest#testChiSquare
>	org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquareLargeTestStatistic
>	org.apache.commons.math.stat.inference.TestUtilsTest#testChiSquare
>	org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquareLargeTestStatistic
>	org.apache.commons.math.stat.inference.ChiSquareTestTest#testChiSquare

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java b/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java
index 984d56d..137d4c5 100644
--- a/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java
+++ b/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java
@@ -63,6 +58,8 @@ public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {
      */
     public double chiSquare(double[] expected, long[] observed)
         throws IllegalArgumentException {
+        double sumSq = 0.0d;
+        double dev = 0.0d;
         if ((expected.length < 2) || (expected.length != observed.length)) {
             throw new IllegalArgumentException(
                     "observed, expected array lengths incorrect");
@@ -71,38 +68,14 @@ public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {
             throw new IllegalArgumentException(
                 "observed counts must be non-negative and expected counts must be postive");
         }
-        double sumExpected = 0d;
-        double sumObserved = 0d;
-        for (int i = 0; i < observed.length; i++) {
-            sumExpected += expected[i];
-            sumObserved += observed[i];
-        }
-        double ratio = 1.0d;
-        boolean rescale = false;
-        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
-            ratio = sumObserved / sumExpected;
-            rescale = true;
-        }
-        double sumSq = 0.0d;
-        double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
-            if (rescale) {
-                dev = ((double) observed[i] - ratio * expected[i]);
-                sumSq += dev * dev / (ratio * expected[i]);
-            } else {
-                dev = ((double) observed[i] - expected[i]);
-                sumSq += dev * dev / expected[i];
-            }
+            dev = ((double) observed[i] - expected[i]);
+            sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }
 
     /**
-     * {@inheritDoc}
-     * <p><strong>Note: </strong>This implementation rescales the 
-     * <code>expected</code> array if necessary to ensure that the sum of the
-     * expected and observed counts are equal.</p>
-     * 
      * @param observed array of observed frequency counts
      * @param expected array of exptected frequency counts
      * @return p-value

```

# Math 103


Nb Executed tests: 1014

Nb Failing tests: 29

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.distribution.NormalDistributionTest#testExtremeValues

## Human Patch 

```Java
diff --git a/org/apache/commons/math/distribution/NormalDistributionImpl.java b/org/apache/commons/math/distribution/NormalDistributionImpl.java
index a08eac5..ff54236 100644
--- a/org/apache/commons/math/distribution/NormalDistributionImpl.java
+++ b/org/apache/commons/math/distribution/NormalDistributionImpl.java
@@ -101,23 +100,11 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution
      * For this disbution, X, this method returns P(X &lt; <code>x</code>).
      * @param x the value at which the CDF is evaluated.
      * @return CDF evaluted at <code>x</code>. 
-     * @throws MathException if the algorithm fails to converge; unless
-     * x is more than 20 standard deviations from the mean, in which case the
-     * convergence exception is caught and 0 or 1 is returned.
+     * @throws MathException if the algorithm fails to converge.
      */
     public double cumulativeProbability(double x) throws MathException {
-        try {
-            return 0.5 * (1.0 + Erf.erf((x - mean) /
-                    (standardDeviation * Math.sqrt(2.0))));
-        } catch (MaxIterationsExceededException ex) {
-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
-                return 0.0d;
-            } else if (x > (mean + 20 * standardDeviation)) {
-                return 1.0d;
-            } else {
-                throw ex;
-            }
-        }
+        return 0.5 * (1.0 + Erf.erf((x - mean) /
+                (standardDeviation * Math.sqrt(2.0))));
     }
     
     /**

```

# Math 104


Nb Executed tests: 1003

Nb Failing tests: 29

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.optimization.MultiDirectionalTest#testRosenbrock
>	org.apache.commons.math.optimization.MultiDirectionalTest#testPowell
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative
>	org.apache.commons.math.special.GammaTest#testRegularizedGammaPositivePositive

## Human Patch 

```Java
diff --git a/org/apache/commons/math/special/Beta.java b/org/apache/commons/math/special/Beta.java
index 904e156..4239c25 100644
--- a/org/apache/commons/math/special/Beta.java
+++ b/org/apache/commons/math/special/Beta.java
@@ -33,7 +33,7 @@ public class Beta implements Serializable {
     private static final long serialVersionUID = -3833485397404128220L;
 
     /** Maximum allowed numerical error. */
-    private static final double DEFAULT_EPSILON = 10e-15;
+    private static final double DEFAULT_EPSILON = 10e-9;
 
     /**
      * Default constructor.  Prohibit instantiation.
diff --git a/org/apache/commons/math/special/Gamma.java b/org/apache/commons/math/special/Gamma.java
index ba2c4db..8c565cb 100644
--- a/org/apache/commons/math/special/Gamma.java
+++ b/org/apache/commons/math/special/Gamma.java
@@ -34,7 +34,7 @@ public class Gamma implements Serializable {
     private static final long serialVersionUID = -6587513359895466954L;
 
     /** Maximum allowed numerical error. */
-    private static final double DEFAULT_EPSILON = 10e-15;
+    private static final double DEFAULT_EPSILON = 10e-9;
 
     /** Lanczos coefficients */
     private static double[] lanczos =

```

## NopolC 

org.apache.commons.math.special.Gamma:162 (Suspicious rank: 88 (Ochiai), 116 (Ample), 88 (Tarantula))
```Java
(!((x)<(1)))&&(((a >= 1.0) && (x > a))||((1)==(a)))
```

Nb Angelic value: 1

Nb analyzed Statement: 88

Execution time: 0:01:21.715000

Grid5000 node: chimint-14.lille.grid5000.fr


# Math 105


Nb Executed tests: 887

Nb Failing tests: 27

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.stat.regression.SimpleRegressionTest#testSSENonNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative

## Human Patch 

```Java
diff --git a/org/apache/commons/math/stat/regression/SimpleRegression.java b/org/apache/commons/math/stat/regression/SimpleRegression.java
index d9fa592..c105a41 100644
--- a/org/apache/commons/math/stat/regression/SimpleRegression.java
+++ b/org/apache/commons/math/stat/regression/SimpleRegression.java
@@ -261,7 +246,7 @@ public class SimpleRegression implements Serializable {
      * @return sum of squared errors associated with the regression model
      */
     public double getSumSquaredErrors() {
-        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
+        return sumYY - sumXY * sumXY / sumXX;
     }
 
     /**

```

## NopolPC 

org.apache.commons.math.stat.regression.SimpleRegression:107 (Suspicious rank: 69 (Ochiai), 72 (Ample), 72 (Tarantula))
```Java
(((y)<=(x))&&((y)<=(x)))||(!((1)<(x)))
```

Nb Angelic value: 1

Nb analyzed Statement: 69

Execution time: 0:00:26.426000

Grid5000 node: chinqchint-14.lille.grid5000.fr


# Math 106


Nb Executed tests: 875

Nb Failing tests: 27

>	org.apache.commons.math.fraction.FractionTest#testFloatValue
>	org.apache.commons.math.fraction.FractionTest#testAbs
>	org.apache.commons.math.fraction.FractionTest#testAdd
>	org.apache.commons.math.fraction.FractionTest#testSubtract
>	org.apache.commons.math.fraction.FractionTest#testReciprocal
>	org.apache.commons.math.fraction.FractionTest#testGetReducedFraction
>	org.apache.commons.math.fraction.FractionTest#testConstructorDouble
>	org.apache.commons.math.fraction.FractionTest#testCompareTo
>	org.apache.commons.math.fraction.FractionTest#testLongValue
>	org.apache.commons.math.fraction.FractionTest#testIntValue
>	org.apache.commons.math.fraction.FractionTest#testDivide
>	org.apache.commons.math.fraction.FractionTest#testMultiply
>	org.apache.commons.math.fraction.FractionTest#testEqualsAndHashCode
>	org.apache.commons.math.fraction.FractionTest#testNegate
>	org.apache.commons.math.fraction.FractionTest#testDoubleValue
>	org.apache.commons.math.fraction.FractionTest#testConstructor
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatImproper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProper
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParse
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatZero
>	org.apache.commons.math.fraction.FractionFormatTest#testFormatNegative
>	org.apache.commons.math.fraction.FractionFormatTest#testParseProperInvalidMinus
>	org.apache.commons.math.fraction.FractionFormatTest#testParseInteger
>	org.apache.commons.math.fraction.FractionFormatTest#testFormat
>	org.apache.commons.math.fraction.FractionFormatTest#testParseNegative

## Human Patch 

```Java
diff --git a/org/apache/commons/math/fraction/ProperFractionFormat.java b/org/apache/commons/math/fraction/ProperFractionFormat.java
index a98b665..5dfa386 100644
--- a/org/apache/commons/math/fraction/ProperFractionFormat.java
+++ b/org/apache/commons/math/fraction/ProperFractionFormat.java
@@ -161,12 +152,6 @@ public class ProperFractionFormat extends FractionFormat {
             pos.setIndex(initialIndex);
             return null;
         }
-        
-        if (num.intValue() < 0) {
-            // minus signs should be leading, invalid expression
-            pos.setIndex(initialIndex);
-            return null;
-        }
 
         // parse '/'
         int startIndex = pos.getIndex();
@@ -200,12 +185,6 @@ public class ProperFractionFormat extends FractionFormat {
             pos.setIndex(initialIndex);
             return null;
         }
-        
-        if (den.intValue() < 0) {
-            // minus signs must be leading, invalid
-            pos.setIndex(initialIndex);
-            return null;
-        }
 
         int w = whole.intValue();
         int n = num.intValue();

```

# Time 1


Nb Executed tests: 12128

Nb Failing tests: 4

>	org.joda.time.TestPartial_Constructors#testConstructorEx7_TypeArray_intArray
>	org.joda.time.TestPartial_Constructors#testConstructorEx7_TypeArray_intArray
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestPartial_Constructors#testConstructorEx7_TypeArray_intArray

## Human Patch 

```Java
diff --git a/org/joda/time/Partial.java b/org/joda/time/Partial.java
index 6ff2771..3b84fdc 100644
--- a/org/joda/time/Partial.java
+++ b/org/joda/time/Partial.java
@@ -214,20 +214,11 @@ public final class Partial
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
-                if (loopUnitField.isSupported() == false) {
-                    if (lastUnitField.isSupported()) {
-                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
-                                        types[i - 1].getName() + " < " + loopType.getName());
-                    } else {
-                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
-                                        types[i - 1].getName() + " and " + loopType.getName());
-                    }
-                }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
-                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
+                } else if (compare == 0) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException("Types array must not contain duplicate: " +
diff --git a/org/joda/time/field/UnsupportedDurationField.java b/org/joda/time/field/UnsupportedDurationField.java
index bf44e01..7e0ce57 100644
--- a/org/joda/time/field/UnsupportedDurationField.java
+++ b/org/joda/time/field/UnsupportedDurationField.java
@@ -224,6 +224,9 @@ public final class UnsupportedDurationField extends DurationField implements Ser
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
+        if (durationField.isSupported()) {
+            return 1;
+        }
         return 0;
     }
 

```

# Time 2


Nb Executed tests: 12128

Nb Failing tests: 4

>	org.joda.time.TestPartial_Basics#testWith_baseAndArgHaveNoRange
>	org.joda.time.TestPartial_Basics#testWith_baseAndArgHaveNoRange
>	org.joda.time.TestPartial_Basics#testWith_baseAndArgHaveNoRange
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/joda/time/Partial.java b/org/joda/time/Partial.java
index 3b84fdc..8e8e603 100644
--- a/org/joda/time/Partial.java
+++ b/org/joda/time/Partial.java
@@ -215,14 +215,13 @@ public final class Partial
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
-                if (compare < 0) {
+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
                 } else if (compare == 0) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());
                         }
                     } else {
                         if (loopType.getRangeDurationType() == null) {
@@ -236,8 +235,7 @@ public final class Partial
                                     types[i - 1].getName() + " < " + loopType.getName());
                         }
                         if (lastRangeField.compareTo(loopRangeField) == 0) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());
                         }
                     }
                 }
@@ -446,9 +444,6 @@ public final class Partial
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
-                            if (fieldType.getRangeDurationType() == null) {
-                                break;
-                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
diff --git a/org/joda/time/field/UnsupportedDurationField.java b/org/joda/time/field/UnsupportedDurationField.java
index 7e0ce57..bf44e01 100644
--- a/org/joda/time/field/UnsupportedDurationField.java
+++ b/org/joda/time/field/UnsupportedDurationField.java
@@ -224,9 +224,6 @@ public final class UnsupportedDurationField extends DurationField implements Ser
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
-        if (durationField.isSupported()) {
-            return 1;
-        }
         return 0;
     }
 

```

# Time 3


Nb Executed tests: 12119

Nb Failing tests: 16

>	org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddYears_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddDays_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddWeeks_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAdd_DurationFieldType_int_dstOverlapWinter_addZero
>	org.joda.time.TestMutableDateTime_Adds#testAddMonths_int_dstOverlapWinter_addZero
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/joda/time/MutableDateTime.java b/org/joda/time/MutableDateTime.java
index 9aa8602..237b256 100644
--- a/org/joda/time/MutableDateTime.java
+++ b/org/joda/time/MutableDateTime.java
@@ -636,9 +637,7 @@ public class MutableDateTime
         if (type == null) {
             throw new IllegalArgumentException("Field must not be null");
         }
-        if (amount != 0) {
-            setMillis(type.getField(getChronology()).add(getMillis(), amount));
-        }
+        setMillis(type.getField(getChronology()).add(getMillis(), amount));
     }
 
     //-----------------------------------------------------------------------
@@ -659,9 +658,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
-        if (years != 0) {
-            setMillis(getChronology().years().add(getMillis(), years));
-        }
+        setMillis(getChronology().years().add(getMillis(), years));
     }
 
     //-----------------------------------------------------------------------
@@ -682,9 +679,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
-        if (weekyears != 0) {
-            setMillis(getChronology().weekyears().add(getMillis(), weekyears));
-        }
+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));
     }
 
     //-----------------------------------------------------------------------
@@ -705,9 +700,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
-        if (months != 0) {
-            setMillis(getChronology().months().add(getMillis(), months));
-        }
+        setMillis(getChronology().months().add(getMillis(), months));
     }
 
     //-----------------------------------------------------------------------
@@ -728,9 +721,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
-        if (weeks != 0) {
-            setMillis(getChronology().weeks().add(getMillis(), weeks));
-        }
+        setMillis(getChronology().weeks().add(getMillis(), weeks));
     }
 
     //-----------------------------------------------------------------------
@@ -771,9 +762,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
-        if (days != 0) {
-            setMillis(getChronology().days().add(getMillis(), days));
-        }
+        setMillis(getChronology().days().add(getMillis(), days));
     }
 
     //-----------------------------------------------------------------------
@@ -794,9 +783,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
-        if (hours != 0) {
-            setMillis(getChronology().hours().add(getMillis(), hours));
-        }
+        setMillis(getChronology().hours().add(getMillis(), hours));
     }
     
     //-----------------------------------------------------------------------
@@ -827,9 +814,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
-        if (minutes != 0) {
-            setMillis(getChronology().minutes().add(getMillis(), minutes));
-        }
+        setMillis(getChronology().minutes().add(getMillis(), minutes));
     }
 
     //-----------------------------------------------------------------------
@@ -860,9 +845,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
-        if (seconds != 0) {
-            setMillis(getChronology().seconds().add(getMillis(), seconds));
-        }
+        setMillis(getChronology().seconds().add(getMillis(), seconds));
     }
 
     //-----------------------------------------------------------------------
@@ -895,9 +878,7 @@ public class MutableDateTime
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
-        if (millis != 0) {
-            setMillis(getChronology().millis().add(getMillis(), millis));
-        }
+        setMillis(getChronology().millis().add(getMillis(), millis));
     }
 
     //-----------------------------------------------------------------------

```

# Time 4


Nb Executed tests: 12047

Nb Failing tests: 4

>	org.joda.time.TestPartial_Basics#testWith3
>	org.joda.time.TestPartial_Basics#testWith3
>	org.joda.time.TestPartial_Basics#testWith3
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/joda/time/Partial.java b/org/joda/time/Partial.java
index 8e8e603..aaf0a0f 100644
--- a/org/joda/time/Partial.java
+++ b/org/joda/time/Partial.java
@@ -459,9 +459,8 @@ public final class Partial
             newValues[i] = value;
             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
-            // use public constructor to ensure full validation
-            // this isn't overly efficient, but is safe
-            Partial newPartial = new Partial(newTypes, newValues, iChronology);
+            
+            Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }

```

# Time 5


Nb Executed tests: 12044

Nb Failing tests: 10

>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months1
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_months2
>	org.joda.time.TestPeriod_Basics#testNormalizedStandard_periodType_monthsWeeks

## Human Patch 

```Java
diff --git a/org/joda/time/Period.java b/org/joda/time/Period.java
index 5ea67a7..5b36bc5 100644
--- a/org/joda/time/Period.java
+++ b/org/joda/time/Period.java
@@ -1614,30 +1614,23 @@ public final class Period
      * @since 1.5
      */
     public Period normalizedStandard(PeriodType type) {
-        type = DateTimeUtils.getPeriodType(type);
         long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
         millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
         millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
         millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
         millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
-        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
+        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
-            long totalMonths = years * 12L + months;
-            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
-                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
-                result = result.withYears(normalizedYears);
-                totalMonths = totalMonths - (normalizedYears * 12);
-            }
-            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
-                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
-                result = result.withMonths(normalizedMonths);
-                totalMonths = totalMonths - normalizedMonths;
+            years = FieldUtils.safeAdd(years, months / 12);
+            months = months % 12;
+            if (years != 0) {
+                result = result.withYears(years);
             }
-            if (totalMonths != 0) {
-                throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString());
+            if (months != 0) {
+                result = result.withMonths(months);
             }
         }
         return result;

```

# Time 6


Nb Executed tests: 11999

Nb Failing tests: 16

>	org.joda.time.chrono.TestGJDate#test_cutoverPreZero
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover
>	junit.framework.TestSuite$1#warning
>	org.joda.time.chrono.TestGJDate#test_cutoverPreZero
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover
>	org.joda.time.chrono.TestGJDate#test_cutoverPreZero
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToZero_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusYears_positiveToNegative_crossCutover
>	org.joda.time.chrono.TestGJDate#test_plusWeekyears_positiveToZero_crossCutover

## Human Patch 

```Java
diff --git a/org/joda/time/chrono/GJChronology.java b/org/joda/time/chrono/GJChronology.java
index d1556f5..960fe47 100644
--- a/org/joda/time/chrono/GJChronology.java
+++ b/org/joda/time/chrono/GJChronology.java
@@ -193,10 +192,6 @@ public final class GJChronology extends AssembledChronology {
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
-            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
-            if (cutoverDate.getYear() <= 0) {
-                throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01.");
-            }
         }
 
         GJChronology chrono;
@@ -980,17 +975,6 @@ public final class GJChronology extends AssembledChronology {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
-                        if (iConvertByWeekyear) {
-                            int wyear = iGregorianChronology.weekyear().get(instant);
-                            if (wyear <= 0) {
-                                instant = iGregorianChronology.weekyear().add(instant, -1);
-                            }
-                        } else {
-                            int year = iGregorianChronology.year().get(instant);
-                            if (year <= 0) {
-                                instant = iGregorianChronology.year().add(instant, -1);
-                            }
-                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
@@ -1013,17 +996,6 @@ public final class GJChronology extends AssembledChronology {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
-                        if (iConvertByWeekyear) {
-                            int wyear = iGregorianChronology.weekyear().get(instant);
-                            if (wyear <= 0) {
-                                instant = iGregorianChronology.weekyear().add(instant, -1);
-                            }
-                        } else {
-                            int year = iGregorianChronology.year().get(instant);
-                            if (year <= 0) {
-                                instant = iGregorianChronology.year().add(instant, -1);
-                            }
-                        }
                         instant = gregorianToJulian(instant);
                     }
                 }

```

# Time 7


Nb Executed tests: 11945

Nb Failing tests: 7

>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear
>	junit.framework.TestSuite$1#warning
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_newYork_startOfYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29_tokyo_endOfYear

## Human Patch 

```Java
diff --git a/org/joda/time/format/DateTimeFormatter.java b/org/joda/time/format/DateTimeFormatter.java
index 913d036..553b035 100644
--- a/org/joda/time/format/DateTimeFormatter.java
+++ b/org/joda/time/format/DateTimeFormatter.java
@@ -705,12 +703,11 @@ public class DateTimeFormatter {
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
-        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);
+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {

```

# Time 8


Nb Executed tests: 11915

Nb Failing tests: 4

>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index a127604..afa75d7 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -276,17 +258,14 @@ public abstract class DateTimeZone implements Serializable {
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException("Hours out of range: " + hoursOffset);
         }
-        if (minutesOffset < -59 || minutesOffset > 59) {
+        if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);
         }
-        if (hoursOffset > 0 && minutesOffset < 0) {
-            throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset);
-        }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
-                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);
+                minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }

```

# Time 9


Nb Executed tests: 11915

Nb Failing tests: 4

>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestDateTimeZone#testForOffsetHoursMinutes_int_int

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index afa75d7..f62ab9c 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -32,6 +32,7 @@ import org.joda.convert.FromString;
 import org.joda.convert.ToString;
 import org.joda.time.chrono.BaseChronology;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.format.DateTimeFormat;
 import org.joda.time.format.DateTimeFormatter;
 import org.joda.time.format.DateTimeFormatterBuilder;
 import org.joda.time.format.FormatUtils;
@@ -92,8 +93,6 @@ public abstract class DateTimeZone implements Serializable {
 
     /** The time zone for Universal Coordinated Time */
     public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0);
-    /** Maximum offset. */
-    private static final int MAX_MILLIS = (86400 * 1000) - 1;
 
     /** The instance that is providing time zones. */
     private static Provider cProvider;
@@ -255,19 +254,16 @@ public abstract class DateTimeZone implements Serializable {
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
-        if (hoursOffset < -23 || hoursOffset > 23) {
-            throw new IllegalArgumentException("Hours out of range: " + hoursOffset);
-        }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);
         }
         int offset = 0;
         try {
-            int hoursInMinutes = hoursOffset * 60;
+            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
             if (hoursInMinutes < 0) {
-                minutesOffset = hoursInMinutes - minutesOffset;
+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
             } else {
-                minutesOffset = hoursInMinutes + minutesOffset;
+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
@@ -279,13 +275,10 @@ public abstract class DateTimeZone implements Serializable {
     /**
      * Gets a time zone instance for the specified offset to UTC in milliseconds.
      *
-     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999
+     * @param millisOffset  the offset in millis from UTC
      * @return the DateTimeZone object for the offset
      */
     public static DateTimeZone forOffsetMillis(int millisOffset) {
-        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
-            throw new IllegalArgumentException("Millis out of range: " + millisOffset);
-        }
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }

```

# Time 10


Nb Executed tests: 11867

Nb Failing tests: 7

>	org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
>	org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
>	org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
>	org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
>	org.joda.time.TestDays#testFactory_daysBetween_RPartial_MonthDay
>	org.joda.time.TestMonths#testFactory_monthsBetween_RPartial_MonthDay
>	junit.framework.TestSuite$1#warning

## Human Patch 

```Java
diff --git a/org/joda/time/base/BaseSingleFieldPeriod.java b/org/joda/time/base/BaseSingleFieldPeriod.java
index 839d3b8..79283b5 100644
--- a/org/joda/time/base/BaseSingleFieldPeriod.java
+++ b/org/joda/time/base/BaseSingleFieldPeriod.java
@@ -48,8 +48,6 @@ public abstract class BaseSingleFieldPeriod
 
     /** Serialization version. */
     private static final long serialVersionUID = 9386874258972L;
-    /** The start of 1972. */
-    private static final long START_1972 = 2L * 365L * 86400L * 1000L;
 
     /** The period in the units of this period. */
     private volatile int iPeriod;
@@ -102,7 +100,7 @@ public abstract class BaseSingleFieldPeriod
             throw new IllegalArgumentException("ReadablePartial objects must be contiguous");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
-        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));
+        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
         return values[0];
     }
 

```

# Time 11


Nb Executed tests: 11852

Nb Failing tests: 4

>	org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder
>	org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder
>	junit.framework.TestSuite$1#warning
>	org.joda.time.tz.TestCompiler#testDateTimeZoneBuilder

## Human Patch 

```Java
diff --git a/org/joda/time/tz/ZoneInfoCompiler.java b/org/joda/time/tz/ZoneInfoCompiler.java
index 64da5ea..6efe071 100644
--- a/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/org/joda/time/tz/ZoneInfoCompiler.java
@@ -65,11 +65,10 @@ public class ZoneInfoCompiler {
 
     static Chronology cLenientISO;
 
-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
-        protected Boolean initialValue() {
-            return Boolean.FALSE;
-        }
-    };
+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
+    static {
+        cVerbose.set(Boolean.FALSE);
+    }
 
     /**
      * Gets a flag indicating that verbose logging is required.

```

# Time 12


Nb Executed tests: 11813

Nb Failing tests: 25

>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero3
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDate_Constructors#testFactory_fromCalendarFields_beforeYearZero3
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromDateFields_beforeYearZero3
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero1
>	org.joda.time.TestLocalDateTime_Constructors#testFactory_fromCalendarFields_beforeYearZero3

## Human Patch 

```Java
diff --git a/org/joda/time/LocalDate.java b/org/joda/time/LocalDate.java
index c86b9d7..7bb7a08 100644
--- a/org/joda/time/LocalDate.java
+++ b/org/joda/time/LocalDate.java
@@ -207,10 +206,8 @@ public final class LocalDate
         if (calendar == null) {
             throw new IllegalArgumentException("The calendar must not be null");
         }
-        int era = calendar.get(Calendar.ERA);
-        int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+            calendar.get(Calendar.YEAR),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
@@ -241,12 +238,6 @@ public final class LocalDate
         if (date == null) {
             throw new IllegalArgumentException("The date must not be null");
         }
-        if (date.getTime() < 0) {
-            // handle years in era BC
-            GregorianCalendar cal = new GregorianCalendar();
-            cal.setTime(date);
-            return fromCalendarFields(cal);
-        }
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
diff --git a/org/joda/time/LocalDateTime.java b/org/joda/time/LocalDateTime.java
index e75deca..325192b 100644
--- a/org/joda/time/LocalDateTime.java
+++ b/org/joda/time/LocalDateTime.java
@@ -196,10 +195,8 @@ public final class LocalDateTime
         if (calendar == null) {
             throw new IllegalArgumentException("The calendar must not be null");
         }
-        int era = calendar.get(Calendar.ERA);
-        int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+            calendar.get(Calendar.YEAR),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
@@ -234,12 +231,6 @@ public final class LocalDateTime
         if (date == null) {
             throw new IllegalArgumentException("The date must not be null");
         }
-        if (date.getTime() < 0) {
-            // handle years in era BC
-            GregorianCalendar cal = new GregorianCalendar();
-            cal.setTime(date);
-            return fromCalendarFields(cal);
-        }
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,

```

# Time 13


Nb Executed tests: 11753

Nb Failing tests: 4

>	org.joda.time.format.TestISOPeriodFormat#testFormatStandard_negative
>	junit.framework.TestSuite$1#warning
>	org.joda.time.format.TestISOPeriodFormat#testFormatStandard_negative
>	org.joda.time.format.TestISOPeriodFormat#testFormatStandard_negative

## Human Patch 

```Java
diff --git a/org/joda/time/format/PeriodFormatterBuilder.java b/org/joda/time/format/PeriodFormatterBuilder.java
index 29b0872..2471fce 100644
--- a/org/joda/time/format/PeriodFormatterBuilder.java
+++ b/org/joda/time/format/PeriodFormatterBuilder.java
@@ -1094,8 +1094,8 @@ public class PeriodFormatterBuilder {
             int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
-                // the minimum output is 0.000, which is 4 or 5 digits with a negative
-                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
+                // the minimum output is 0.000, which is 4 digits
+                sum = Math.max(sum, 4);
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
@@ -1130,7 +1130,6 @@ public class PeriodFormatterBuilder {
             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
-            int bufLen = buf.length();
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
@@ -1140,9 +1139,6 @@ public class PeriodFormatterBuilder {
             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
-                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
-                        buf.insert(bufLen, '-');
-                    }
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }

```

# Time 14


Nb Executed tests: 11723

Nb Failing tests: 25

>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusDays_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeEndOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_endOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusDays_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusDays_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeEndOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_endOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusDays_int_fromLeap
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusDays_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusMonths_int_negativeEndOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_endOfMonthAdjust
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_negativeFromLeap
>	org.joda.time.TestMonthDay_Basics#testMinusMonths_int_fromLeap
>	org.joda.time.TestMonthDay_Basics#testPlusDays_int_fromLeap

## Human Patch 

```Java
diff --git a/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
index 2892a2d..42a32e7 100644
--- a/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
+++ b/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
@@ -206,12 +206,6 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {
         if (valueToAdd == 0) {
             return values;
         }
-        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
-            // month is largest field and being added to, such as month-day
-            int curMonth0 = partial.getValue(0) - 1;
-            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
-            return set(partial, 0, values, newMonth);
-        }
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {

```

# Time 15


Nb Executed tests: 11687

Nb Failing tests: 7

>	org.joda.time.field.TestFieldUtils#testSafeMultiplyLongInt
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.field.TestFieldUtils#testSafeMultiplyLongInt
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	junit.framework.TestSuite$1#warning
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.field.TestFieldUtils#testSafeMultiplyLongInt

## Human Patch 

```Java
diff --git a/org/joda/time/field/FieldUtils.java b/org/joda/time/field/FieldUtils.java
index 1e045b2..55ed991 100644
--- a/org/joda/time/field/FieldUtils.java
+++ b/org/joda/time/field/FieldUtils.java
@@ -118,7 +118,8 @@ public class FieldUtils {
     public static int safeMultiply(int val1, int val2) {
         long total = (long) val1 * (long) val2;
         if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {
-          throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2);
+            throw new ArithmeticException
+                ("The calculation caused an overflow: " + val1 + " * " + val2);
         }
         return (int) total;
     }
@@ -127,26 +128,24 @@ public class FieldUtils {
      * Multiply two values throwing an exception if overflow occurs.
      * 
      * @param val1  the first value
-     * @param val2  the second value
+     * @param scalar  the second value
      * @return the new total
      * @throws ArithmeticException if the value is too big or too small
      * @since 1.2
      */
-    public static long safeMultiply(long val1, int val2) {
-        switch (val2) {
-            case -1:
-                if (val1 == Long.MIN_VALUE) {
-                    throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2);
-                }
-                return -val1;
-            case 0:
-                return 0L;
-            case 1:
-                return val1;
+    public static long safeMultiply(long val1, int scalar) {
+        switch (scalar) {
+        case -1:
+            return -val1;
+        case 0:
+            return 0L;
+        case 1:
+            return val1;
         }
-        long total = val1 * val2;
-        if (total / val2 != val1) {
-          throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2);
+        long total = val1 * scalar;
+        if (total / scalar != val1) {
+            throw new ArithmeticException
+                ("The calculation caused an overflow: " + val1 + " * " + scalar);
         }
         return total;
     }

```

# Time 16


Nb Executed tests: 11684

Nb Failing tests: 25

>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseEndYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_withDefaultYear_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseEndYear
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	junit.framework.TestSuite$1#warning
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseEndYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_withDefaultYear_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseEndYear
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseStartYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_baseEndYear
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_withDefaultYear_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthDay_feb29
>	org.joda.time.format.TestDateTimeFormatter#testParseInto_monthOnly_parseEndYear

## Human Patch 

```Java
diff --git a/org/joda/time/format/DateTimeFormatter.java b/org/joda/time/format/DateTimeFormatter.java
index baa276a..f92771a 100644
--- a/org/joda/time/format/DateTimeFormatter.java
+++ b/org/joda/time/format/DateTimeFormatter.java
@@ -706,7 +702,7 @@ public class DateTimeFormatter {
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
-            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {

```

# Time 17


Nb Executed tests: 11654

Nb Failing tests: 7

>	org.joda.time.TestDateTimeZoneCutover#testBug3476684_adjustOffset
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testBug3476684_adjustOffset
>	junit.framework.TestSuite$1#warning
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testBug3476684_adjustOffset

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index 7219899..ec05941 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -1161,37 +1161,14 @@ public abstract class DateTimeZone implements Serializable {
      * @return the adjusted instant millis
      */
     public long adjustOffset(long instant, boolean earlierOrLater) {
-        // a bit messy, but will work in all non-pathological cases
-        
-        // evaluate 3 hours before and after to work out if anything is happening
-        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
-        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
-        long offsetBefore = getOffset(instantBefore);
-        long offsetAfter = getOffset(instantAfter);
-        if (offsetBefore <= offsetAfter) {
-            return instant;  // not an overlap (less than is a gap, equal is normal case)
-        }
-        
-        // work out range of instants that have duplicate local times
-        long diff = offsetBefore - offsetAfter;
-        long transition = nextTransition(instantBefore);
-        long overlapStart = transition - diff;
-        long overlapEnd = transition + diff;
-        if (instant < overlapStart || instant >= overlapEnd) {
-          return instant;  // not an overlap
-        }
-        
-        // calculate result
-        long afterStart = instant - overlapStart;
-        if (afterStart >= diff) {
-          // currently in later offset
-          return earlierOrLater ? instant : instant - diff;
-        } else {
-          // currently in earlier offset
-          return earlierOrLater ? instant + diff : instant;
+        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
+        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
+        if (before == after) {
+            return instant;
         }
+        long local = convertUTCToLocal(instant);
+        return convertLocalToUTC(local, false, earlierOrLater ? after : before);
     }
-//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));
 
     //-----------------------------------------------------------------------
     /**

```

# Time 18


Nb Executed tests: 11624

Nb Failing tests: 7

>	org.joda.time.chrono.TestGJChronology#testLeapYearRulesConstruction
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	junit.framework.TestSuite$1#warning
>	org.joda.time.chrono.TestGJChronology#testLeapYearRulesConstruction
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.chrono.TestGJChronology#testLeapYearRulesConstruction

## Human Patch 

```Java
diff --git a/org/joda/time/chrono/GJChronology.java b/org/joda/time/chrono/GJChronology.java
index 0a19aa6..6131f14 100644
--- a/org/joda/time/chrono/GJChronology.java
+++ b/org/joda/time/chrono/GJChronology.java
@@ -360,22 +360,9 @@ public final class GJChronology extends AssembledChronology {
         }
 
         // Assume date is Gregorian.
-        long instant;
-        try {
-            instant = iGregorianChronology.getDateTimeMillis
-                (year, monthOfYear, dayOfMonth,
-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-        } catch (IllegalFieldValueException ex) {
-            if (monthOfYear != 2 || dayOfMonth != 29) {
-                throw ex;
-            }
-            instant = iGregorianChronology.getDateTimeMillis
-                (year, monthOfYear, 28,
-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-            if (instant >= iCutoverMillis) {
-                throw ex;
-            }
-        }
+        long instant = iGregorianChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis

```

# Time 19


Nb Executed tests: 11618

Nb Failing tests: 7

>	org.joda.time.TestDateTimeZoneCutover#testDateTimeCreation_london
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testDateTimeCreation_london
>	junit.framework.TestSuite$1#warning
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testDateTimeCreation_london

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index ec05941..855cad0 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {
                     return offsetLocal;
                 }
             }
-        } else if (offsetLocal >= 0) {
+        } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);

```

# Time 20


Nb Executed tests: 11609

Nb Failing tests: 7

>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseZoneDawsonCreek
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	junit.framework.TestSuite$1#warning
>	org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseZoneDawsonCreek
>	org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseZoneDawsonCreek
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object

## Human Patch 

```Java
diff --git a/org/joda/time/format/DateTimeFormatterBuilder.java b/org/joda/time/format/DateTimeFormatterBuilder.java
index ebb4b08..558a586 100644
--- a/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -2539,18 +2539,12 @@ public class DateTimeFormatterBuilder {
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
-            String best = null;
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
-                	if (best == null || id.length() > best.length()) {
-                		best = id;
-                	}
+                    bucket.setZone(DateTimeZone.forID(id));
+                    return position + id.length();
                 }
             }
-            if (best != null) {
-                bucket.setZone(DateTimeZone.forID(best));
-                return position + best.length();
-            }
             return ~position;
         }
     }

```

# Time 21


Nb Executed tests: 11603

Nb Failing tests: 10

>	org.joda.time.TestDateTimeZone#testGetName_berlin
>	org.joda.time.TestDateTimeZone#testGetShortName_berlin
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZone#testGetName_berlin
>	org.joda.time.TestDateTimeZone#testGetShortName_berlin
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestDateTimeZone#testGetName_berlin
>	org.joda.time.TestDateTimeZone#testGetShortName_berlin
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object

## Human Patch 

```Java
diff --git a/org/joda/time/tz/DefaultNameProvider.java b/org/joda/time/tz/DefaultNameProvider.java
index 89e6739..24423f8 100644
--- a/org/joda/time/tz/DefaultNameProvider.java
+++ b/org/joda/time/tz/DefaultNameProvider.java
@@ -62,37 +62,25 @@ public class DefaultNameProvider implements NameProvider {
         Map<String, Object> byNameKeyCache = byIdCache.get(id);
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
-            
-            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
-            String[] setEn = null;
-            for (String[] strings : zoneStringsEn) {
-              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
-                setEn = strings;
-                break;
-              }
-            }
-            String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
-            String[] setLoc = null;
-            for (String[] strings : zoneStringsLoc) {
-              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
-                setLoc = strings;
-                break;
-              }
-            }
-            
-            if (setEn != null && setLoc != null) {
-              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
-              // need to handle case where summer and winter have the same
-              // abbreviation, such as EST in Australia [1716305]
-              // we handle this by appending "-Summer", cf ZoneInfoCompiler
-              if (setEn[2].equals(setEn[4])) {
-                  byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]});
-              } else {
-                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
-              }
+            String[][] zoneStrings = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
+            for (int i=0; i<zoneStrings.length; i++) {
+                String[] set = zoneStrings[i];
+                if (set != null && set.length == 5 && id.equals(set[0])) {
+                    byNameKeyCache.put(set[2], new String[] {set[2], set[1]});
+                    // need to handle case where summer and winter have the same
+                    // abbreviation, such as EST in Australia [1716305]
+                    // we handle this by appending "-Summer", cf ZoneInfoCompiler
+                    if (set[2].equals(set[4])) {
+                        byNameKeyCache.put(set[4] + "-Summer", new String[] {set[4], set[3]});
+                    } else {
+                        byNameKeyCache.put(set[4], new String[] {set[4], set[3]});
+                    }
+                    break;
+                }
             }
         }
-        return (String[]) byNameKeyCache.get(nameKey);
+
+        return (String[])byNameKeyCache.get(nameKey);
     }
 
     private HashMap createCache() {

```

# Time 22


Nb Executed tests: 11535

Nb Failing tests: 31

>	org.joda.time.TestDuration_Basics#testToPeriod_fixedZone
>	org.joda.time.TestPeriod_Constructors#testConstructor_long_fixedZone
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDuration_Basics#testToPeriod_fixedZone
>	org.joda.time.TestDuration_Basics#testToPeriod_fixedZone
>	org.joda.time.TestPeriod_Constructors#testConstructor_long_fixedZone
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestPeriod_Constructors#testConstructor_long_fixedZone

## Human Patch 

```Java
diff --git a/org/joda/time/MutablePeriod.java b/org/joda/time/MutablePeriod.java
index 78db791..4e40d55 100644
--- a/org/joda/time/MutablePeriod.java
+++ b/org/joda/time/MutablePeriod.java
@@ -177,7 +177,7 @@ public class MutablePeriod
      * @param duration  the duration, in milliseconds
      */
     public MutablePeriod(long duration) {
-        super(duration);
+        super(duration, null, null);
     }
 
     /**
diff --git a/org/joda/time/Period.java b/org/joda/time/Period.java
index 7ec8072..1e0a6d8 100644
--- a/org/joda/time/Period.java
+++ b/org/joda/time/Period.java
@@ -379,7 +379,7 @@ public final class Period
      * @param duration  the duration, in milliseconds
      */
     public Period(long duration) {
-        super(duration);
+        super(duration, null, null);
     }
 
     /**
diff --git a/org/joda/time/base/BasePeriod.java b/org/joda/time/base/BasePeriod.java
index a5dcb74..e2da9f0 100644
--- a/org/joda/time/base/BasePeriod.java
+++ b/org/joda/time/base/BasePeriod.java
@@ -211,24 +210,6 @@ public abstract class BasePeriod
     }
 
     /**
-     * Creates a period from the given millisecond duration with the standard period type
-     * and ISO rules, ensuring that the calculation is performed with the time-only period type.
-     * <p>
-     * The calculation uses the hour, minute, second and millisecond fields.
-     *
-     * @param duration  the duration, in milliseconds
-     */
-    protected BasePeriod(long duration) {
-        super();
-        // bug [3264409]
-        iType = PeriodType.time();
-        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
-        iType = PeriodType.standard();
-        iValues = new int[8];
-        System.arraycopy(values, 0, iValues, 4, 4);
-    }
-
-    /**
      * Creates a period from the given millisecond duration, which is only really
      * suitable for durations less than one day.
      * <p>

```

# Time 23


Nb Executed tests: 11529

Nb Failing tests: 28

>	org.joda.time.TestDateTimeZone#testForID_String_old
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZone#testForID_String_old
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestDateTimeZone#testForID_String_old
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index 855cad0..004821a 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -561,32 +561,31 @@ public abstract class DateTimeZone implements Serializable {
             // Backwards compatibility with TimeZone.
             map = new HashMap<String, String>();
             map.put("GMT", "UTC");
-            map.put("WET", "WET");
-            map.put("CET", "CET");
-            map.put("MET", "CET");
-            map.put("ECT", "CET");
-            map.put("EET", "EET");
             map.put("MIT", "Pacific/Apia");
-            map.put("HST", "Pacific/Honolulu");  // JDK 1.1 compatible
+            map.put("HST", "Pacific/Honolulu");
             map.put("AST", "America/Anchorage");
             map.put("PST", "America/Los_Angeles");
-            map.put("MST", "America/Denver");  // JDK 1.1 compatible
+            map.put("MST", "America/Denver");
             map.put("PNT", "America/Phoenix");
             map.put("CST", "America/Chicago");
-            map.put("EST", "America/New_York");  // JDK 1.1 compatible
-            map.put("IET", "America/Indiana/Indianapolis");
+            map.put("EST", "America/New_York");
+            map.put("IET", "America/Indianapolis");
             map.put("PRT", "America/Puerto_Rico");
             map.put("CNT", "America/St_Johns");
-            map.put("AGT", "America/Argentina/Buenos_Aires");
+            map.put("AGT", "America/Buenos_Aires");
             map.put("BET", "America/Sao_Paulo");
+            map.put("WET", "Europe/London");
+            map.put("ECT", "Europe/Paris");
             map.put("ART", "Africa/Cairo");
             map.put("CAT", "Africa/Harare");
+            map.put("EET", "Europe/Bucharest");
             map.put("EAT", "Africa/Addis_Ababa");
+            map.put("MET", "Asia/Tehran");
             map.put("NET", "Asia/Yerevan");
             map.put("PLT", "Asia/Karachi");
-            map.put("IST", "Asia/Kolkata");
+            map.put("IST", "Asia/Calcutta");
             map.put("BST", "Asia/Dhaka");
-            map.put("VST", "Asia/Ho_Chi_Minh");
+            map.put("VST", "Asia/Saigon");
             map.put("CTT", "Asia/Shanghai");
             map.put("JST", "Asia/Tokyo");
             map.put("ACT", "Australia/Darwin");

```

# Time 24


Nb Executed tests: 11523

Nb Failing tests: 46

>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2016
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	junit.framework.TestSuite$1#warning
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2016
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_weekyear_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2010
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2011
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2012
>	org.joda.time.format.TestDateTimeFormatter#testParseLocalDate_year_month_week_2016

## Human Patch 

```Java
diff --git a/org/joda/time/format/DateTimeParserBucket.java b/org/joda/time/format/DateTimeParserBucket.java
index 7c37fc1..b985cef 100644
--- a/org/joda/time/format/DateTimeParserBucket.java
+++ b/org/joda/time/format/DateTimeParserBucket.java
@@ -352,11 +352,6 @@ public class DateTimeParserBucket {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
-            if (resetFields) {
-                for (int i = 0; i < count; i++) {
-                    millis = savedFields[i].set(millis, i == (count - 1));
-                }
-            }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage("Cannot parse \"" + text + '"');

```

# Time 25


Nb Executed tests: 11475

Nb Failing tests: 34

>	org.joda.time.TestDateTimeZoneCutover#test_DateTime_constructor_Moscow_Autumn
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn_overlap_mins
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#test_DateTime_constructor_Moscow_Autumn
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn_overlap_mins
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#test_DateTime_constructor_Moscow_Autumn
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn_overlap_mins
>	org.joda.time.TestDateTimeZoneCutover#test_getOffsetFromLocal_Moscow_Autumn

## Human Patch 

```Java
diff --git a/org/joda/time/DateTimeZone.java b/org/joda/time/DateTimeZone.java
index 81f5872..23f70a5 100644
--- a/org/joda/time/DateTimeZone.java
+++ b/org/joda/time/DateTimeZone.java
@@ -866,22 +866,18 @@ public abstract class DateTimeZone implements Serializable {
      * Input: 02:00  Output: 02:00<br />
      * Input: 02:30  Output: 02:30<br />
      * <p>
-     * During a DST overlap (where the local time is ambiguous) this method will return
-     * the earlier instant. The combination of these two rules is to always favour
-     * daylight (summer) time over standard (winter) time.
-     * <p>
-     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
-     * Prior to v1.5, the DST gap behaviour was also not defined.
+     * NOTE: The behaviour of this method changed in v1.5, with the emphasis
+     * on returning a consistent result later along the time-line (shown above).
      *
-     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
+     * @param instantLocal  the millisecond instant, relative to this time zone, to
+     * get the offset for
      * @return the millisecond offset to subtract from local time to get UTC time
      */
     public int getOffsetFromLocal(long instantLocal) {
         // get the offset at instantLocal (first estimate)
-        final int offsetLocal = getOffset(instantLocal);
+        int offsetLocal = getOffset(instantLocal);
         // adjust instantLocal using the estimate and recalc the offset
-        final long instantAdjusted = instantLocal - offsetLocal;
-        final int offsetAdjusted = getOffset(instantAdjusted);
+        int offsetAdjusted = getOffset(instantLocal - offsetLocal);
         // if the offsets differ, we must be near a DST boundary
         if (offsetLocal != offsetAdjusted) {
             // we need to ensure that time is always after the DST gap
@@ -890,21 +886,12 @@ public abstract class DateTimeZone implements Serializable {
                 // if we just return offsetAdjusted then the time is pushed
                 // back before the transition, whereas it should be
                 // on or after the transition
-                long nextLocal = nextTransition(instantAdjusted);
+                long nextLocal = nextTransition(instantLocal - offsetLocal);
                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
                 if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
             }
-        } else if (offsetLocal > 0) {
-            long prev = previousTransition(instantAdjusted);
-            if (prev < instantAdjusted) {
-                int offsetPrev = getOffset(prev);
-                int diff = offsetPrev - offsetLocal;
-                if (instantAdjusted - prev <= diff) {
-                    return offsetPrev;
-                }
-            }
         }
         return offsetAdjusted;
     }

```

# Time 26


Nb Executed tests: 11463

Nb Failing tests: 49

>	org.joda.time.TestDateTimeZoneCutover#testWithSecondOfMinuteInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange_mockZone
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_usCentral
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_Paris_summer
>	org.joda.time.TestDateTimeZoneCutover#testWithHourOfDayInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_NewYork_winter
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_ausNSW
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testWithSecondOfMinuteInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange_mockZone
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_usCentral
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_Paris_summer
>	org.joda.time.TestDateTimeZoneCutover#testWithHourOfDayInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_NewYork_winter
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_ausNSW
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.TestDateTimeZoneCutover#testWithSecondOfMinuteInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMinuteOfHourInDstChange_mockZone
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_usCentral
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_Paris_summer
>	org.joda.time.TestDateTimeZoneCutover#testWithHourOfDayInDstChange
>	org.joda.time.TestDateTimeZoneCutover#testWithMillisOfSecondInDstChange_NewYork_winter
>	org.joda.time.TestDateTimeZoneCutover#testBug2182444_ausNSW

## Human Patch 

```Java
diff --git a/org/joda/time/chrono/ZonedChronology.java b/org/joda/time/chrono/ZonedChronology.java
index 819f64e..f165f3d 100644
--- a/org/joda/time/chrono/ZonedChronology.java
+++ b/org/joda/time/chrono/ZonedChronology.java
@@ -433,7 +433,7 @@ public final class ZonedChronology extends AssembledChronology {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
-               return iZone.convertLocalToUTC(localInstant, false, instant);
+               return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -445,7 +445,7 @@ public final class ZonedChronology extends AssembledChronology {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
-               return iZone.convertLocalToUTC(localInstant, false, instant);
+               return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -457,14 +457,14 @@ public final class ZonedChronology extends AssembledChronology {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
-                return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
-            long result = iZone.convertLocalToUTC(localInstant, false, instant);
+            long result = iZone.convertLocalToUTC(localInstant, false);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     "Illegal instant due to time zone offset transition: " +
@@ -478,7 +478,7 @@ public final class ZonedChronology extends AssembledChronology {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
-            return iZone.convertLocalToUTC(localInstant, false, instant);
+            return iZone.convertLocalToUTC(localInstant, false);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -525,7 +525,7 @@ public final class ZonedChronology extends AssembledChronology {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
-                return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -537,7 +537,7 @@ public final class ZonedChronology extends AssembledChronology {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
-                return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
diff --git a/org/joda/time/field/LenientDateTimeField.java b/org/joda/time/field/LenientDateTimeField.java
index 6cf4c71..450a4ef 100644
--- a/org/joda/time/field/LenientDateTimeField.java
+++ b/org/joda/time/field/LenientDateTimeField.java
@@ -72,6 +72,6 @@ public class LenientDateTimeField extends DelegatedDateTimeField {
         long localInstant = iBase.getZone().convertUTCToLocal(instant);
         long difference = FieldUtils.safeSubtract(value, get(instant));
         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
-        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);
+        return iBase.getZone().convertLocalToUTC(localInstant, false);
     }
 }

```

# Time 27


Nb Executed tests: 11292

Nb Failing tests: 79

>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestPeriodFormatterBuilder#testBug2495455
>	org.joda.time.TestMinutes#testFactory_parseMinutes_String
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object1
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object2
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object3
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object4
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object5
>	org.joda.time.convert.TestStringConverter#testSetIntoPeriod_Object6
>	org.joda.time.TestYears#testFactory_parseYears_String
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard1
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard2
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard3
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard4
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard5
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard6
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard8
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard9
>	org.joda.time.TestSeconds#testFactory_parseSeconds_String
>	org.joda.time.TestMutablePeriod_Basics#testToString
>	org.joda.time.TestPeriod_Basics#testToString_nullPeriodFormatter
>	org.joda.time.TestPeriod_Basics#testToString
>	org.joda.time.TestMutablePeriod_Basics#testToString
>	org.joda.time.TestYears#testFactory_parseYears_String
>	org.joda.time.TestMonths#testFactory_parseMonths_String
>	org.joda.time.TestWeeks#testFactory_parseWeeks_String
>	org.joda.time.TestDays#testFactory_parseDays_String
>	org.joda.time.TestHours#testFactory_parseHours_String
>	org.joda.time.TestMinutes#testFactory_parseMinutes_String
>	org.joda.time.TestSeconds#testFactory_parseSeconds_String
>	org.joda.time.TestMonths#testFactory_parseMonths_String
>	junit.framework.TestSuite$1#warning
>	org.joda.time.TestPeriod_Basics#testToString_nullPeriodFormatter
>	org.joda.time.TestPeriod_Basics#testToString
>	org.joda.time.format.TestPeriodFormatter#testPrint_bufferMethods
>	org.joda.time.format.TestPeriodFormatter#testParseMutablePeriod_simple
>	org.joda.time.format.TestPeriodFormatter#testPrinterParserMethods
>	org.joda.time.format.TestPeriodFormatter#testPrint_writerMethods
>	org.joda.time.format.TestPeriodFormatter#testParsePeriod_parseType
>	org.joda.time.format.TestPeriodFormatter#testPrint_simple
>	org.joda.time.format.TestPeriodFormatter#testParseInto_simple
>	org.joda.time.format.TestPeriodFormatter#testParsePeriod_simple
>	org.joda.time.format.TestISOPeriodFormat#testFormatStandard
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard1
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard2
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard3
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard4
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard5
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard6
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard8
>	org.joda.time.format.TestISOPeriodFormatParsing#testParseStandard9
>	org.joda.time.format.TestPeriodFormatterBuilder#testBug2495455
>	org.joda.time.TestHours#testFactory_parseHours_String
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYWD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionMS
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedD
>	org.joda.time.TestParseISO#testSpecTimeComplete
>	org.joda.time.TestParseISO#testSpecTimeTruncatedMS
>	org.joda.time.TestParseISO#testSpecTruncatedYMD
>	org.joda.time.TestParseISO#testSpecTimeTruncatedM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedS
>	org.joda.time.TestParseISO#testSpecWeekTruncatedD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedW
>	org.joda.time.TestParseISO#testSpecWeekTruncatedWD
>	org.joda.time.TestParseISO#testSpecWeekTruncatedYW
>	org.joda.time.TestParseISO#testSpecTruncatedD
>	org.joda.time.TestParseISO#testSpecTruncatedM
>	org.joda.time.TestParseISO#testSpecTruncatedY
>	org.joda.time.TestParseISO#testSpecOrdinalTruncatedYD
>	org.joda.time.TestParseISO#testSpecReducedPrecisionC
>	org.joda.time.TestParseISO#testSpecTruncatedMD
>	org.joda.time.TestParseISO#testSpecTruncatedYM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionM
>	org.joda.time.TestParseISO#testSpecTimeTruncatedFractionS
>	org.joda.time.convert.TestReadableDurationConverter#testSetInto_Object
>	org.joda.time.format.TestISOPeriodFormat#testFormatStandard
>	org.joda.time.format.TestPeriodFormatterBuilder#testBug2495455
>	org.joda.time.TestWeeks#testFactory_parseWeeks_String

## Human Patch 

```Java
diff --git a/org/joda/time/format/PeriodFormatterBuilder.java b/org/joda/time/format/PeriodFormatterBuilder.java
index f7c7738..f78830c 100644
--- a/org/joda/time/format/PeriodFormatterBuilder.java
+++ b/org/joda/time/format/PeriodFormatterBuilder.java
@@ -798,11 +798,9 @@ public class PeriodFormatterBuilder {
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
-            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
-                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
-                sep = sep.finish(f.getPrinter(), f.getParser());
-                return new PeriodFormatter(sep, sep);
-            }
+            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
+            sep = sep.finish(f.getPrinter(), f.getParser());
+            return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {

```

